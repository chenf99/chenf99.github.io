<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-031]]></title>
    <url>%2F2018%2F09%2F09%2Fleetcode-031%2F</url>
    <content type="text"><![CDATA[题目 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1234&gt; 1,2,3 → 1,3,2&gt; 3,2,1 → 1,2,3&gt; 1,1,5 → 1,5,1&gt; 分析这道题目的意思是给出一个序列，要求给出它的下一个置换，即按照字典序比它大的最小的那个序列。如果找不到这样的置换，那么就输出最小的那个序列(即按升序排序)。in-place的意思是让我们在交换元素时不要花费过多空间，花费的额外空间只能是常量。 解法首先要判断是否有下一个置换，这可能不太直观，但判断没有下一个置换是很容易的：当序列已经是降序时就已经是最大的序列了，当然就不存在下一个置换，此时只要将它反过来就可以得到所求序列。因此，只要序列不是降序的，那么置换就存在。 要判断序列是否是降序，可以采取从后往前遍历的方式，如果相邻的两个元素，后面那个(right)一直比前面那个(left)小，那么就是降序的。当我们找到这样两个元素:right &gt; left时，就找到求下一个置换的突破口了，因为这意味着在left后面的那一段子序列都是降序的，已经不存在下一个置换了，即是时候把left这个位置的元素的值变大了。 找到这样的left之后我的第一个想法是把它与后面那段子序列中比它大的最小的那个元素交换位置，再把子序列排序，这样就得到了比原始序列大的最小的序列，即下一个置换。这样的确是可以得到答案的，但是这样我们就使用了排序了，复杂度就成了O(n2)，算法自然就没那么好了。 实际上，我们知道那段子序列是降序的，那么只要把它反过来就是一个升序的序列了，这样的时间复杂度是O(n)，排好序后再去找比left大的最小的那个元素，交换它们的位置就好了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 1) return; bool flag = false; //是否存在下一个置换 int index; for (index = len - 1; index &gt; 0; --index) &#123;//找left和right if (nums[index] &gt; nums[index - 1]) &#123; flag = true; break; &#125; &#125; if (flag == false) reverse(nums.begin(), nums.end());//没有下一个置换 reverse(nums.begin() + index, nums.end()); int small_index = -1; for (int i = index; i &lt; len; ++i) &#123;//找比left大的最小元素 if (nums[i] &gt; nums[index - 1]) &#123; if (small_index == -1) small_index = i; else if (nums[i] &lt; nums[small_index]) small_index = i; &#125; &#125; int temp = nums[small_index]; nums[small_index] = nums[index - 1]; nums[index - 1] = temp; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox + CentOS让PC提供云服务]]></title>
    <url>%2F2018%2F09%2F09%2Fcentos-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BA%91%2F</url>
    <content type="text"><![CDATA[前期准备安装Git客户端直接百度git for windows即可找到官网的下载链接，安装好对应系统版本后应在任何地方右键鼠标都会出现git bash here： 安装VirtualBox直接到官网下载最新版本的安装包并安装，在Downloads界面选择windows版本的： 配置VirtualBox 点击管理-&gt;全局设定-&gt;常规，设置默认虚拟电脑存储位置，最好把默认的C盘路径改掉，方便自己查找，同时也不消耗系统盘空间。 创建虚拟机内部虚拟网络，使得 Vbox 内部虚拟机可以通过它，实现虚拟机之间、虚拟机与主机的通讯： 管理-&gt;主机网络管理器-&gt;创建，创建一块虚拟网卡，并把IPv4地址设为：192.168.100.1/24，这是虚拟内部网络host的默认地址(这一步好像有同学创建不了，据说回退到4.3版本可以，但他直接换Vmware了…) 用cmd输入ipconfig可以查看到刚创建的网卡VirtualBox Host-Only Network #2: 第一个是本机的网卡，可以通过它看到本机的ip地址，这在之后会有用到。 下载CentOS镜像直接到官网下载Minimal ISO镜像即可，点击Minimal ISO后进入下载界面选第一个就好了 安装虚拟机安装第一个虚拟机进入VirtualBox，点击新建，在名称那里输入centos，就会自动选择类型和版本了： 注意：如果没有64位选择的话，有几种可能： 电脑不是64位的 电脑未开启硬件可虚拟化，具体解决方法是进入BIOS把对应可虚拟化的选项设为enable,一般是Intel Virtual Technology 电脑开启了hyper-v，解决方法是进入控制面板-&gt;卸载程序-&gt;启用或关闭Windows功能，取消选择hyper-v即可，重启就可以了 选好后继续安装，点击下一步，分配内存依据自己电脑配置，2G差不多了，然后创建虚拟硬盘，选择现在创建虚拟硬盘，文件类型选择VDI，动态分配和固定大小按自己个人喜好选就好，文件位置一般会自动选择在之前设置的默认虚拟电脑位置文件夹下，大小选择分配30G，方便以后扩展，然后就创建好了。 接下来选择刚创建的虚拟机点击设置，在系统那里把启动顺序设为硬盘第一(不然装好系统后再次启动可能又会进入安装系统界面)；存储那里点击没有盘片： 然后选择之前下载的Minimal ISO；在网络那里第一块网卡默认NAT，第二块网卡选择Host-Only,接口就是前面创建的虚拟网卡： 设置好之后就可以点击启动来安装系统了，选择Install Centos 7，选择语言后点击继续， 在这个界面要注意两个地方，一个是黄色感叹号那个选项，点击进入后选择安装位置，就选之前分配的虚拟硬盘，然后还要注意点击NETWORK &amp; HOST NAME，进去把网络连接打开， 然后就可以安装了，在这个过程中还可以设置root密码和添加用户。 安装好之后进入系统，首先进行升级OS内核： 获取wget：sudo yum install wget 配置源163源或者阿里云源： 具体操作为(以163源为例): 备份/etc/yum.repos.d/CentOS-Base.repo(即改名): 1sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 进入yum源配置文件：cd /etc/yum.repos.d 下载网易163源： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 下载好后把163源设置为默认源： 1sudo mv CentOS7-Base-163.repo CentOS-Base.repo 然后生成缓存： 12yum clean allyum makecache 升级OS内核：sudo yum update 升级内核之后进行下一步，检查网卡配置： 输入nmtui，配置第二块网卡地址： 选择第一项，然后选择第二个网卡的edit: 在IPv4那里点击Show，在下面的Addresses点击Add，配置第二块网卡地址，格式如192.168.100.50/24, 然后退出nmtui界面。 ping主机，如ping 192.168.100.1 第一个虚拟机的操作完成，关闭虚拟机。 安装第二个虚拟机利用虚拟机复制功能，直接获取新虚拟机：右键之前创建的虚拟机，选择复制，为新虚拟机取名并一定要选择重新初始化所有网卡的 MAC 地址： 然后选链接复制，完成。 启动新的虚拟机，配置主机名和第二块网卡： 配置主机名要使用sudo nmtui，修改网卡地址操作与之前相同，但地址变为了192.168.100.100/24。改好后回退到nmtui的第一个界面，选择第二项来激活第二个网卡，两个网卡名前面都有*号就表示都已激活。 再回到nmtui的第一个界面选第三项，更改主机名，改完后退出，重启。 重启后需重新激活第二个网卡，在windows上进入git bash，ping刚才修改的地址，即ping 192.168.100.100： 通过ssh来访问该虚拟机。到官网下载putty,安装后启动，输入虚拟机第二块网卡的地址，点击open即可连接到虚拟机(windows需启动git bash)： 此时已经差不多完成了，能通过ssh访问到虚拟机就已经搭好私有云环境了，但为了centos更方便使用，继续安装centos桌面： 首先重新配置虚拟机的CPU、内存、显存，因为使用centos桌面对配置要求更高。先关闭虚拟机，选择对应的虚拟机后点击设置来进行配置，CPU 1~2个，内存2G或4G，显存越大越好，同时勾选启动3D加速 启动虚拟机，安装桌面sudo yum groupinstall &quot;GNOME Desktop&quot;,这个很大，耗费时间比较长，需要耐心等待，如果下载不成功，可能需要更换yum源 安装好后设置启动目标为桌面，然后重启: 1ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 此时我们已经可以通过图形化界面来使用centos，但因为虚拟机对鼠标的捕获很不友好，导致使用很不方便，而且也不能全屏，那么就需要安装VirtualBox的扩展功能了： 先安装kernel-devel和gcc：sudo yum install -y kernel-devel gcc 点击VirtuaBox的设备-&gt;安装增强功能，此时可能会报错： 这个错误挺常见的，也容易解决： 弹出后再选择安装增强功能就好了： 点击Run即可开始安装。 装好之后重启时突然报错：Failed to load selinux policy.然后就一直卡在进度条满的状态，无法进入系统，重启很多次也没用，上网查之后发现是因为/etc/selinux/config配置文件不对，虽然我没有修改这个文件，但还是试了试网上方法： 首先在启动时选择启动项的界面按e进入grub编辑界面： 进入grub编辑界面后找到linux16那一行，在最后面的LANG=zh_CN.UTF-8之后空格，加上selinux=0，如上图所示，然后Ctrl + X启动即可进入系统 进入系统后当然要解决这个问题了，sudo vi /etc/selinux/config,可以看到SELINUX=enforcing,我们要做的是改成disabled,且记SELINUXTYPE=targeted原始配置不用改！ 解决上个那个错误后重启就发现增强功能已经装好了，鼠标可以自由移动，也可以全屏了。 接下来安装Google Chrome(可选)： 直接去官网下载可能会被墙，可以移步国内新浪科技网下载，选择正式版RPM，直接下载 进入下载的安装包所在路径，利用yum来安装sudo yum localinstall google-chrome-stable_current_x86_64.rpm,yum会自动分析依赖，并完成安装 在这里插入一个可能的问题：有了图形化界面后我们就可以很方便地通过设置来把第二块网卡设置自动激活了，避免每次开机都要手动激活的痛苦。在这个过程中我发现了一个问题，貌似系统把我之前设置的第二块网卡的IPv4地址修改了： 现在的地址是192.168.100.4，而之前我是把它设置成了192.168.100.100，而且貌似修改后重启又会变成这个，干脆就使用这个地址吧，在使用ssh访问的时候要注意IP地址的变化。 使用远程桌面访问虚拟机安装扩展包首先关闭所有虚拟机，然后去VirtualBox官网下载扩展包，在下载界面选择VirtualBox 5.2.18 Oracle VM VirtualBox Extension Pack(扩展包版本要与VBox版本相同)： 下载好后点击管理-&gt;全局设定-&gt;扩展，点击添加新包，找到正确的扩展包并添加 装好扩展包后重启Windows(注意不是重启虚拟机) 设置虚拟机端口点击对应的虚拟机，点击设置后选择显示，在远程桌面那里启用服务器，然后设置端口号，这里需要注意每台虚拟机的端口号必须不同，因此最好手动修改端口号而不是使用默认。认证方式选择空，我使用外部的认证方式无法连接： 使用远程桌面直接在win10小娜姐姐那里输入远程，就可以启动windows自带的远程桌面连接，在计算机一栏那里输入的地址为本机IP地址:端口号，注意是本机地址，不是虚拟机的地址！！ 再点击连接，就成功啦： 注： 部分同学发现在不开启第二块网卡时虚拟机可以ping到192.168.100.1,但开启了第二块网卡之后就不行了，经大佬提示后发现是windows防火墙的问题…关闭之后就好了，不过没有必要，因为已经可以实现远程访问了。]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-004]]></title>
    <url>%2F2018%2F09%2F07%2Fleetcode-004%2F</url>
    <content type="text"><![CDATA[题目Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析这个题目的意思是给出两个已排好序的数组，要求我们给出包含两个数组中所有数的中位数。我首先想到的方法是利用两个循环变量i， j来同时遍历这两个数组 nums1、nums2 ，当 nums1[i] &lt; nums2[j]时i++ ，否则 j++ ，并且选出小的那个数，直到总共遍历了(m + n) / 2 个元素，有点类似于合并两个有序链表的算法。此时就可以找到中位数了： 如果总数是奇数，那么中位数就是最后一个选出来的数 如果总数是偶数，那么中位数就是最后两个选出来的数的平均数 代码如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m == 0) return n % 2 == 0 ? (nums2[n/2 - 1] + nums2[n/2]) / 2.0 : nums2[n/2]; else if (n == 0) return m % 2 == 0 ? (nums1[m/2 - 1] + nums1[m/2]) / 2.0 : nums1[m/2]; int mid = (m + n) / 2; vector&lt;int&gt; sortedArr; for (int i = 0, j = 0; i + j &lt;= mid; ) &#123; if (i == m) sortedArr.push_back(nums2[j++]); else if (j == n) sortedArr.push_back(nums1[i++]); else if (nums1[i] &lt;= nums2[j]) sortedArr.push_back(nums1[i++]); else sortedArr.push_back(nums2[j++]); &#125; return (m + n) % 2 == 0 ? (sortedArr[mid - 1] + sortedArr[mid]) / 2.0 : sortedArr[mid]; &#125;&#125;; 这种方法的时间复杂度是 O((m + n) / 2), 并不满足题目要求的O(log(m + n)) ,因此还是得找效率更高的方法。 解法实际上看到有 log 的复杂度，我们就应该想到要使用分治法，但这题要怎么使用二分法来把两个有序数组合并起来并找到中位数呢？其实，我们并不需要非得这样做，从中位数的定义入手，我们可以知道，如果数组中的一个数在把数组分成长度相等的两部分，且一部分的数值总大于等于另一部分，那这个数就是中位数，即： 把数组nums1 分成两个部分： 1nums1[0],nums1[1]...nums1[i - 1] | nums1[i], nums1[i + 1]...nums[m - 1] 左边部分数目为i，右边部分数目为m - i且 max(left) &lt;= min(right)当i = m - i 时（nums1[i - 1] + nums1[i]) / 2就是中位数 同理，我们无需把两个数组合并起来排序再找中位数，只需要把它们分成两个长度相等的部分，并使max(left) &lt;= min(right)就可以找到中位数了，即： 12nums1[0]...nums1[i - 1] | nums1[i]...nums1[m - 1]nums2[0]...nums2[j - 1] | nums2[j]...nums2[n - 1] 长度相等即: i + j = m - i + n - j ,当总长度为奇数时左边会比右边少一个 max(left) &lt;= min(right) 即: nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]。 那么现在我们的问题就变成了找到这样的 i和j来满足上面两个条件。 i 的范围是 [0, m] ，由第一个条件可以知道 j = (m + n) / 2 - i ,当 m &lt;= n 时 j &gt;= 0 ，否则为负数 现在我们就可以用二分法来解决这个问题了，伪代码如下： 123456781.imin = 0, imax = m2.j = (m + n) / 2 - i3. if nums1[i - 1] &gt; nums2[j] imax = i - 1 //i较大，因此需要减小遍历i的范围 else if nums2[j - 1] &gt; nums1[i] imin = i + 1 //i较小，因此需要增大遍历i的范围 else //找到了合适的i if (m + n) % 2 == 0 return (max(left) + min(right)) / 2.0 else return min(right) 当然我们需要考虑临界问题：i = 0, i = m, j = 0, j = n时怎么办？访问nums1[i - 1],nums2[j],nums2[j - 1],nums1[i]是可能越界的。 实际上，由j = (m + n) / 2 - i ，0 &lt; i &lt; m， n &gt;= m可知0 &lt; j &lt; n，因此我们只需要判断i的临界范围就可以了。 对于nums1[i - 1] &gt; nums2[j],需加上i &gt; imin的判断，防止读取到nums1[-1]和nums2[n] 对于nums2[j - 1] &gt; nums1[i],需加上i &lt; imax的判断，防止读取到nums2[-1]和nums1[m] 最终代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m &gt; n) &#123; //确保n&gt;=m nums1.swap(nums2); int temp = m; m = n; n = temp; &#125; int imin = 0, imax = m, mid = (m + n) / 2; while (imin &lt;= imax) &#123; int i = (imin + imax) / 2; int j = mid - i; if (i &gt; imin &amp;&amp; nums1[i - 1] &gt; nums2[j]) imax = i - 1; else if (i &lt; imax &amp;&amp; nums2[j - 1] &gt; nums1[i]) imin = i + 1; else &#123;//找到了使max(left) &lt; min(right)的i int minRight; if (i == m) minRight = nums2[j]; else if (j == n) minRight = nums1[i]; else minRight = min(nums1[i], nums2[j]); if ((m + n) % 2 != 0) return minRight; int maxLeft; if (i == 0) maxLeft = nums2[j - 1]; else if (j == 0) maxLeft = nums1[i - 1]; else maxLeft = max(nums1[i - 1], nums2[j - 1]); return (maxLeft + minRight) / 2.0; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
</search>
