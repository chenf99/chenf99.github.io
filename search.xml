<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang入门:环境配置]]></title>
    <url>%2F2018%2F09%2F27%2FGolang%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言在前一篇博客中我们学习了如何配置Centos私有云，下一步我们将要学习Go语言编程。 什么是Go语言？ Go语言由Google于2009年发布，它是一种静态强类型、编译型、并发型、解释型的编程语言，并且具有便利的垃圾回收和强大的运行时反射。 Go语言是简洁的和有效率的，实用性很强。 要学习Go语言编程，第一步就是要学习配置需要的相关环境。 Centos安装Golang有两种方法可以安装Golang: 下载最新版本的go1.11.linux-amd64.tar.gz，然后解压并配置环境变量，这种方法相对复杂些 利用系统包管理工具直接下载Golang，这种方法简单。但Golang不是最新版本的，但也不影响使用 安装最新版Golang下载二进制包可以去官网下载，也可以利用wget工具自动下载： 1wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz 然后解压，可以指定解压到的目录： 1sudo tar -zxvf go1.11.linux-amd64.tar.gz -C /opt/ 记得一定要加上-C(大写)这个参数，创建默认文件夹才能被成功解压，否则报错如下： 设置环境变量，sudo vi /etc/profile，在底部加上 12export GOROOT=/opt/goexport PATH=$PATH:$GOROOT/bin 然后source /etc/profile更新环境变量，再使用go version检查配置是否正常： 我们可以使用go env来查看Go的环境变量，其中比较重要的是GOROOT和GOPATH，GOROOT里面放置系统代码和中间文件，而GOPATH可以作为我们的工作空间。GOROOT和GOPATH中都有三个子目录： src:存放被组织成包的源代码(.go .c .h .s等) pkg:存放编译后生成的文件(.a) bin:存放编译后生成的可执行文件 为了方便，可以把bin加入到 $PATH 变量中，便于直接运行Go程序 创建工作空间： 12 修改配置文件，sudo vi /etc/profile： 12 更新配置文件后可以通过go env来查看是否设置成功。 利用包管理工具安装Golang1sudo yum install golang 查看Golang安装的目录： 1rpm -ql golang |more 测试安装： 1go version 然后是创建工作空间和配置GOPATH、PATH这两个环境变量，步骤同上。 安装工具和插件安装VSCode安装过程参考官方给出的教程： 12 然后就可以打开VSCode了。 编写Hello，World首先创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 然后使用VSCode编写一个hello.go文件(VSCode会提示安装Go相关插件)： 1234567package mainimport "fmt"func main() &#123; fmt.Printf("hello, world\n")&#125; 在终端运行： 安装git客户端由于Go语言的插件主要在github上，因此git客户端必不可少 1sudo yum install git 但这样安装的git太老，总觉得用着不舒服，因此我选择更新： 首先移除安装的旧版本 1sudo yum remove git 安装所需的软件包 123sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develsudo yum install gcc perl-ExtUtils-MakeMaker 去官网下载安装包并解压 12wget https://www.kernel.org/pub/software/scm/git/git-2.9.2.tar.gztar -zxvf git-2.9.2.tar.gz 编译安装 123cd git-2.9.2make prefix=/usr/local/git allsudo make prefix=/usr/local/git install 配置环境变量，在/etc/profile中添加 1export PATH=$PATH:/usr/local/git/bin 更新环境变量 1source /etc/profile 如果此时查看git仍是旧版本，执行以下语句： 1234sudo yum remove -y gitsource /etc/bashrccd ~/git --version 安装Go的一些工具当我们进入VSCode打开hello.go时，VSCode会提示我们安装go-outline，点击Install却失败了，需要手动安装： 下载源码到本地 123456# 创建文件夹mkdir -p $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 安装工具包 1go install $GOPATH/src/golang.org/x/tools/go/buildutil 重启VSCode，按照提示安装即可 安装运行 hello world 1go install github.com/github-user/hello 安装go tour1go get -u github.com/Go-zh/tour/gotour 安装好之后会在工作空间的 bin 目录中创建一个 gotour 可执行文件 运行Go语言之旅 1go tool tour 绑定git远程仓库之前我们已经在github.com文件夹下创建了与自己的github账户同名的文件夹，现在需要把这个文件夹绑定git上的远程仓库，用来保存我们以后编写的Go语言代码。 在github上创建一个仓库用于同步之后就可以来绑定远程仓库了，本地执行指令如下： 1234git init git config --global user.name "xxx"git config --global user.email "xxx@xxx"git remote add origin your_repo_url 以上传hello文件夹为例： 123git add hello/git commit -m 'first commit'git push -u origin master git相关指令详见git学习笔记]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>配置环境</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-042]]></title>
    <url>%2F2018%2F09%2F23%2Fleetcode-042%2F</url>
    <content type="text"><![CDATA[题目Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 分析这道题目的意思是给出一个数组来代表柱子的高度，让我们计算可以有多少水陷在这些柱子围成的空隙中，注意最左边和最右边是没有阻挡作用的。 解法一要让水陷入，就必须有左右各一个柱子比中间的所有柱子都高，因此我的想法是用一个bottom变量来记录矮一点的左边柱子，用一个栈stack来存放两个柱子中的矮柱子高度，当遍历到高度&gt;=bottom的柱子时就形成了一个可以陷入水的空隙，再遍历数组去找到所有可能的这种空隙。算法思路如下： 数组arr长度&lt;=2时无法形成空隙，必为0 bottom = arr[0]，stack&lt;int&gt; s 1234for i : arr if (bottom &lt;= arr[i]) //计算空隙中的水量 else s.push(arr[i]) 而计算空隙中的水量也很简单，其实就是个计算面积的问题：以矮柱子bottom的高度为宽，中间柱子数bar_num为宽计算整个长方形面积，再减去中间柱子的总高度rock即可：water = bottom * bar_num - rock 要得到中间的柱子数bar_num和中间柱子的总高度rock，只需一步步弹出栈即可 循环部分的代码如下： 1234567891011121314151617for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i;&#125; else s.push(height[i]);&#125; 但这个思路还没有完全解决问题，因为我假设的bottom是左边的柱子，然后通过找高度&gt;=bottom的柱子来寻找空隙，但是如果没有高度&gt;=bottom的柱子也是可能存在空隙的，比如例子中最右边的那个空隙。解决办法是记录最高的那个柱子，然后再从右边以同样的方法遍历，直到最高的这个柱子为止，来寻找那些第一次遍历时错过的空隙(十分暴力的解法)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; stack&lt;int&gt; s; int bottom = height[0]; int top = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; &#125; else s.push(height[i]); &#125; stack&lt;int&gt; s2; bottom = height[height.size() - 1]; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s2.empty()) &#123; int tmp = s2.top(); s2.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; &#125; else s2.push(height[i]); &#125; return result; &#125; &#125;; 这种解法的时间复杂度是O(n2)，而且最坏情况(最高的柱子为最左边的柱子)下需要遍历两次，效率很低了，必须得优化下。 解法二我的优化思路是从堆栈入手，一开始我使用栈是因为想用它来管理那些中间的矮柱子，但其实好像并不需要，因为我只需要得到3条关于它们的信息： 高度&lt;=bottom 矮柱子个数 矮柱子总高度 这3条信息在遍历的过程中都可以得到，而额外弹出栈还需要再套一个循环，完全没必要，因此使用堆栈这一点是显而易见需要优化的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; int bottom = height[0]; int top = 0; int rock = 0, bar_num = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; bottom = height[height.size() - 1]; rock = bar_num = 0; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; return result; &#125; &#125;;int main() &#123; vector&lt;int&gt; test = &#123;0,1,0,2,1,0,1,3,2,1,2,1&#125;; Solution s; cout &lt;&lt; s.trap(test);&#125; 优化后的代码时间复杂度为O(n)，但是最坏情况下还是可能遍历两次，因此我还需要找出一次遍历就能解决问题的算法，这可能要同时从两边开始遍历。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-023]]></title>
    <url>%2F2018%2F09%2F16%2Fleetcode-023%2F</url>
    <content type="text"><![CDATA[题目Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 分析这道题的描述十分简单，要求也清晰，就是要我们把k个有序的链表合并成一个有序的链表，我们熟悉的应该是合并两个链表，但这里链表数目增加了，算法的设计就自然变难了。 合并两个有序链表我们先回顾经典的合并两个链表的问题，最好的方法如下： 从合并两个链表头节点开始，比较两个链表头节点值的大小，若list的头节点值更小，则把result_list的头指针指向这个节点，并把list的头节点往后移一次 循环判断剩余节点：继续比较两个链表头节点大小，若list的头节点值更小，则把result_list尾节点的next指针指向list的头节点，并把list的头节点往后移一次。推出循环的条件是两个链表中有一个头节点指针为空 使result_list的尾节点的next指针指向不为空的那个链表的头节点 代码如下： 1234567891011121314151617181920212223242526272829//list1和list2分别指向要合并的两个有序链表的头节点 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; 这种方法的时间复杂度最大为O(N)，而空间复杂度为O(1)，效率挺不错了。 合并k个有序链表有了前面的基础后再回到这个题目，很容易会想采用同样的方法：比较这k个链表的头节点的值，然后把最小的那个头节点作为合并后链表的头节点，再不断循环。但这样的话每得到一个正确位置的节点就要循环一次，开销太大了，不适用于此种情况。 鉴于最近课上一直在讲分治算法，很自然地我就想到了用分治法来解决这个问题。既然一次性合并k个链表是困难的，而一次性合并两个链表是容易的，那使用分治法来把这个大问题(合并k个)分成很多个小问题(合并2个)，再一一解决，就很容易了。 解法按照前面的思路，解决方法可以分为以下几个步骤： 使用二分法把这k个链表不断递归分成两个子部分，最终得到的子部分所含有的链表数全为1，这是最底层 最底层不需要合并，因为一个链表的合并自然就是它本身 向上递归，倒数第二层的合并全是两个有序链表的合并，这在之前已经得到解决，合并之后链表数减半，再继续递归合并，一层层合并完就得到了最终的链表 这种方法的时间复杂度是O(Nlogk)，总共分成了logk层，而每一层中合并两个有序链表总共的时间复杂度为O(N)，因此总的就为O(Nlogk) 至于空间复杂度，我们在合并两个链表的过程中并没有额外开辟新的空间，而是仅通过改变指针的指向就实现了合并，因此为O(1) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.Example:Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;private: //合并两个有序链表 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; ListNode* mergelist(vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123; int mid = (left + right) / 2; if (left &lt; right) &#123; ListNode* list1 = mergelist(lists, left, mid); ListNode* list2 = mergelist(lists, mid + 1, right); ListNode* mergedList = merge(list1, list2); return mergedList; &#125; return lists[left]; &#125;public: //思路:先采用分治法把问题分成两个子问题(不断向下递归分解)，到最后一层得到的是单独的一条链表 // 合并两条链表为一条，向上递归继续合并 // 思路很类似于归并排序 ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; return mergelist(lists, 0, lists.size() - 1); &#125;&#125;;int main() &#123; //懒得写测试代码了...直接用的leetcode来测试 //错的那两遍是因为没有考虑[] 和[[],[]]这种输入形式 //会导致访问空指针的val，因此需要额外考虑&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F09%2F13%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git学习笔记 前言git作为世界上最先进的分布式版本控制系统，为我们管理自己的代码提供了很多便利，它的指令强大且复杂多样，而我一直都只用着git add、git push等最简单的指令，十分惭愧。希望这篇笔记能帮助我之后的git学习，也帮助到有需要的同学。 配置git12345678910111213#查看版本信息git --version#查看配置信息git config --list#查看配置信息，输入后会启动默认的git编辑器，可以编辑用户名和邮箱，#git的配置文件在C:Users\用户名\目录下，是.gitconfig文件git config -e --global#分别为设置用户名和邮箱，如果不加最后面的参数，就是查看用户名和邮箱git config --global user.name "xxx"git config --global user.email "xxx@xxx" 新建仓库12345#在指定目录初始化仓库，会创建一个.git隐藏文件夹，默认在当前目录下初始化仓库git init [dir]#下载一个项目和代码历史，会在本地当前目录自动创建一个项目名的文件夹，用于存放项目git clone [url] 增加和删除文件123456789101112131415161718#添加文件到暂存区，参数是一个.或-A的话为添加所有文件git add [file1] [file2]...#添加指定目录到暂存区，包括该目录的子目录git add [dir]#添加每个变化前，都会要求确认#对于同一个文件的多处变化，可以实现分次提交git add -p#删除工作区文件，并将这次删除放入暂存区git rm [file1] [file2]...#把暂存区的文件删除，但该文件会保留在工作区git rm --cached [file]#重命名文件，并将这次命名放入暂存区git mv [file-original] [file-renamed] 提交修改123456789101112131415161718#提交暂存区到仓库区，message用于描述这次提交git commit -m [message]#提交暂存区的指定文件git commit [file1] [file2]... -m [message]#提交工作区自上次commit之后的变化，直接到仓库区git commit -a#提交时显示所有diff信息git commit -v#使用一次新的commit，替代上一次提交#如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]#重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839#列出所有本地分支git branch#列出所有远程分支git branch -r#列出所有本地分支和远程分支git branch -a#新建一个分支，但依然停留在当前分支git branch [branch-name]#新建一个分支，并切换到该分支git checkout -b [branch]#新建一个分支，指向指定commitgit branch [branch] [commit]#新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]#切换到指定分支，并更新工作区git checkout [branch-name]#建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]#合并指定分支到当前分支git merge [branch]#选择一个commit，合并进当前分支git cherry-pick [commit]#删除分支git branch -d [branch-name]#删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526#列出所有taggit tag#新建一个tag在当前commitgit tag [tag]#新建一个tag在指定commitgit tag [tag] [commit]#删除本地taggit tag -d [tag]#删除远程taggit push origin :refs/tags/[tagName]#查看tag信息git show [tag]#提交指定taggit push [remote] [tag]#提交所有taggit push [remote] --tags#新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#显示有变更的文件git status#显示当前分支的版本历史git log#显示commit历史，以及每次commit发生变更的文件git log --stat#搜索提交历史，根据关键词git log -S [keyword]#显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s#显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature#显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]#显示指定文件相关的每一次diffgit log -p [file]#显示过去5次提交git log -5 --pretty --oneline#显示所有提交过的用户，按提交次数排序git shortlog -sn#显示指定文件是什么人在什么时间修改过git blame [file]#显示暂存区和工作区的差异git diff#显示暂存区和上一个commit的差异git diff --cached [file]#显示工作区与当前分支最新commit之间的差异git diff HEAD#显示两次提交之间的差异git diff [first-branch]...[second-branch]#显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"#显示某次提交的元数据和内容变化git show [commit]#显示某次提交发生变化的文件git show --name-only [commit]#显示某次提交时，某个文件的内容git show [commit]:[filename]#显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223#下载远程仓库的所有变动git fetch [remote]#显示所有远程仓库git remote -v#显示某个远程仓库的信息git remote show [remote]#增加一个新的远程仓库，并命名git remote add [shortname] [url]#取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]#上传本地指定分支到远程仓库git push [remote] [branch]#强行推送当前分支到远程仓库，即使有冲突git push [remote] --force#推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031#恢复暂存区的指定文件到工作区git checkout [file]#恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]#恢复暂存区的所有文件到工作区git checkout .#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]#重置暂存区与工作区，与上一次commit保持一致git reset --hard#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]#重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]#新建一个commit，用来撤销指定commit#后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]#暂时将未提交的变化移除，稍后再移入git stashgit stash pop 理解工作区和暂存区先上图： 工作区就是电脑上的文件夹 在工作区中有一个隐藏的.git文件夹，它不属于工作区，是git的版本库，这里包含所有git操作所需要的东西 版本库中最重要的东西就是暂存区(index/stage)，还有自动创建的第一个分支master和指向master的指针HEAD 下面通过简单的指令来理解暂存区的概念： 首先git init初始化一个空的版本库，git会自动帮我们创建一个分支master，此时的git commit就是往master分支上修改。假设工作区已经有一个readme.txt文件，那此时工作区有一个文件，暂存区和版本库都没有文件： 我们先对readme.txt进行修改，内容随意；再在工作区新增一个文件LICENSE，然后使用git status来查看状态： 可以看到readme.txt被修改了，而LICENSE文件还没有被git add过，因此是Untracked的 使用git add来把这两个文件从工作区复制到暂存区，然后用git status查看状态： 此时暂存区的状态如下图： 然后使用git commit来把暂存区中的文件提交到分支： 此时的版本库如下，暂存区已经没有任何内容了： gitignore有时候我们需要把一些文件放到git的工作区当中，但是又不想提交它们，.gitignore配置文件就是用来忽略文件的。 不用担心不会写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 需要注意的是，.gitignore文件也是需要放入到版本库中的，并且也可以对它进行版本管理。前面我们知道git status会显示一些Untracked的文件，看起来很不舒服，但如果我们利用.gitignore来忽略该文件，git status就会显示working directory clean了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-031]]></title>
    <url>%2F2018%2F09%2F09%2Fleetcode-031%2F</url>
    <content type="text"><![CDATA[题目next permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1234&gt; 1,2,3 → 1,3,2&gt; 3,2,1 → 1,2,3&gt; 1,1,5 → 1,5,1&gt; 分析这道题目的意思是给出一个序列，要求给出它的下一个置换，即按照字典序比它大的最小的那个序列。如果找不到这样的置换，那么就输出最小的那个序列(即按升序排序)。in-place的意思是让我们在交换元素时不要花费过多空间，花费的额外空间只能是常量。 解法首先要判断是否有下一个置换，这可能不太直观，但判断没有下一个置换是很容易的：当序列已经是降序时就已经是最大的序列了，当然就不存在下一个置换，此时只要将它反过来就可以得到所求序列。因此，只要序列不是降序的，那么置换就存在。 要判断序列是否是降序，可以采取从后往前遍历的方式，如果相邻的两个元素，后面那个(right)一直比前面那个(left)小，那么就是降序的。当我们找到这样两个元素:right &gt; left时，就找到求下一个置换的突破口了，因为这意味着在left后面的那一段子序列都是降序的，已经不存在下一个置换了，即是时候把left这个位置的元素的值变大了。 找到这样的left之后我的第一个想法是把它与后面那段子序列中比它大的最小的那个元素交换位置，再把子序列排序，这样就得到了比原始序列大的最小的序列，即下一个置换。这样的确是可以得到答案的，但是这样我们就使用了排序了，复杂度就成了O(n2)，算法自然就没那么好了。 实际上，我们知道那段子序列是降序的，那么只要把它反过来就是一个升序的序列了，这样的时间复杂度是O(n)，排好序后再去找比left大的最小的那个元素，交换它们的位置就好了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 1) return; bool flag = false; //是否存在下一个置换 int index; for (index = len - 1; index &gt; 0; --index) &#123;//找left和right if (nums[index] &gt; nums[index - 1]) &#123; flag = true; break; &#125; &#125; if (flag == false) reverse(nums.begin(), nums.end());//没有下一个置换 reverse(nums.begin() + index, nums.end()); int small_index = -1; for (int i = index; i &lt; len; ++i) &#123;//找比left大的最小元素 if (nums[i] &gt; nums[index - 1]) &#123; if (small_index == -1) small_index = i; else if (nums[i] &lt; nums[small_index]) small_index = i; &#125; &#125; int temp = nums[small_index]; nums[small_index] = nums[index - 1]; nums[index - 1] = temp; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox + CentOS让PC提供云服务]]></title>
    <url>%2F2018%2F09%2F09%2Fcentos-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BA%91%2F</url>
    <content type="text"><![CDATA[前期准备安装Git客户端直接百度git for windows即可找到官网的下载链接，安装好对应系统版本后应在任何地方右键鼠标都会出现git bash here： 安装VirtualBox直接到官网下载最新版本的安装包并安装，在Downloads界面选择windows版本的： 配置VirtualBox 点击管理-&gt;全局设定-&gt;常规，设置默认虚拟电脑存储位置，最好把默认的C盘路径改掉，方便自己查找，同时也不消耗系统盘空间。 创建虚拟机内部虚拟网络，使得 Vbox 内部虚拟机可以通过它，实现虚拟机之间、虚拟机与主机的通讯： 管理-&gt;主机网络管理器-&gt;创建，创建一块虚拟网卡，并把IPv4地址设为：192.168.100.1/24，这是虚拟内部网络host的默认地址(这一步好像有同学创建不了，据说回退到4.3版本可以，但他直接换Vmware了…) 用cmd输入ipconfig可以查看到刚创建的网卡VirtualBox Host-Only Network #2: 第一个是本机的网卡，可以通过它看到本机的ip地址，这在之后会有用到。 下载CentOS镜像直接到官网下载Minimal ISO镜像即可，点击Minimal ISO后进入下载界面选第一个就好了 安装虚拟机安装第一个虚拟机进入VirtualBox，点击新建，在名称那里输入centos，就会自动选择类型和版本了： 注意：如果没有64位选择的话，有几种可能： 电脑不是64位的 电脑未开启硬件可虚拟化，具体解决方法是进入BIOS把对应可虚拟化的选项设为enable,一般是Intel Virtual Technology 电脑开启了hyper-v，解决方法是进入控制面板-&gt;卸载程序-&gt;启用或关闭Windows功能，取消选择hyper-v即可，重启就可以了 选好后继续安装，点击下一步，分配内存依据自己电脑配置，2G差不多了，然后创建虚拟硬盘，选择现在创建虚拟硬盘，文件类型选择VDI，动态分配和固定大小按自己个人喜好选就好，文件位置一般会自动选择在之前设置的默认虚拟电脑位置文件夹下，大小选择分配30G，方便以后扩展，然后就创建好了。 接下来选择刚创建的虚拟机点击设置，在系统那里把启动顺序设为硬盘第一(不然装好系统后再次启动可能又会进入安装系统界面)；存储那里点击没有盘片： 然后选择之前下载的Minimal ISO；在网络那里第一块网卡默认NAT，第二块网卡选择Host-Only,接口就是前面创建的虚拟网卡： 设置好之后就可以点击启动来安装系统了，选择Install Centos 7，选择语言后点击继续， 在这个界面要注意两个地方，一个是黄色感叹号那个选项，点击进入后选择安装位置，就选之前分配的虚拟硬盘，然后还要注意点击NETWORK &amp; HOST NAME，进去把网络连接打开， 然后就可以安装了，在这个过程中还可以设置root密码和添加用户。 安装好之后进入系统，首先进行升级OS内核： 获取wget：sudo yum install wget 配置源163源或者阿里云源： 具体操作为(以163源为例): 备份/etc/yum.repos.d/CentOS-Base.repo(即改名): 1sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 进入yum源配置文件：cd /etc/yum.repos.d 下载网易163源： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 下载好后把163源设置为默认源： 1sudo mv CentOS7-Base-163.repo CentOS-Base.repo 然后生成缓存： 12yum clean allyum makecache 升级OS内核：sudo yum update 升级内核之后进行下一步，检查网卡配置： 输入nmtui，配置第二块网卡地址： 选择第一项，然后选择第二个网卡的edit: 在IPv4那里点击Show，在下面的Addresses点击Add，配置第二块网卡地址，格式如192.168.100.50/24, 然后退出nmtui界面。 ping主机，如ping 192.168.100.1 第一个虚拟机的操作完成，关闭虚拟机。 安装第二个虚拟机利用虚拟机复制功能，直接获取新虚拟机：右键之前创建的虚拟机，选择复制，为新虚拟机取名并一定要选择重新初始化所有网卡的 MAC 地址： 然后选链接复制，完成。 启动新的虚拟机，配置主机名和第二块网卡： 配置主机名要使用sudo nmtui，修改网卡地址操作与之前相同，但地址变为了192.168.100.100/24。改好后回退到nmtui的第一个界面，选择第二项来激活第二个网卡，两个网卡名前面都有*号就表示都已激活。 再回到nmtui的第一个界面选第三项，更改主机名，改完后退出，重启。 重启后需重新激活第二个网卡，在windows上进入git bash，ping刚才修改的地址，即ping 192.168.100.100： 通过ssh来访问该虚拟机。到官网下载putty,安装后启动，输入虚拟机第二块网卡的地址，点击open即可连接到虚拟机(windows需启动git bash)：经老师提示发现windows安装了git bash(Unix命令行模拟环境)就有ssh客户端了，可以通过git bash来进行ssh连接，例如我的虚拟机地址是192.168.100.4,则ssh连接的命令为 1ssh [用户名]@[虚拟机地址] 相应操作为： 此时已经差不多完成了，能通过ssh访问到虚拟机就已经搭好私有云环境了，但为了centos更方便使用，继续安装centos桌面： 首先重新配置虚拟机的CPU、内存、显存，因为使用centos桌面对配置要求更高。先关闭虚拟机，选择对应的虚拟机后点击设置来进行配置，CPU 1~2个，内存2G或4G，显存越大越好，同时勾选启动3D加速 启动虚拟机，安装桌面sudo yum groupinstall &quot;GNOME Desktop&quot;,这个很大，耗费时间比较长，需要耐心等待，如果下载不成功，可能需要更换yum源 安装好后设置启动目标为桌面，然后重启: 1ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 此时我们已经可以通过图形化界面来使用centos，但因为虚拟机对鼠标的捕获很不友好，导致使用很不方便，而且也不能全屏，那么就需要安装VirtualBox的扩展功能了： 先安装kernel-devel和gcc：sudo yum install -y kernel-devel gcc 点击VirtuaBox的设备-&gt;安装增强功能，此时可能会报错： 这个错误挺常见的，也容易解决： 弹出后再选择安装增强功能就好了： 点击Run即可开始安装。 装好之后重启时突然报错：Failed to load selinux policy.然后就一直卡在进度条满的状态，无法进入系统，重启很多次也没用，上网查之后发现是因为/etc/selinux/config配置文件不对，虽然我没有修改这个文件，但还是试了试网上方法： 首先在启动时选择启动项的界面按e进入grub编辑界面： 进入grub编辑界面后找到linux16那一行，在最后面的LANG=zh_CN.UTF-8之后空格，加上selinux=0，如上图所示，然后Ctrl + X启动即可进入系统 进入系统后当然要解决这个问题了，sudo vi /etc/selinux/config,可以看到SELINUX=enforcing,我们要做的是改成disabled,且记SELINUXTYPE=targeted原始配置不用改！ 解决上个那个错误后重启就发现增强功能已经装好了，鼠标可以自由移动，也可以全屏了。 接下来安装Google Chrome(可选)： 直接去官网下载可能会被墙，可以移步国内新浪科技网下载，选择正式版RPM，直接下载 进入下载的安装包所在路径，利用yum来安装sudo yum localinstall google-chrome-stable_current_x86_64.rpm,yum会自动分析依赖，并完成安装 在这里插入一个可能的问题：有了图形化界面后我们就可以很方便地通过设置来把第二块网卡设置自动激活了，避免每次开机都要手动激活的痛苦。在这个过程中我发现了一个问题，貌似系统把我之前设置的第二块网卡的IPv4地址修改了： 现在的地址是192.168.100.4，而之前我是把它设置成了192.168.100.100，而且貌似修改后重启又会变成这个，干脆就使用这个地址吧，在使用ssh访问的时候要注意IP地址的变化。 使用远程桌面访问虚拟机安装扩展包首先关闭所有虚拟机，然后去VirtualBox官网下载扩展包，在下载界面选择VirtualBox 5.2.18 Oracle VM VirtualBox Extension Pack(扩展包版本要与VBox版本相同)： 下载好后点击管理-&gt;全局设定-&gt;扩展，点击添加新包，找到正确的扩展包并添加 装好扩展包后重启Windows(注意不是重启虚拟机) 设置虚拟机端口点击对应的虚拟机，点击设置后选择显示，在远程桌面那里启用服务器，然后设置端口号，这里需要注意每台虚拟机的端口号必须不同，因此最好手动修改端口号而不是使用默认。认证方式选择空，我使用外部的认证方式无法连接： 使用远程桌面直接在win10小娜姐姐那里输入远程，就可以启动windows自带的远程桌面连接，在计算机一栏那里输入的地址为本机IP地址:端口号，注意是本机地址，不是虚拟机的地址！！ 再点击连接，就成功啦： 注： 部分同学发现在不开启第二块网卡时虚拟机可以ping到192.168.100.1,但开启了第二块网卡之后就不行了，经大佬提示后发现是windows防火墙的问题…关闭之后就好了，不过没有必要，因为已经可以实现远程访问了。]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-004]]></title>
    <url>%2F2018%2F09%2F07%2Fleetcode-004%2F</url>
    <content type="text"><![CDATA[题目Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析这个题目的意思是给出两个已排好序的数组，要求我们给出包含两个数组中所有数的中位数。我首先想到的方法是利用两个循环变量i， j来同时遍历这两个数组 nums1、nums2 ，当 nums1[i] &lt; nums2[j]时i++ ，否则 j++ ，并且选出小的那个数，直到总共遍历了(m + n) / 2 个元素，有点类似于合并两个有序链表的算法。此时就可以找到中位数了： 如果总数是奇数，那么中位数就是最后一个选出来的数 如果总数是偶数，那么中位数就是最后两个选出来的数的平均数 代码如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m == 0) return n % 2 == 0 ? (nums2[n/2 - 1] + nums2[n/2]) / 2.0 : nums2[n/2]; else if (n == 0) return m % 2 == 0 ? (nums1[m/2 - 1] + nums1[m/2]) / 2.0 : nums1[m/2]; int mid = (m + n) / 2; vector&lt;int&gt; sortedArr; for (int i = 0, j = 0; i + j &lt;= mid; ) &#123; if (i == m) sortedArr.push_back(nums2[j++]); else if (j == n) sortedArr.push_back(nums1[i++]); else if (nums1[i] &lt;= nums2[j]) sortedArr.push_back(nums1[i++]); else sortedArr.push_back(nums2[j++]); &#125; return (m + n) % 2 == 0 ? (sortedArr[mid - 1] + sortedArr[mid]) / 2.0 : sortedArr[mid]; &#125;&#125;; 这种方法的时间复杂度是 O((m + n) / 2), 并不满足题目要求的O(log(m + n)) ,因此还是得找效率更高的方法。 解法实际上看到有 log 的复杂度，我们就应该想到要使用分治法，但这题要怎么使用二分法来把两个有序数组合并起来并找到中位数呢？其实，我们并不需要非得这样做，从中位数的定义入手，我们可以知道，如果数组中的一个数在把数组分成长度相等的两部分，且一部分的数值总大于等于另一部分，那这个数就是中位数，即： 把数组nums1 分成两个部分： 1nums1[0],nums1[1]...nums1[i - 1] | nums1[i], nums1[i + 1]...nums[m - 1] 左边部分数目为i，右边部分数目为m - i且 max(left) &lt;= min(right)当i = m - i 时（nums1[i - 1] + nums1[i]) / 2就是中位数 同理，我们无需把两个数组合并起来排序再找中位数，只需要把它们分成两个长度相等的部分，并使max(left) &lt;= min(right)就可以找到中位数了，即： 12nums1[0]...nums1[i - 1] | nums1[i]...nums1[m - 1]nums2[0]...nums2[j - 1] | nums2[j]...nums2[n - 1] 长度相等即: i + j = m - i + n - j ,当总长度为奇数时左边会比右边少一个 max(left) &lt;= min(right) 即: nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]。 那么现在我们的问题就变成了找到这样的 i和j来满足上面两个条件。 i 的范围是 [0, m] ，由第一个条件可以知道 j = (m + n) / 2 - i ,当 m &lt;= n 时 j &gt;= 0 ，否则为负数 现在我们就可以用二分法来解决这个问题了，伪代码如下： 123456781.imin = 0, imax = m2.j = (m + n) / 2 - i3. if nums1[i - 1] &gt; nums2[j] imax = i - 1 //i较大，因此需要减小遍历i的范围 else if nums2[j - 1] &gt; nums1[i] imin = i + 1 //i较小，因此需要增大遍历i的范围 else //找到了合适的i if (m + n) % 2 == 0 return (max(left) + min(right)) / 2.0 else return min(right) 当然我们需要考虑临界问题：i = 0, i = m, j = 0, j = n时怎么办？访问nums1[i - 1],nums2[j],nums2[j - 1],nums1[i]是可能越界的。 实际上，由j = (m + n) / 2 - i ，0 &lt; i &lt; m， n &gt;= m可知0 &lt; j &lt; n，因此我们只需要判断i的临界范围就可以了。 对于nums1[i - 1] &gt; nums2[j],需加上i &gt; imin的判断，防止读取到nums1[-1]和nums2[n] 对于nums2[j - 1] &gt; nums1[i],需加上i &lt; imax的判断，防止读取到nums2[-1]和nums1[m] 最终代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m &gt; n) &#123; //确保n&gt;=m nums1.swap(nums2); int temp = m; m = n; n = temp; &#125; int imin = 0, imax = m, mid = (m + n) / 2; while (imin &lt;= imax) &#123; int i = (imin + imax) / 2; int j = mid - i; if (i &gt; imin &amp;&amp; nums1[i - 1] &gt; nums2[j]) imax = i - 1; else if (i &lt; imax &amp;&amp; nums2[j - 1] &gt; nums1[i]) imin = i + 1; else &#123;//找到了使max(left) &lt; min(right)的i int minRight; if (i == m) minRight = nums2[j]; else if (j == n) minRight = nums1[i]; else minRight = min(nums1[i], nums2[j]); if ((m + n) % 2 != 0) return minRight; int maxLeft; if (i == 0) maxLeft = nums2[j - 1]; else if (j == 0) maxLeft = nums1[i - 1]; else maxLeft = max(nums1[i - 1], nums2[j - 1]); return (maxLeft + minRight) / 2.0; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
</search>
