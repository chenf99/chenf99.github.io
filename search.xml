<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统分析与设计作业6]]></title>
    <url>%2F2019%2F06%2F13%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A6%2F</url>
    <content type="text"><![CDATA[领域建模-对象状态使用 UMLet 建模1.使用类图，分别对 Asg_RH 文档中 Make Reservation 用例以及 Payment 用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键 注意事项： 对象必须是名词、特别是技术名词、报表、描述类的处理； 关联必须有多重性、部分有名称与导航方向 属性要注意计算字段 数据建模，为了简化描述仅需要给出表清单，例如： Hotel（ID/Key，Name，LoctionID/Fkey，Address…..） Make Reservation用例领域建模 数据表及主要字段 Location（ID/Key，name） Hotel（ID/Key，name，address，favourites，lowest-price，cut-off，star-rating，info） Customer（ID/Key） Reservation（ID/Key，check-in-date，num-of-night，check-out-date，total，customer-full-name，customer-smoking，contact-email） ShoppingBasket（ID/Key） Payment（ID/Key） RoomType（ID/Key，name） RoomDesc（ID/Key，type，list-price，info） Room（ID/Key，type，date，price，isAvailable，available-num，reserved-num） RootItems（ID/Key，type，adults，children，agefrom，ageto） Payment用例领域建模 数据表及主要字段 Customer（ID/Key，name，address） CreditCard（ID/Key，type，number，securityCode，expireDate） Payment（ID/Key，total） PaymentItem（ID/Key，price，room，numberOfNights） 2.使用 UML State Model，对每个订单对象生命周期建模 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业5]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A5%2F</url>
    <content type="text"><![CDATA[用例建模 - 业务建模方法使用UMLet建模1.根据订旅馆建模文档，Asg-RH.pdf：1.1绘制用例图模型（到子用例） 1.2给出make reservation 用例的活动图 2.根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景2.1分别用多泳道图建模三个场景的业务过程 x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。 随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。 x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。 2.2根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例 用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业4]]></title>
    <url>%2F2019%2F05%2F13%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A4%2F</url>
    <content type="text"><![CDATA[用例建模 - 绘制用例图1.简答题1.用例的概念用例（use case），或译使用案例、用况，是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。每个用例提供了一个或多个场景，该场景说明了系统是如何和最终用户或其它系统互动，也就是谁可以用系统做什么，从而获得一个明确的业务目标。编写用例时要避免使用技术术语，而应该用最终用户或者领域专家的语言。用例一般是由软件开发者和最终用户共同创作的。 2.用例和场景的关系？什么是主场景或 happy path？场景是actors和系统之间一系列特定的actions和会话，又被称为用例实例（use case instance）。一个用例代表了一些场景的集合。 主场景对应主要的系统会话（交互），一般是“成功的”场景，是最常用、直接地实现用户目标的场景。 happy path是一个默认场景，没有异常或错误条件。比如验证信用卡号的happy path是，验证规则中没有一条会引发错误，从而使执行成功地持续到最后。 3.用例有哪些形式？ Brief 简短的一段总结，通常是针对主要的成功场景。是为了在早期的需求分析过程中，快速了解主题和范围，可能只需要几分钟就可以创建。 Causal 非正式的段落格式。涵盖多种场景的多个段落。 Fully 所有的步骤和变化都写得很详细，并且有补充部分，如前置条件和成功保证。在以简短的格式识别和编写了许多用例之后，在第一个需求研讨会期间有少量的具有结构重要性和高价值的用例被详细地编写。 4.对于复杂业务，为什么编制完整用例非常难？因为复杂业务所涉及的场景非常多，较为复杂，场景之间的关联使得用例设计变得十分困难。要编写完整用例，需要非常熟悉这些场景，还需要建模知识，注意与用户交互的各种细节，并且还要应对实际中需求发生变化的情况，所以非常难。 5.什么是用例图？用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图。用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。 6.用例图的基本符号与元素？ 参与者（Actor）：表示的是一个系统用户，也就是与应用程序进行交互的用户、组织或者外部系统。 用例（Use Case）：表示的是对系统提供的功能、服务的一种描述。 用例之间的关系： 包含(Include)：表示用例可以简单地包含其他用例所具有的行为，并把它所包含的用例行为作为自身行为的一部分。在UML中常用带箭头的虚线表示，箭头指向被包含的用例。 泛化(Generalization)：泛化指的是一个父用例可以被特化形成多个子用例，而父用例和子用例之间的关系就是泛化关系。在UML中用空心三角箭头的实线表示，箭头指向父用例。 关联(Association)：表示的是参与者与用例之间的关系。在UML中常用一条直线，或者是一条带箭头的线条来表示，箭头指向信息接收方。 扩展/延伸(Extend)：表示在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例，原有的用例叫做基础用例，相当于为基础用例提供一个附加功能。在UML中用带箭头的虚线表示，箭头指向基础用例。 7.用例图的画法与步骤 确定研讨的系统 使用用例图 System框 表示一个待研究的系统 正确命名系统或子系统 识别 Actors 识别使用系统的主要参与者（primary actors）/角色(roles) 使用用例图 actor符号 表示，通常放在系统的左边 企业应用可以通过企业组织架构，业务角色与职责识别 互联网应用则必须通过市场分析，确定受众范围 千万不要用“用户”代表系统使用者，以避免过于通用导致缺乏用户体验。 识别系统依赖的外部系统 使用用例图 Neighboursystem框 表示用例依赖的外部系统、服务、设备，并使用构造型（Stereotype）识别 要将一些专业功能赋予专业系统 识别用例（服务） 识别用户级别用例（user goal level） 以主要参与者目标驱动 收集主要参与者的业务事件 必须满足以下准则 boss test EBP test Size Test manage 用例。特指管理一些事物的 CRUD 操作，例如管理文件、管理用户等 识别子功能级别的用例（sub function level） 子用例特征 业务复用。 复杂业务分解。 强调技术或业务创新。 正确使用用例与子用例之间的关系 &lt;&gt; 表示子用例是父用例的一部分，通常强调离开这个特性，父用例无法达成目标或失去意义！ &lt;&gt; 表示子用例是父用例的可选场景或技术特征。 &lt;&gt; 箭头指向子用例；&lt;&gt; 箭头指向父用例。箭头表示的依赖关系！ 建立 Actor 和 Use Cases 之间的关联 请使用 无方向连线，表示两间之间是双向交互的协议 8.用例图给利益相关人与开发者的价值有哪些？ 对利益相关人： 可以直观看清系统的结果以及用户的功能体验，提供了系统使用和行为的摘要视图，保证系统能够按照用户的需求进行设计，并且便于与利益相关人进行沟通，及时对系统功能进一步完善。 能够根据业务场景的复杂程度和形式化程序进行增减调节，能够相应利益相关人提出的需求。通过用例图进行系统功能的增减以及修改更加便利。 使得系统能够注重其参与者的用户体验。 对开发者： 明确系统的业务范围、服务对象（角色）、外部系统与设备 帮助识别技术风险，提前实施关键技术原型公关与学习 易于评估项目工作量，合理规划迭代周期，规划人力需要 2.建模练习题（用例模型）2.1选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如订旅馆（携程、去哪儿等）、订电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 携程酒店： 猫眼电影： 2.2回答下列问题： 为什么相似系统的用例图是相似的？ 因为相似系统面向的Actor是相似的，从Actor视角定义的用例也是相似的，连同用例之间的关系都是相似的。这本质是因为相似系统的功能需求是相似的。 如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术 不同时代用户的需求不同，Asg_RH用例图主要满足的是用户基本需求，如今的产品则综合考虑了更多功能，更加人性化。不同地区的旅馆在服务、价格、交通方面都会有较大的差别，可以在用例图中突出这些方面的重要性。 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 使用不同的颜色来标记创新思路可以快速定位其在用例图中的位置，利用创新思路在用例图中的位置可以看出它在系统中的作用。如果把用例图看成一棵树，则位于越靠近根的创新思路作用越大。 请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 选择携程订酒店的用例图。 ID Name Imp Est How to demo 1 find hotel 10 5 根据酒店名、地点查找酒店，输入目的地、日期等相关信息后获取匹配的酒店列表 2 make reservation 10 5 选择酒店、房间并确认 3 login 6 2 建立用户账户信息数据库，与第三方软件绑定实现多种方式登陆 4 manage basket 7 3 用户查看订单，并可以进行修改 5 pay 8 3 在完成登陆后可以支付订单费用，需要用到不同支付方式的api 根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算 根据用户点方法，对用例分配权重的标准是： 简单用例：1 到 3 个事务，权重=5 一般用例：4 到 7 个事务，权重=10 复杂用例：多于 7 个事务，权重=15 用例 业务 计算 原因 UC比重 find hotel 3 3 简单 make reservation 4 4 一般 login 2 1 简单 manage basket 4 3 一般 pay 3 1 简单]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业3]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A3%2F</url>
    <content type="text"><![CDATA[软件项目过程模型与规划1.简答题1. 简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点从项目特点、风险特征、人力资源利用角度思考 瀑布模型 简述 瀑布模型是一种项目开发架构，开发过程是顺序展开的，从一个阶段流动到下一个阶段。瀑布模型中的每一个开发活动具有下列特征： 本阶段活动的工作对象来自于上一项活动的输出，这些输出一般是代表本阶段活动结束的里程碑式的文档 根据本阶段的活动规程执行相应的任务 本阶段活动产出相关的软件工件，作为下一阶段活动的输入 对本阶段活动执行情况进行评审 优点 降低软件开发的复杂度，提高软件开发过程的透明性，提高软件开发过程的可管理性 推迟软件实现，强调在软件实现前必须进行分析和设计工作 以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，使产品达到预期的质量要求 缺点 强调过程活动的线性顺序 缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题 风险控制能力较弱 瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量 管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论 增量模型 简述 增量模型是把待开发的系统模块化，每个模块作为一个增量组件，按不同的优先级来逐步实现。增量模型首先要对系统最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中，再按优先级逐步实现后续需求。 优点 增强用户对系统的信心 降低系统失败风险 提高系统可靠性 提高系统的稳定性和可维护性 缺点 建立初始模型时，作为增量基础的基本业务服务的确定有一定难度 增量粒度难以选择 螺旋模型 简述 螺旋模型是一种演化软件开发过程模型，兼顾了瀑布模型和快速原型方法的关键特征，其最大的特点是引入了明确的风险管理机制，尤其适用于大规模复杂的系统。螺旋模型是风险驱动的迭代过程，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中，它的每一次迭代都包含了以下六个步骤： 决定目标、替代方案和约束条件 识别和解决项目的风险 评估技术方案和替代方案 开发本次迭代的交付物，并验证迭代产出的正确性 计划下一次迭代 提交下一次迭代的步骤和方案 优点 提供对风险的分析 设计灵活，可以在项目各个阶段变更 客户始终掌握项目的最新信息，从而跟管理层有效地交互 以小的分段来构建大型系统，技术和流程变得简单 缺点 螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发 风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目 失误的风险分析可能带来更大的风险 2.简述统一过程三大特点，与面向对象的方法有什么关系？三大特点： 用例驱动 用例是一系列行为的表示，这些行为给人们带来了有价值的行为，帮助他们来实现目标。 用例驱动意味着开发团队使用通过代码和测试收集的案例。 以架构为中心 软件架构提供所有其他开发发展的中心点。 迭代和增量的 迭代和增量的方案允许以不完整、不完善的知识开始开发。 统一过程将软件开发过程要素和软件工程要素整合在统一的软件工程框架中，是一个面向对象的程序开发方法论。 3.简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？划分准则： 软件生命周期在时间维度上被分解为4个顺序的阶段，每个阶段结束于一个主要的里程碑，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。 里程碑： 初始阶段： 生命周期目标里程碑，包括一些重要的文档，通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等。 精化阶段： 生命周期体系结构里程碑，包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等 。 构建阶段： 初始运行能力里程碑，包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。 产品化阶段/移交阶段： 产品发布里程碑，确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段相重合。 4.软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？因为软件企业使用基于统一过程的软件项目规划，这也是一个迭代过程。企业把软件生命周期划分为各个阶段，每个阶段有不同的目标，由多次迭代组成。每个迭代都是瀑布的工作流程；每个迭代产品在增量，利于及时交付使用并反馈；固定的迭代周期利于量化团队/个人效率。 好处： 使得软件生产按固定节奏运行 规范软件开发 提升企业生产力]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业2]]></title>
    <url>%2F2019%2F04%2F02%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A2%2F</url>
    <content type="text"><![CDATA[软件项目与知识团队管理基础1.简答题1.用简短的语言给出对分析、设计的理解分析：强调对问题和需求的调研，而不是获得解决方案。比如要实现一个App的话，需要分析它的用处是什么？它有哪些功能？分析是做正确的事情。 设计：强调满足需求的概念上的解决方案，而不是如何实现。比如使用UML类图来设计系统的类、接口等。设计是把事情做对。 2.用一句话描述面向对象的分析与设计的优势分析与设计之间的界限变得更加模糊，模块化，从而使维护简单，开发效率高、质量好，而且易于扩展。 3.简述 UML（统一建模语言）的作用。考试考哪些图？UML是把分析和设计的结果可视化的标准绘图语言。它可用于进行面向对象设计，简单、准确而直接地描述出系统的功能需求，并可视化类与类之间的关系。 考试考的图有： 用例视图 用例图 设计视图 类图 对象图 进程视图 顺序图 合作图 状态图 活动图 实现视图 构件图 拓扑视图 部署图 4.从软件本质的角度，解释软件范围（需求）控制的可行性由于软件本身的复杂性、不可见性、不一致性、可变性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。我们只要围绕客户目标，发现并满足客户感兴趣的内容是最关键的。根据2/8法则，细化20%的有效需求，我们就能满足80%的客户需要，因此软件范围控制是可行的。 2.项目管理实践1.看板使用练习 2.UML绘图工具练习参考书：UML和模式应用（原书第三版） 页码：7 图1-5]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业1]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A1%2F</url>
    <content type="text"><![CDATA[软件的本质与软件工程科学1.简答题 软件工程的定义： 软件工程是应用系统的、规范的、量化的方法来开发、操作和维护软件，是将工程应用到软件开发的系统方法。 解释导致software crisis本质原因、表现，述说客服软件危机的方法： 本质原因：计算机能力的快速增长以及无法解决的问题的复杂性，由于软件复杂性的增加，很多已有方法不足以解决的软件问题逐渐增加。 计算能力的提高超过了程序员有效利用这些计算能力的能力 表现： 项目运行超预算 项目运行超时 软件效率低下 软件低质量 软件经常无法满足需求 项目无法管理、代码难以维护 软件从未交付过 解决方法： 使用系统化、与时俱进的软件工程方法，如过程式编程、面向对象编程方法。 软件生命周期： 在时间维度对软件项目任务进行划分，又称为软件开发过程，即为了提高设计、产品管理、项目管理而把软件开发工作分成不同的阶段。常见的有瀑布模型、螺旋模型、敏捷的模型等。 SWEBoK的15个知识域： 描述软件工程实践的11个知识域： 软件需求： 关于软件需求的启发、协商、分析、规范和验证。表达了用于解决实际问题的软件产品的需要和约束。 软件设计： 定义系统或组件的结构、组成部分、接口和其他特点的过程以及这个过程的结果。软件设计过程是一个软件工程生命周期活动，它分析软件需求来产生对软件内部结构的描述，它的表现会作为它的构建的基础。 软件构建： 通过详细的设计、编码、单元测试、继承测试、调试和验证的组合来详细地创建工作软件。这个知识域涉及软件构建基础、软件管理基础、构建技术、实际考虑以及软件构建工具。 软件测试： 评估和通过识别缺陷来提升软件质量的活动。这个知识域包含软件测试基础、测试技术、人机交互接口测试和评估、测试相关的措施以及实际考虑。 软件维护： 包含增强已有的能力，调整软件来在新的和修改过的操作环境中运行以及纠正缺陷。这个知识域包含软件维护的基础、软件维护的关键问题、维护过程、软件维护的技术、灾难恢复技术和软件维护工具。 软件配置管理： 系统的配置是硬件、固件、软件的功能和物理特性的组合。软件配置管理是为了系统地控制配置的变化，在不同时间点识别系统配置的规程，也是在整个软件生命周期中维护配置的完整性和可追溯性的规程。 软件工程管理： 包含计划、协调、测量、报告和控制项目或程序，以确保软件的开发和维护是系统的、规范的和量化的 软件工程进程： 涉及软件生命周期过程的定义、实现、评估、测量、管理和改进。 软件工程模型和方法： 涉及包含多个生命周期阶段的方法，特定生命周期阶段的方法由其他知识域涵盖。 软件质量： 普遍存在的的软件生命周期问题。 软件工程专业实践： 软件工程师必须拥有知识、技能和态度来以专业、负责和道德的方式来实践软件工程。 描述软件工程教育需求的4个知识域： 软件工程经济学： 涉及在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。 计算基础： 涵盖为软件工程实践提供必要的计算背景的基本主题。 数学基础： 涵盖为软件工程实践提供必要的数学背景的基本主题。 工程基础： 涵盖为软件工程实践提供必要的工程背景的基本主题。 简单解释CMMI的五个级别 Level 1-Initial(初始级)： ​ 软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力，管理是反应式的 Level 2-Managed(可管理级)： ​ 建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 Level 3-Defined(已定义级)： ​ 已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 Level 4-Quantitatively Managed(量化管理级)： ​ 分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 Level 5-Optimizing(优化级)： ​ 过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。 用自己语言简述SWEBok或CMMI(约200字) CMMI即能力成熟度模型集成，是一个过程级别的改进模型，集成了各种现存实施的与将被发展出来的能力成熟度模型，本质是软件管理工程的一部分。 改善软件生产过程是当前软件管理工程的核心问题，它关乎高效率、高质量和低成本地开发软件。CMMI目的旨在帮助企业管理和改进软件工程过程，增强开发和改进能力，开发出高质量的软件。它通过使用知识(能力)的不同，用不同的级别表示开发企业的成熟性，给出了企业能力评估的事实标准。 CMMI的主要关注点在成本效益、明确重点、过程集中和灵活性四个方面。 参考链接Software engineering Software_crisis Software_development_process An_Overview_of_the_SWEBOK_Guide]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>系统分析与设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFLP]]></title>
    <url>%2F2018%2F12%2F22%2FCFLP%2F</url>
    <content type="text"><![CDATA[算法project报告 Capacitated Facility Location Problem问题描述Suppose there are n facilities and m customers. We wish to choose: which of the n facilities to open the assignment of customers to facilities The objective is to minimize the sum of the opening cost and the assignment cost. The total demand assigned to a facility must not exceed its capacity. You need to obtain the results for 71 benchmark instances. 初始数据一共给出了71个案例，需要找出每一种案例的解。 每个案例的数据格式如下： J I //J个facility，I个customer. //接下来J行给出了每个facility的capacity和opencost s1 f1s2 f2…sJ fJ //接下来个数据给出了每个customer的demand d1 d2 d3 … dI //接下来J * I个数据 //每I个数据对应I个customer分配给1个customer的assigncost c11 c12 c13 … c1I c21 c22 c23 … c2I … cJ1 cJ2 cJ3 … cJI J is the number of potential facility locations;I is the number of customers;sj (j=1,…,J) is the capacity of facility j;fj (j=1,…,J) is the fixed cost of opening facility j;di (i=1,…,I) is the demand of customer i;cji (j=1,…,J),(i=1,…,I) is the cost of allocating all the demand of customer i to facility j. customer的demand不可切分，即只能分配给一个falicity 问题分析要求已经很明确，需要我们把I个顾客分配到J个设施去，每个设施初始时关闭，打开它需要opencost，把顾客分配到设施需要assigncost，设施的容量capacity不能小于分配给它的顾客的需求demand之和。我们需要求出一种分配方案，使得总的花费(打开设施的费用 + 分配顾客的费用)最小。 根据问题的需求及输入数据格式，我们可以把设施和顾客都抽象成结构体，属性如下： 12345678910struct facility &#123; int capacity; int leftCapa;//剩余容量 int openCost; facility(int capacity, int openCost) &#123; this-&gt;capacity = capacity; this-&gt;openCost = openCost; this-&gt;leftCapa = capacity; &#125;&#125;； 1234567struct customer &#123; int demand; vector&lt;int&gt; assigncost; customer(int demand) &#123; this-&gt;demand = demand; &#125;&#125;; 利用循环读取数据就可以初始化所有的设施和顾客，然后我们需要求解： totalcost = opencost + assigncost 所有设施的打开状态open 每个顾客被分配到的设施 分别用一个int变量和两个数组vector&lt;bool&gt; open和vector&lt;int&gt; assign即可存放结果。 我使用的两种算法是贪心算法+模拟退火算法。 项目代码github地址：https://github.com/chenf99/CFLP/tree/master/code 项目代码结构： 1234567├── CFLP.cpp #主函数，主要处理输入输出及调用其他函数├── CFLP.hpp #声明函数及抽象结构体├── SA.cpp #模拟退火算法├── greedy.cpp #贪心算法├── io.cpp #处理文件的读写├── Instances/ #输入的数据实例└── Results/ #算法的历史最优解 贪心算法思想使用贪心算法的重点是确定每一步的选择策略，策略定下来后，贪心算法的最终解都是不会变的。 解的主要变化部分在于分配方式assign，因此我考虑的主要是优化每一次分配方式，使得剩余容量多，且花费少。 我的贪心算法采取的策略是每次操作分配一个顾客到一个设施，并且每次进行的操作都是当前最优的操作，对于“最优”，我定义为性价比最高，即opencost + assigncost / demand最小的操作，在每次分配后把对应设施的opencost设为0，表示已经打开；并且在之后选取最优操作时，不会考虑已经被分配的顾客。 代码12345678910111213141516171819202122232425262728int greedy(vector&lt;bool&gt;&amp; open, vector&lt;int&gt;&amp; assign, vector&lt;facility&gt;&amp; facilities, vector&lt;customer&gt;&amp; customers) &#123; int totalCost = 0; while (true) &#123; int performance = INT_MAX; int currAssignCost = INT_MAX; int select_i = -1, select_j = -1; for (int i = 0; i &lt; customers.size(); ++i) &#123; if (assign[i] != -1) continue; //该customer已被分配过 for (int j = 0; j &lt; facilities.size(); ++j) &#123; //更换当前最优操作 if ((customers[i].assigncost[j] + facilities[j].openCost / customers[i].demand) &lt; performance &amp;&amp; facilities[j].capacity &gt;= customers[i].demand) &#123; select_i = i; select_j = j; performance = customers[i].assigncost[j] + facilities[j].openCost / customers[i].demand; currAssignCost = customers[i].assigncost[j] + facilities[j].openCost; &#125; &#125; &#125; if (currAssignCost == INT_MAX || select_i == -1 || select_j == -1) break;//分配完成 totalCost += currAssignCost; facilities[select_j].openCost = 0; facilities[select_j].capacity -= customers[select_i].demand; open[select_j] = true; assign[select_i] = select_j; &#125; return totalCost;&#125; 模拟退火算法使用贪心算法的话，很大程度上会局限于我们的策略，导致得不到比较好的解，而且对于不同的案例可能适合的策略也不同，因此我们最好还是使用启发式搜索来解决这种问题。 思想模拟退火算法是在爬山法的基础上改进得来的，它避免了爬山法因为邻域没有更优解(陷入局部最优)而导致的问题，通过概率接受差解，能够跳出局部最优解，然后继续搜索寻找全局最优解。 模拟退火算法的基本步骤如下： 随机生成一个初始解，设置初温T、莫温T_end、每轮迭代次数count 迭代count次，对每次迭代进行如下操作： 产生新解 计算新解与原始解的评估值之差ΔE 如果ΔE &lt; 0则新解更好，接受新解 否则以概率exp(-ΔE/T)接受差解 如果满足终止条件则得到最优解，终止程序 当前温度迭代次数完成，降温，一般降温方法为T = 0.99 * T 温度T &lt;= T_end时结束程序 在本题中，解就是设施打开状态open和分配方案assign，解的评估值就是总的cost 产生新解的方法我采取了两种策略，每次迭代时随机选择一种： 随机选择两个customer，互相交换分配的facility 随机选择一个customer，把它随机分配到另外一个facility 本来我还采取了2-opt、插入策略和随机一次分配方式的策略，但感觉对效果没有提升，反而导致了产生好解的概率下降了，因此就抛弃了它们 此外，根据输入数据中后面复杂情况下opencost很大的特点，我对产生初始解的方法进行了优化，即随机打开一个设施，给它分配顾客，直到容量已满为止，再去打开新的设施，直到所有顾客都被分配到。这样就可以减少很多opencost，对于后面复杂的情况优化效果明显。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158int SA(int i, vector&lt;bool&gt;&amp; open, vector&lt;int&gt;&amp; assign, vector&lt;facility&gt;&amp; facilities, vector&lt;customer&gt;&amp; customers) &#123; double T = 10000; //初温 double T_end = 0.0001; //末温 int count = 500; //每个温度迭代次数 //随机生成初始解 randomInitSolution(open, assign, facilities, customers); int opencost = 0; for (int i = 0; i &lt; facilities.size(); ++i) &#123; if (open[i] == true) opencost += facilities[i].openCost; &#125; vector&lt;int&gt; currAssign(assign); vector&lt;bool&gt; currOpen(open); vector&lt;facility&gt; currFacilities(facilities); int currCost = 0; for (int i = 0; i &lt; customers.size(); ++i) currCost += customers[i].assigncost[currAssign[i]]; for (int i = 0; i &lt; open.size(); ++i) &#123; if (open[i] == true) currCost += currFacilities[i].openCost; &#125; while (T &gt; T_end) &#123; count = 500; while (count--) &#123; //生成新解 int select = rand() % 2; if (select == 1) &#123; //随机交换assign的facility，不会改变curropen vector&lt;int&gt; tmpAssign(currAssign); vector&lt;facility&gt; tmpFacilities(currFacilities); int customer1 = rand() % customers.size(); int customer2 = rand() % customers.size(); if (customer1 != customer2) &#123; tmpFacilities[tmpAssign[customer1]].leftCapa += customers[customer1].demand; tmpFacilities[tmpAssign[customer2]].leftCapa += customers[customer2].demand; int tmp = tmpAssign[customer1]; tmpAssign[customer1] = tmpAssign[customer2]; tmpAssign[customer2] = tmp; tmpFacilities[tmpAssign[customer1]].leftCapa -= customers[customer1].demand; tmpFacilities[tmpAssign[customer2]].leftCapa -= customers[customer2].demand; &#125; if (isValidSolution(open, tmpAssign, tmpFacilities)) &#123; int cost = 0; for (int i = 0; i &lt; customers.size(); ++i) &#123; cost += customers[i].assigncost[tmpAssign[i]]; &#125; for (int i = 0; i &lt; open.size(); ++i) &#123; if (open[i] == true) cost += tmpFacilities[i].openCost; &#125; int dE = cost - currCost; if (dE &lt; 0) &#123; //直接接受好的新解 currCost = cost; currAssign = tmpAssign; currFacilities = tmpFacilities; &#125; else if (dE &gt; 0) &#123; //以概率接受差的新解 double rd = rand() / (RAND_MAX + 1.0);//0到1的随机数 if (exp(-dE / T) &gt; rd) &#123; currCost = cost; currAssign = tmpAssign; currFacilities = tmpFacilities; &#125; &#125; &#125; &#125; else &#123; //随机让一个customer分配到别的facility int customer_select = rand() % customers.size(); int facility_select = rand() % facilities.size(); vector&lt;int&gt; tmpAssign(currAssign); vector&lt;facility&gt; tmpFacilities(currFacilities); vector&lt;bool&gt; tmpOpen(currOpen); tmpFacilities[tmpAssign[customer_select]].leftCapa += customers[customer_select].demand; //关闭facility if (tmpFacilities[tmpAssign[customer_select]].leftCapa == tmpFacilities[tmpAssign[customer_select]].capacity) &#123; tmpOpen[tmpAssign[customer_select]] = false; &#125; tmpAssign[customer_select] = facility_select; if (tmpFacilities[facility_select].leftCapa &gt; customers[customer_select].demand) &#123; tmpFacilities[facility_select].leftCapa -= customers[customer_select].demand; tmpOpen[facility_select] = true; int cost = 0; for (int i = 0; i &lt; customers.size(); ++i) &#123; cost += customers[i].assigncost[tmpAssign[i]]; &#125; for (int i = 0; i &lt; tmpOpen.size(); ++i) &#123; if (tmpOpen[i] == true) cost += tmpFacilities[i].openCost; &#125; int dE = cost - currCost; if (dE &lt; 0) &#123;//直接接受好的新解 currCost = cost; currAssign = tmpAssign; currFacilities = tmpFacilities; currOpen = tmpOpen; &#125; else if (dE &gt; 0) &#123; //以概率接受差的新解 double rd = rand() / (RAND_MAX + 1.0);//0到1的随机数 if (exp(-dE / T) &gt; rd) &#123; currCost = cost; currAssign = tmpAssign; currFacilities = tmpFacilities; currOpen = tmpOpen; &#125; &#125; &#125; &#125; &#125; T = 0.99 * T;//降温 &#125; assign = currAssign; open = currOpen; facilities = currFacilities; return currCost;&#125;bool isValidSolution(const vector&lt;bool&gt;&amp; open, const vector&lt;int&gt;&amp; assign, const vector&lt;facility&gt;&amp; facilities) &#123; for (int i = 0; i &lt; assign.size(); ++i) &#123; if (open[assign[i]] == true) &#123; if (facilities[assign[i]].leftCapa &lt; 0) return false; &#125; else return false; &#125; return true;&#125;void randomInitSolution(vector&lt;bool&gt;&amp; open, vector&lt;int&gt;&amp; assign, vector&lt;facility&gt;&amp; facilities, const vector&lt;customer&gt;&amp; customers) &#123; srand(time(NULL)); int cust_select = 0; while (true) &#123; //随机打开一个工厂，给这个工厂分配顾客 //直到给这个工厂分配完顾客，再选取下一个工厂 //减少打开工厂的费用 int open_select = rand() % open.size(); open[open_select] = true; while (facilities[open_select].leftCapa &gt;= customers[cust_select].demand) &#123; facilities[open_select].leftCapa -= customers[cust_select].demand; assign[cust_select] = open_select; cust_select++; if (cust_select == customers.size()) break; &#125; if (cust_select == customers.size()) break;//全都分配完 &#125; //验证解的有效性 for (auto i : assign) &#123; if (i == -1 || open[i] == false) &#123; cout &lt;&lt; "error init solution" &lt;&lt; endl; exit(1); &#125; &#125; int count = 0; for (int i = 0; i &lt; facilities.size(); i++) &#123; if (facilities[i].leftCapa &lt; 0) &#123; cout &lt;&lt; "error init solution" &lt;&lt; endl; exit(1); &#125; if (open[i] == true) count += facilities[i].openCost; &#125;&#125; 结果使用两种算法得到的结果如下所示(历史最优解见github) 贪心算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622P1 result:Total cost: 9307Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 0 3 4 0 9 7 3 4 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP2 result:Total cost: 7993Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 0 3 4 0 9 7 3 4 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP3 result:Total cost: 9993Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 0 3 4 0 9 7 3 4 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP4 result:Total cost: 11993Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 0 3 4 0 9 7 3 4 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP5 result:Total cost: 9220Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 7 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 8 4 1 8 1 5 7 0 2 0 7 0Running Time : 1msP6 result:Total cost: 7906Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 7 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 8 4 1 8 1 5 7 0 2 0 7 0Running Time : 1msP7 result:Total cost: 9906Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 7 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 8 4 1 8 1 5 7 0 2 0 7 0Running Time : 0msP8 result:Total cost: 11906Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 7 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 8 4 1 8 1 5 7 0 2 0 7 0Running Time : 0msP9 result:Total cost: 9040Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 8 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 1msP10 result:Total cost: 7726Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 8 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP11 result:Total cost: 9726Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 8 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP12 result:Total cost: 11726Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 8 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 8 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 0 4 1 8 1 5 7 0 4 0 4 0Running Time : 0msP13 result:Total cost: 12032Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP14 result:Total cost: 9180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP15 result:Total cost: 13180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP16 result:Total cost: 17193Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 14 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP17 result:Total cost: 12032Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP18 result:Total cost: 9180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP19 result:Total cost: 13180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP20 result:Total cost: 17193Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 14 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP21 result:Total cost: 12032Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 1msP22 result:Total cost: 9180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 0msP23 result:Total cost: 13180Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 12 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 0msP24 result:Total cost: 17193Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:16 12 10 10 1 18 17 13 14 17 15 4 1 6 13 3 15 10 4 9 14 15 15 19 6 17 16 17 1 17 13 7 2 16 3 10 11 19 19 13 6 0 5 0 8 5 14 10 19 9Running Time : 0msP25 result:Total cost: 14918Open status:1 0 1 0 1 1 1 1 1 0 0 1 0 0 1 1 1 1 0 0 1 1 0 0 1 0 1 0 1 0Assignment of customer:20 11 20 14 6 5 2 24 20 0 26 16 20 20 2 14 14 0 5 11 2 4 21 17 24 20 17 24 5 24 21 11 6 11 20 20 24 15 4 14 0 14 15 6 24 14 4 20 11 14 21 14 14 5 20 20 14 4 17 14 0 5 20 11 11 11 24 0 26 24 20 6 11 0 24 8 26 20 2 24 20 7 20 0 17 0 17 4 20 5 2 24 17 11 17 24 2 4 21 6 16 17 14 11 2 5 4 11 14 28 14 17 2 11 11 4 24 24 24 24 5 16 11 20 16 4 5 24 17 21 0 17 24 5 20 14 4 5 20 17 0 20 20 14 8 5 11 5 2 5Running Time : 10msP26 result:Total cost: 13239Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1Assignment of customer:20 25 20 2 20 5 19 24 19 17 24 20 8 20 17 14 14 17 5 11 19 0 24 0 24 8 19 24 24 24 29 25 20 25 20 20 24 15 17 14 0 14 15 20 2414 17 20 0 8 0 14 14 5 20 20 2 0 0 14 0 5 20 0 11 11 24 0 0 24 20 20 11 17 24 8 24 20 19 24 20 0 20 11 19 11 17 0 20 29 2 24 00 17 24 2 0 29 20 20 0 14 25 19 29 0 0 14 28 14 19 2 11 11 0 24 24 24 24 5 20 25 20 20 0 5 24 0 25 0 0 24 5 8 14 0 5 20 17 0 820 14 8 0 25 5 2 5Running Time : 10msP27 result:Total cost: 15832Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 1 0Assignment of customer:13 11 13 2 13 5 14 9 17 0 9 13 20 20 3 14 14 17 5 11 14 11 9 3 9 20 17 24 5 9 5 11 13 11 20 20 24 15 11 14 17 14 15 3 24 14 3 13 11 14 9 14 14 5 13 20 17 3 11 14 0 5 20 11 11 11 9 0 9 9 13 13 11 0 24 8 9 20 14 9 20 17 13 0 17 0 17 11 20 5 2 24 17 11 17 9 2 3 5 13 13 17 14 11 2 5 11 11 14 28 14 3 2 11 11 9 24 24 24 24 5 13 5 13 13 3 5 9 11 5 0 5 24 9 14 14 3 5 20 17 0 20 20 14 85 11 5 2 5Running Time : 8msP28 result:Total cost: 18601Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0Assignment of customer:13 11 8 2 8 5 3 9 3 0 22 8 8 20 3 14 14 17 5 11 14 11 22 3 22 8 17 24 24 22 11 11 8 11 20 20 24 15 3 14 17 14 15 3 24 14 3 13 11 8 22 14 14 5 13 20 2 3 11 14 0 5 20 11 11 11 22 0 22 22 8 13 11 0 24 8 22 20 3 9 13 17 13 0 17 17 17 11 20 11 2 24 17 11 17 22 2 22 11 8 8 17 14 11 2 11 11 11 8 8 14 3 2 11 11 22 24 24 24 24 5 8 11 13 8 3 5 22 11 22 0 11 24 22 8 14 3 5 20 17 0 8 20 148 11 11 5 2 5Running Time : 8msP29 result:Total cost: 16680Open status:1 0 1 0 1 1 1 0 1 1 0 1 0 1 1 1 1 1 0 0 1 1 0 0 1 0 1 0 1 0Assignment of customer:20 11 20 2 6 5 2 24 17 17 26 16 20 20 17 14 14 17 5 11 2 4 21 17 24 20 17 24 5 24 21 11 6 11 8 20 5 15 4 14 17 14 15 6 24 14 420 11 14 21 14 14 5 20 13 2 4 17 14 0 5 8 11 11 11 24 0 26 24 20 6 11 0 9 8 26 20 2 24 13 17 20 0 17 0 17 4 20 5 2 24 17 11 1724 2 4 21 6 16 17 14 11 2 5 4 11 14 28 14 17 2 11 11 4 24 15 0 24 5 16 11 20 16 4 5 24 17 21 0 17 24 5 20 14 4 5 13 17 0 20 1314 8 5 11 5 2 5Running Time : 11msP30 result:Total cost: 14860Open status:1 0 1 0 0 1 1 0 1 1 0 1 0 1 1 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1Assignment of customer:20 11 20 2 20 5 19 24 19 0 24 20 8 20 17 14 14 17 5 11 19 0 24 19 24 8 19 24 24 24 29 25 6 25 8 20 11 15 11 14 0 14 15 20 5 1417 20 0 8 0 14 14 5 6 13 17 0 0 14 0 5 8 25 11 11 24 0 0 24 8 20 11 17 9 8 24 20 19 24 13 17 20 17 19 17 17 17 20 29 2 9 17 0 17 24 2 0 29 20 20 17 14 25 19 29 0 11 14 28 14 19 2 11 11 0 24 15 5 5 5 20 25 20 20 0 5 24 0 25 11 0 24 5 8 14 0 5 13 17 0 8 13 14 8 0 25 5 2 5Running Time : 9msP31 result:Total cost: 16230Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 1 0Assignment of customer:13 11 13 2 13 5 14 9 17 0 9 13 20 20 3 14 0 17 5 0 17 11 9 3 9 20 17 24 5 9 5 11 13 11 20 20 24 15 11 14 17 14 15 3 24 14 3 1311 14 9 14 14 5 13 20 2 3 11 14 0 24 20 11 0 11 9 0 9 9 13 13 0 17 24 8 9 20 17 9 20 17 13 0 17 17 17 17 20 5 2 24 17 11 17 9 2 3 5 13 13 17 0 11 2 5 11 11 14 28 14 3 2 11 11 9 24 24 24 24 0 13 5 13 13 3 5 9 11 5 0 5 24 9 14 14 3 5 20 17 0 20 20 14 8 5 11 5 2 24Running Time : 7msP32 result:Total cost: 18587Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0Assignment of customer:13 0 8 2 8 5 3 9 3 0 22 8 8 20 3 14 14 17 5 0 17 11 22 3 22 8 17 24 5 22 11 5 13 11 20 20 24 15 3 14 17 14 15 3 24 14 3 13 11 8 22 14 14 5 13 20 17 3 11 14 0 5 20 11 0 11 22 0 22 22 13 13 5 17 24 8 22 20 3 9 13 17 13 0 17 17 17 17 20 5 2 24 17 11 17 22 2 22 11 8 8 17 14 11 2 11 17 11 8 8 14 3 2 11 11 22 24 24 24 24 5 8 11 13 8 3 5 22 11 22 0 11 24 22 8 14 3 5 20 17 0 8 20 14 8 11 11 5 2 5Running Time : 11msP33 result:Total cost: 14643Open status:1 0 1 0 1 1 1 0 1 0 0 1 0 0 1 1 1 1 0 0 1 1 0 0 1 0 1 0 1 0Assignment of customer:20 11 20 2 6 5 2 24 17 17 26 16 20 20 17 14 14 17 5 11 2 4 21 17 24 20 17 24 5 24 21 11 6 11 20 20 24 15 4 14 17 14 15 6 24 144 20 11 14 21 14 14 5 20 20 17 4 17 14 0 5 8 11 11 11 24 0 26 24 20 6 11 17 24 8 26 20 17 24 20 17 20 17 17 17 17 4 20 5 2 24 17 11 17 24 2 4 21 6 16 17 14 11 2 5 4 11 14 28 14 17 2 11 11 4 24 24 24 24 5 16 11 20 16 4 5 24 17 21 0 17 24 5 20 14 4 5 8 170 20 20 14 8 5 11 5 2 5Running Time : 11msP34 result:Total cost: 13867Open status:1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1Assignment of customer:20 25 20 2 20 5 19 24 19 17 24 20 8 20 17 14 14 17 5 11 19 0 24 0 24 8 19 24 24 24 29 25 20 25 8 20 24 15 17 14 0 14 15 20 24 14 17 20 0 8 0 14 14 5 20 13 17 0 0 14 0 5 8 0 11 11 24 0 0 24 20 20 11 17 9 8 24 20 19 24 13 0 20 17 19 17 17 17 20 29 2 24 0 0 17 24 2 0 29 20 20 0 17 25 19 29 0 0 14 28 14 19 2 11 11 0 24 24 5 24 5 20 25 20 20 0 5 24 0 25 17 0 24 5 8 14 0 5 13 17 0 8 13 14 8 0 25 5 2 5Running Time : 11msP35 result:Total cost: 15588Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 1 0Assignment of customer:13 11 13 2 13 5 17 9 17 17 9 13 20 20 3 14 14 17 5 11 17 11 9 3 9 20 17 24 5 9 5 11 13 11 20 20 24 15 11 14 17 14 15 3 24 14 313 11 14 9 14 14 5 13 20 17 3 11 14 0 5 20 11 11 11 9 0 9 9 13 13 11 17 24 8 9 20 17 9 20 17 13 17 17 17 17 11 20 5 2 24 17 1117 9 2 3 5 13 13 17 17 11 2 5 11 11 14 28 14 3 2 11 11 9 24 24 24 24 5 13 5 13 13 3 5 9 11 5 0 5 24 9 14 14 3 5 20 17 0 20 20 14 8 5 11 5 2 5Running Time : 7msP36 result:Total cost: 18512Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0Assignment of customer:13 11 8 2 8 5 17 9 3 17 22 8 8 20 3 14 14 17 5 0 17 11 22 3 22 8 17 24 24 22 11 11 8 11 20 20 24 15 3 14 17 14 15 3 24 14 3 1311 8 22 14 14 5 13 20 17 3 11 14 0 5 20 11 11 11 22 0 22 22 8 13 5 17 24 8 22 20 3 9 13 17 13 17 17 17 17 17 20 11 17 24 17 1117 22 2 22 11 8 8 17 14 11 17 11 11 11 8 8 14 3 2 11 11 22 24 24 24 24 5 8 11 13 8 3 5 22 11 22 0 11 24 22 8 14 3 5 20 17 0 8 20 14 8 11 11 5 2 5Running Time : 8msP37 result:Total cost: 14223Open status:1 0 1 0 1 1 1 0 1 0 0 1 0 0 1 1 1 1 0 0 1 1 0 0 1 0 1 0 1 0Assignment of customer:20 11 20 2 6 5 2 24 17 17 26 16 20 20 17 14 14 17 5 11 2 4 21 17 24 20 17 24 5 24 21 11 6 11 20 20 24 15 4 14 17 14 15 6 24 144 20 11 14 21 14 14 5 20 20 17 4 17 14 0 5 20 11 11 11 24 0 26 24 20 6 11 17 24 8 26 20 17 24 20 17 20 17 17 17 17 4 20 5 2 2417 11 17 24 2 4 21 6 16 17 17 11 2 5 4 11 14 28 14 17 2 11 11 4 24 24 24 24 5 16 11 20 16 4 5 24 17 21 0 17 24 5 20 14 4 5 20 17 0 20 20 14 8 5 11 5 2 5Running Time : 9msP38 result:Total cost: 12386Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1Assignment of customer:20 25 20 2 20 5 19 24 19 17 24 20 8 20 17 14 14 17 5 11 19 0 24 0 24 8 19 24 24 24 29 25 20 25 20 20 24 15 0 14 0 14 15 20 24 14 0 20 0 8 0 14 14 5 20 20 17 0 0 14 0 5 20 0 11 11 24 0 0 24 20 20 11 17 24 8 24 20 19 24 20 0 20 17 19 17 17 0 20 29 2 24 0 0 0 24 2 0 29 20 20 0 17 25 19 29 0 0 14 28 14 19 2 11 11 0 24 24 24 24 5 20 25 20 20 0 5 24 0 25 0 0 24 5 8 14 0 5 20 17 0 8 20 14 8 0 25 5 2 5Running Time : 7msP39 result:Total cost: 15588Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 1 0Assignment of customer:13 11 13 2 13 5 17 9 17 17 9 13 20 20 3 14 14 17 5 11 17 11 9 3 9 20 17 24 5 9 5 11 13 11 20 20 24 15 11 14 17 14 15 3 24 14 313 11 14 9 14 14 5 13 20 17 3 11 14 0 5 20 11 11 11 9 0 9 9 13 13 11 17 24 8 9 20 17 9 20 17 13 17 17 17 17 11 20 5 2 24 17 1117 9 2 3 5 13 13 17 17 11 2 5 11 11 14 28 14 3 2 11 11 9 24 24 24 24 5 13 5 13 13 3 5 9 11 5 0 5 24 9 14 14 3 5 20 17 0 20 20 14 8 5 11 5 2 5Running Time : 7msP40 result:Total cost: 18441Open status:1 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0Assignment of customer:13 11 8 2 8 5 17 9 3 17 22 8 8 20 3 14 14 17 5 11 17 11 22 3 22 8 17 24 24 22 11 11 8 11 20 20 24 15 3 14 17 14 15 3 24 14 3 13 11 8 22 14 14 5 13 20 17 3 11 14 0 5 20 11 11 11 22 0 22 22 8 13 11 17 24 8 22 20 3 9 13 17 13 17 17 17 17 11 20 11 17 24 17 11 17 22 2 22 11 8 8 17 17 11 17 11 11 11 8 8 14 3 2 11 11 22 24 24 24 24 5 8 11 13 8 3 5 22 11 22 0 11 24 22 8 14 3 5 20 17 0 8 20 14 8 11 11 5 2 5Running Time : 7msP41 result:Total cost: 7155Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:5 6 4 1 7 7 3 7 8 8 4 6 2 6 2 7 7 3 0 6 6 1 4 1 6 5 5 4 8 5 8 0 0 0 3 9 2 6 6 2 2 7 3 3 3 5 0 5 6 4 1 6 6 6 9 7 2 8 8 8 0 0 1 5 0 6 6 6 5 4 0 0 4 0 7 7 2 2 6 5 7 9 9 7 9 9 9 9 9 2Running Time : 2msP42 result:Total cost: 7758Open status:1 1 0 1 0 1 1 0 1 0 0 1 1 1 1 1 1 1 0 1Assignment of customer:12 14 3 14 15 19 16 3 16 1 11 8 6 14 19 15 0 13 14 14 5 11 5 8 8 8 11 16 17 13 1 19 6 8 14 19 6 15 0 1 1 3 3 16 11 14 8 19 15 15 16 17 1 13 13 5 16 14 14 14 3 3 3 3 11 3 0 15 19 6 19 8 19 19 19 19 19 19 19 19Running Time : 1msP43 result:Total cost: 8450Open status:1 1 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 0 1 1 0 0 1 1 1 1 1 1Assignment of customer:18 21 18 24 25 20 25 21 1 29 24 1 13 17 12 11 21 11 12 12 25 26 20 20 20 13 28 18 29 29 29 24 13 13 0 0 25 12 21 18 27 12 28 24 24 25 26 17 17 11 21 25 25 18 18 18 21 20 13 29 5 27 1 29 28 28 1 28 28 28Running Time : 2msP44 result:Total cost: 7222Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:4 4 4 4 4 4 4 4 6 0 0 0 0 0 0 0 1 1 1 1 6 1 6 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 0 1 1 8 8 7 5 9 7 7 6 5 5 8 8 7 7 9 5 5 5 9 3 0 6 6 8 1 5 4 9 5 7 7 8 6 6 5 2 7 9 9 9 9 9 6 5 7 5Running Time : 1msP45 result:Total cost: 8663Open status:1 1 1 0 1 1 1 1 1 0 1 1 1 0 0 1 1 1 1 1Assignment of customer:0 0 0 0 0 0 0 1 1 1 1 1 1 6 6 2 2 2 2 2 2 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 0 0 2 2 11 12 18 16 18 7 15 16 8 8 11 16 18 19 5 15 10 10 12 2 15 17 18 7 11 12 7 10 18 12 18 17 17 17 11 16 10 7Running Time : 1msP46 result:Total cost: 9550Open status:1 1 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 0 0 0 0 1 1 0 1 1 1Assignment of customer:10 0 10 10 10 0 10 1 1 1 1 1 1 11 11 2 2 2 2 2 2 5 5 5 5 5 5 7 8 8 8 8 8 9 10 2 2 17 24 28 28 12 15 28 24 14 14 17 29 28 29 2713 11 25 14 13 28 12 17 19 15 28 28 14 27 17 13 15 12Running Time : 2msP47 result:Total cost: 6490Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:0 0 0 0 0 0 0 0 0 0 2 1 1 1 1 2 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 7 7 6 7 6 0 7 7 7 7 7 7 6 8 8 8 8 8 6 0 6 2 9 9 9 9 9 9Running Time : 2msP48 result:Total cost: 7629Open status:1 1 1 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1Assignment of customer:1 0 1 1 1 1 1 1 1 2 3 2 2 3 3 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 8 8 8 8 8 8 8 8 8 9 9 10 10 10 10 10 10 13 13 12 13 13 12 13 15 15 12 15 13 0 15 15 15 15 16 17 17 17 17 17 17 17 18 19 19 19 19 19 19Running Time : 1msP49 result:Total cost: 7108Open status:1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 1 1 1 0Assignment of customer:0 0 0 0 0 0 0 0 3 5 3 5 5 7 7 7 7 7 7 7 7 7 9 9 9 11 11 13 13 13 13 13 13 13 13 13 16 16 16 16 16 16 19 19 19 19 19 19 22 19 22 19 0 22 22 22 22 24 26 26 26 26 26 26 27 28 28 28 28 28Running Time : 2msP50 result:Total cost: 10453Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 0 3 0 2 9 5 5 3 7 7 4 1 2 6 2 9 5 5 3 0 6 6 4 0 0 8 8 4 7 7 7 3 3 3 5 9 2 6 0 6 9 6 9 5 5 5 5 5 3 3 5 0 0 0 0 6 0 1 9 9 7 7 7 3 3 6 4 8 3 3 0 0 0 0 3 3 3 3 3 3 5 5 9 2 2 6 5 1 7 9 9 2 1 1 9 9 9 9 9Running Time : 2msP51 result:Total cost: 9619Open status:1 1 0 1 0 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1Assignment of customer:1 13 15 10 12 12 1 5 15 1 5 14 13 18 6 13 12 12 5 15 14 0 10 14 14 14 1 14 19 15 1 15 15 19 15 5 13 18 10 14 0 13 6 13 5 5 5 55 15 15 1 14 14 14 0 0 13 13 12 13 5 1 5 15 15 10 3 1 1 15 0 0 0 10 15 15 15 19 14 15 5 12 12 18 18 6 1 12 1 13 12 13 13 13 1213 13 12 13Running Time : 3msP52 result:Total cost: 11037Open status:0 1 1 1 1 1 1 1 1 1Assignment of customer:7 7 7 7 7 7 7 7 3 4 4 4 3 4 4 4 4 5 5 8 3 3 3 8 3 1 6 9 9 9 1 9 9 5 6 6 6 6 6 6 6 6 6 6 7 7 4 8 8 5 5 8 3 6 2 5 3 3 3 4 6 9 5 8 8 8 9 6 4 7 6 6 4 3 3 5 3 4 7 9 1 3 8 5 9 3 3 4 5 9 9 9 9 1 9 1 3 2 3 2Running Time : 2msP53 result:Total cost: 11409Open status:0 1 0 1 0 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1Assignment of customer:5 5 5 6 5 5 5 5 1 7 19 7 7 7 7 7 7 13 13 12 12 13 13 12 3 15 15 9 9 9 9 9 9 15 18 18 18 18 18 18 18 18 18 18 5 5 7 12 12 15 1512 1 17 5 15 3 3 1 6 5 9 15 12 1 12 9 5 7 5 17 18 6 1 3 15 3 6 6 8 14 1 12 15 9 3 1 5 15 8 8 8 9 9 9 17 3 1 1 5Running Time : 2msP54 result:Total cost: 11100Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:9 7 9 9 9 7 7 7 9 7 7 2 2 2 2 2 2 2 2 1 1 1 1 1 3 1 1 2 1 1 3 3 3 3 3 3 3 3 3 8 8 6 8 8 8 6 8 8 8 8 8 8 6 6 6 6 6 6 6 6 0 0 5 0 0 0 0 6 0 4 4 0 0 5 9 0 0 0 0 0 4 4 4 4 4 0 4 4 4 0 9 4 4 4 4 9 2 9 9 2Running Time : 1msP55 result:Total cost: 10209Open status:1 0 1 0 0 1 1 1 1 1 1 0 1 1 0 1 0 1 1 0Assignment of customer:8 17 8 8 8 17 17 2 8 8 8 2 2 8 2 2 2 2 2 8 12 12 8 12 6 8 12 12 12 12 6 6 6 6 6 6 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 10 7 7 710 7 13 13 13 13 9 9 9 10 9 13 13 9 9 13 17 9 9 13 9 9 13 15 13 15 15 9 5 15 5 9 5 18 18 17 17 17 18 17 17 17Running Time : 2msP56 result:Total cost: 23892Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 19 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 23 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 14msP57 result:Total cost: 32917Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 221 6 4 7 12 7 15 10 19Running Time : 14msP58 result:Total cost: 54462Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 10 1 28 18 1 10 22 0 18 21 5 24 10 18 27 19 29 2 19 19 4 21 27 6 20 8 24 15 18 9 6 4 8 19 3 21 19 14 24 24 24 21 8 12 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 19 9 23 23 20 23 8 24 10 0 9 25 29 10 6 2 27 7 28 19 25 25 2 3 11 6 0 28 28 15 12 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 10 23 9 3 3 28 10 12 2211 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 15msP59 result:Total cost: 39237Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 21 8 6 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 2 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 18msP60 result:Total cost: 23892Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 19 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 23 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 19msP61 result:Total cost: 32917Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 221 6 4 7 12 7 15 10 19Running Time : 18msP62 result:Total cost: 54462Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 10 1 28 18 1 10 22 0 18 21 5 24 10 18 27 19 29 2 19 19 4 21 27 6 20 8 24 15 18 9 6 4 8 19 3 21 19 14 24 24 24 21 8 12 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 19 9 23 23 20 23 8 24 10 0 9 25 29 10 6 2 27 7 28 19 25 25 2 3 11 6 0 28 28 15 12 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 10 23 9 3 3 28 10 12 2211 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 15msP63 result:Total cost: 39237Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 21 8 6 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 2 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 14msP64 result:Total cost: 23892Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 19 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 23 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 15msP65 result:Total cost: 32917Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 221 6 4 7 12 7 15 10 19Running Time : 19msP66 result:Total cost: 54462Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 10 1 28 18 1 10 22 0 18 21 5 24 10 18 27 19 29 2 19 19 4 21 27 6 20 8 24 15 18 9 6 4 8 19 3 21 19 14 24 24 24 21 8 12 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 19 9 23 23 20 23 8 24 10 0 9 25 29 10 6 2 27 7 28 19 25 25 2 3 11 6 0 28 28 15 12 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 10 23 9 3 3 28 10 12 2211 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 16msP67 result:Total cost: 39825Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 22 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 15 18 9 6 26 8 19 13 21 19 14 24 16 24 21 20 6 11 9 18 25 29 0 7 8 13 12 5 14 28 25 7 12 19 9 23 23 20 23 8 24 10 0 9 25 29 13 19 2 27 7 28 6 25 25 2 3 27 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 12msP68 result:Total cost: 23892Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 19 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 23 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 17msP69 result:Total cost: 32917Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 16 8 6 11 9 18 7 29 0 7 8 13 11 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 5 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 221 6 4 7 12 7 15 10 19Running Time : 17msP70 result:Total cost: 54462Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 10 1 28 18 1 10 22 0 18 21 5 24 10 18 27 19 29 2 19 19 4 21 27 6 20 8 24 15 18 9 6 4 8 19 3 21 19 14 24 24 24 21 8 12 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 19 9 23 23 20 23 8 24 10 0 9 25 29 10 6 2 27 7 28 19 25 25 2 3 11 6 0 28 28 15 12 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 10 23 9 3 3 28 10 12 2211 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 3 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 16msP71 result:Total cost: 39237Open status:1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 1 28 18 1 20 22 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 1321 19 14 24 16 24 21 8 6 11 9 18 7 29 0 7 8 13 25 5 14 28 25 18 12 6 9 23 23 20 23 8 16 10 0 9 25 29 13 6 2 27 7 28 6 25 25 2 3 11 6 0 28 28 15 25 18 4 0 4 24 22 3 19 4 27 12 12 8 28 7 17 8 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 12 22 11 25 25 5 24 15 27 25 24 17 23 0 8 11 2 15 3 13 13 27 10 24 23 27 5 4 3 21 1 20 19 14 26 2 0 10 29 10 5 21 2 19 12 8 28 23 0 212 21 6 4 7 12 7 15 10 19Running Time : 18ms SA算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616P1 result:Total cost: 8863Open status:1 1 1 1 1 0 1 0 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 0 3 2 8 3 4 0 9 4 3 4 6 4 2 6 1 6 0 1 2 6 0 3 9 4 4 3 0 4 3 8 1 6 4 0 2 0 4 0Running Time : 1915msP2 result:Total cost: 7913Open status:1 1 1 1 1 0 1 0 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 0 3 2 8 3 4 0 9 4 3 4 6 4 2 6 1 6 0 1 2 6 0 3 9 4 4 3 0 4 3 8 1 6 4 0 2 0 4 0Running Time : 1803msP3 result:Total cost: 9668Open status:1 0 1 1 1 1 0 0 1 1Assignment of customer:0 2 5 5 3 8 2 4 4 5 9 8 3 2 8 3 4 0 9 4 3 4 9 4 2 5 3 5 8 5 2 5 0 3 9 4 4 3 0 4 5 8 3 5 4 0 2 0 4 0Running Time : 1862msP4 result:Total cost: 11191Open status:1 0 1 1 1 1 1 0 0 0Assignment of customer:2 2 5 6 3 0 2 4 4 5 4 0 0 2 0 3 2 0 6 4 5 4 6 4 5 5 3 5 0 5 2 6 0 3 4 4 4 3 0 4 5 2 3 5 4 0 2 0 4 3Running Time : 2088msP5 result:Total cost: 9306Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 8 3 2 0 9 7 3 8 6 4 2 5 1 5 8 5 9 6 0 3 9 4 4 3 0 2 1 8 1 5 7 0 4 0 4 0Running Time : 1837msP6 result:Total cost: 7899Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:8 2 1 6 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 7 3 8 6 4 2 5 1 5 0 5 2 6 0 3 9 4 4 3 8 4 1 8 1 5 7 0 9 0 7 0Running Time : 1908msP7 result:Total cost: 9744Open status:1 1 1 1 1 1 1 1 1 0Assignment of customer:8 8 1 6 3 8 2 4 4 1 4 8 3 2 8 3 4 0 6 7 3 8 6 4 5 5 1 5 0 5 2 6 0 3 2 4 7 3 0 4 1 8 1 5 7 0 2 3 4 0Running Time : 2248msP8 result:Total cost: 11609Open status:1 1 1 1 1 1 1 1 1 0Assignment of customer:8 8 1 6 3 8 2 4 2 1 4 8 3 2 8 3 2 0 6 7 3 7 6 4 2 5 1 5 8 5 2 6 0 3 4 4 7 3 0 4 1 8 1 5 7 0 4 0 7 0Running Time : 2143msP9 result:Total cost: 8891Open status:1 1 1 1 1 1 0 0 1 1Assignment of customer:8 8 1 5 3 8 2 4 4 1 9 8 3 2 8 3 4 0 9 4 3 8 9 4 2 5 1 5 0 5 2 5 0 3 9 4 4 3 0 4 1 8 1 5 2 0 4 0 4 0Running Time : 2390msP10 result:Total cost: 7744Open status:1 1 1 1 1 1 1 0 1 0Assignment of customer:8 8 1 6 3 8 2 4 4 1 4 8 3 2 8 3 2 0 6 4 3 8 6 4 2 5 1 5 0 5 2 6 0 3 2 4 4 3 0 4 1 8 1 5 4 0 4 0 4 0Running Time : 2049msP11 result:Total cost: 9027Open status:1 1 1 1 1 0 1 0 1 0Assignment of customer:8 8 1 6 3 8 2 4 4 1 4 8 3 2 8 3 2 0 6 4 3 8 6 4 2 6 1 1 0 1 2 6 0 3 4 4 4 3 0 4 1 8 1 6 4 0 2 0 4 0Running Time : 2110msP12 result:Total cost: 10477Open status:1 1 1 1 1 0 1 0 1 0Assignment of customer:8 8 1 6 3 8 2 4 4 1 4 8 3 2 8 3 4 0 6 4 3 8 6 4 2 6 1 1 0 1 2 6 0 3 4 4 4 3 0 2 1 8 1 6 4 0 2 0 4 0Running Time : 2040msP13 result:Total cost: 8999Open status:1 1 0 0 0 0 0 0 0 1 1 1 0 1 1 1 0 1 1 0Assignment of customer:0 1 10 10 1 18 17 13 14 17 15 1 1 10 13 11 15 10 17 9 14 15 15 18 9 17 0 17 1 17 13 15 13 0 11 10 11 1 18 13 9 0 15 0 11 13 1410 18 9Running Time : 2794msP14 result:Total cost: 7164Open status:1 0 0 1 0 0 0 0 0 1 1 0 0 1 1 1 0 1 0 1Assignment of customer:0 3 10 10 19 13 17 13 14 17 15 19 19 10 13 3 15 10 17 9 14 15 15 19 9 17 0 17 3 17 13 15 13 0 3 10 3 19 19 13 9 0 15 0 3 13 1410 19 9Running Time : 2815msP15 result:Total cost: 9526Open status:1 1 0 1 0 0 0 1 0 1 1 0 0 1 0 1 0 1 0 1Assignment of customer:0 1 10 10 1 15 17 13 7 17 15 19 1 10 13 3 15 10 17 9 1 15 15 19 9 17 0 17 1 17 13 7 13 0 3 10 3 19 19 13 9 0 15 0 3 13 7 10 199Running Time : 2954msP16 result:Total cost: 11663Open status:0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1 0Assignment of customer:16 3 16 14 18 18 17 18 14 17 15 4 4 6 18 3 15 14 4 6 14 15 15 4 6 17 16 17 3 17 18 15 18 16 3 6 3 18 4 18 6 16 15 16 3 18 14 64 3Running Time : 2781msP17 result:Total cost: 8353Open status:0 1 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1Assignment of customer:16 1 10 10 1 15 17 13 14 17 15 19 1 10 13 14 15 10 17 9 14 15 15 19 9 1 16 17 1 17 13 15 13 16 1 10 17 19 19 13 9 16 15 16 9 13 14 10 19 9Running Time : 2789msP18 result:Total cost: 7335Open status:1 0 0 1 0 0 1 0 0 1 1 0 1 1 0 1 0 1 0 1Assignment of customer:0 12 10 10 19 12 17 13 12 17 15 19 19 6 13 3 15 10 17 9 12 15 15 19 6 17 0 17 3 17 13 15 13 0 3 10 3 19 19 13 6 0 0 15 3 13 1210 19 9Running Time : 2974msP19 result:Total cost: 9626Open status:1 1 0 1 1 0 1 0 0 0 1 0 0 1 1 1 0 1 0 0Assignment of customer:0 1 10 10 1 15 17 13 14 17 15 4 1 6 13 3 15 10 4 6 14 15 15 13 6 17 0 17 1 17 13 15 13 0 3 10 3 1 1 13 6 0 15 0 3 13 14 10 4 6Running Time : 2903msP20 result:Total cost: 12163Open status:0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0Assignment of customer:16 1 10 10 1 15 17 13 14 17 15 1 1 10 13 3 15 10 17 3 14 15 15 2 14 17 16 17 1 17 13 15 2 16 3 10 3 1 1 13 14 16 5 16 3 5 14 10 2 3Running Time : 3292msP21 result:Total cost: 8511Open status:0 1 0 0 0 0 1 0 0 0 1 0 0 1 1 1 1 1 0 0Assignment of customer:16 1 10 10 1 15 17 13 14 17 15 1 1 6 13 14 15 10 17 6 14 15 15 13 6 17 16 17 1 17 13 15 13 16 1 10 17 1 1 13 6 16 15 16 6 13 14 10 1 6Running Time : 2841msP22 result:Total cost: 7198Open status:1 1 0 0 0 0 0 0 0 1 1 0 0 1 1 1 0 1 0 1Assignment of customer:0 1 10 10 1 15 17 13 14 17 15 19 1 10 13 14 15 10 17 9 14 15 15 19 9 17 0 17 1 17 13 15 13 0 1 10 17 19 19 13 10 0 0 0 9 13 1410 19 9Running Time : 2838msP23 result:Total cost: 9182Open status:1 1 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 1Assignment of customer:0 1 10 10 1 15 17 2 10 17 15 19 1 10 2 1 15 10 17 9 15 15 15 19 9 17 0 17 1 17 2 15 2 0 1 10 17 19 19 2 10 0 0 0 9 15 15 10 199Running Time : 2781msP24 result:Total cost: 10924Open status:0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 1 1 1 0 1Assignment of customer:16 12 16 16 1 12 17 13 12 17 15 19 1 6 13 12 15 6 17 6 12 15 15 19 6 17 16 17 1 17 13 15 13 16 1 6 17 19 19 13 6 16 15 16 12 13 12 6 19 6Running Time : 2734msP25 result:Total cost: 13206Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 14 20 5 2 24 14 17 24 8 8 20 2 14 14 17 5 11 14 0 5 17 5 8 2 24 5 24 5 25 13 25 20 20 24 24 0 14 0 14 24 8 24 14 7 1311 8 5 14 14 5 13 20 17 11 11 14 0 5 20 11 11 11 24 0 24 24 20 20 11 0 24 8 24 20 14 24 20 7 13 17 2 17 17 7 20 5 2 24 17 11 75 2 14 25 13 8 17 17 25 2 25 7 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 7 5 20 17 0 8 20 148 25 25 5 2 5Running Time : 4027msP26 result:Total cost: 11866Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 0 0 1 1 0 0 1 0Assignment of customer:20 11 20 14 20 5 14 24 14 17 24 8 8 20 2 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 15 0 14 0 14 15 28 24 14 7 20 11 8 5 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 5 24 20 20 11 0 24 8 24 20 14 24 20 7 20 17 2 17 17 7 20 5 2 24 17 11 724 2 2 25 20 8 17 17 25 2 25 7 11 14 28 14 14 2 11 11 25 24 24 24 24 5 8 25 20 8 0 5 24 0 25 0 11 24 5 8 14 7 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 4019msP27 result:Total cost: 13590Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 14 20 5 14 24 14 17 24 8 8 20 2 14 14 0 5 11 14 0 5 17 5 8 2 24 5 24 5 25 13 25 20 20 24 24 0 14 0 14 24 8 24 14 0 1311 8 5 14 14 5 13 20 17 11 0 14 0 5 20 11 11 11 24 0 24 24 20 20 11 17 24 8 24 20 14 24 20 0 20 17 2 17 2 0 20 5 2 24 17 11 1724 2 2 25 20 8 17 14 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 0 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 4292msP28 result:Total cost: 16407Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 14 20 5 2 24 14 17 24 8 8 20 7 14 14 17 5 11 14 0 5 7 5 8 2 24 5 24 5 25 13 25 20 20 24 24 0 14 0 14 24 8 24 14 7 13 11 8 5 14 14 5 13 20 17 11 0 14 0 5 20 11 11 11 24 0 5 24 20 20 11 17 24 8 24 20 14 24 20 7 20 17 2 17 2 7 20 5 2 24 17 11 7 5 2 2 25 13 8 17 17 25 2 25 7 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 7 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 3969msP29 result:Total cost: 13708Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 1 1 0 0 1 0Assignment of customer:20 11 8 2 20 5 2 24 28 17 22 8 8 20 2 14 14 17 5 11 2 0 5 17 5 8 2 24 5 22 5 25 28 25 20 8 24 24 0 14 0 14 24 28 24 14 0 20 118 25 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 22 0 5 22 8 8 11 17 24 8 22 20 14 24 20 7 20 17 17 17 17 7 20 5 2 24 17 11 17 22 2 2 25 8 8 17 17 25 2 25 7 11 14 28 14 14 2 11 11 25 24 24 24 24 5 8 25 20 8 0 5 22 0 25 0 11 24 25 28 14 17 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 4027msP30 result:Total cost: 11916Open status:1 0 1 0 0 1 0 1 1 1 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 13 2 20 5 2 9 14 17 9 8 8 20 17 14 14 17 5 11 2 0 9 17 9 8 2 24 5 24 25 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 13 20 17 11 0 14 0 5 20 11 11 11 9 0 5 24 13 20 11 17 24 8 24 20 14 9 20 7 13 17 2 17 17 7 20 5 2 24 17 11 17 5 22 25 13 8 17 17 25 2 25 17 11 8 8 14 14 2 11 11 25 24 24 5 24 5 8 25 13 8 0 5 9 0 25 0 11 24 25 8 14 7 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 3918msP31 result:Total cost: 14051Open status:1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 13 2 20 5 2 9 8 17 9 8 8 20 2 14 14 17 5 11 2 0 5 17 9 8 2 24 5 9 5 25 13 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 25 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 9 0 24 9 13 20 11 17 24 8 24 20 14 24 20 0 13 17 17 17 17 0 20 5 2 24 17 11 17 5 22 25 13 8 17 17 25 2 25 0 11 14 8 14 14 2 11 11 25 24 9 5 24 5 8 25 13 8 0 5 24 0 25 0 11 24 25 8 14 17 5 20 17 0 8 20 14 8 2525 5 2 5Running Time : 4000msP32 result:Total cost: 16629Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 13 2 20 5 2 24 14 17 5 8 8 20 17 14 14 17 25 11 2 0 25 17 5 8 2 5 5 25 25 25 13 25 20 20 24 24 0 14 0 8 24 8 24 14 0 13 11 8 25 14 14 5 13 20 17 0 11 14 0 5 20 11 11 11 5 0 5 5 13 20 11 17 24 8 24 20 14 24 20 7 20 17 2 17 17 7 20 5 2 24 17 11 17 52 2 25 13 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 25 0 11 0 11 24 11 8 14 7 25 20 17 0 8 20 148 25 25 5 2 5Running Time : 3961msP33 result:Total cost: 12223Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 2 20 5 2 24 14 17 24 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 8 25 20 20 24 24 0 14 0 14 24 8 24 14 0 20 11 8 5 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 5 5 8 20 11 17 24 8 24 20 14 24 20 0 20 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 25 20 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 5 24 5 8 25 20 8 0 5 24 0 25 0 11 24 5 8 14 17 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 4111msP34 result:Total cost: 11582Open status:1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 2 20 5 2 24 14 17 9 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 13 20 17 11 11 14 0 5 20 11 11 11 24 0 9 24 20 20 11 17 24 8 9 20 14 24 20 0 20 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 25 13 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 9 0 25 0 11 24 5 8 14 17 5 20 17 0 8 20 148 25 25 5 2 5Running Time : 4399msP35 result:Total cost: 13485Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 13 2 20 5 2 24 14 17 5 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 5 5 20 20 11 17 24 8 24 20 14 24 20 0 13 17 17 17 17 0 20 5 2 24 17 11 17 5 2 2 25 20 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 17 5 20 17 0 8 20 148 25 25 5 2 5Running Time : 4617msP36 result:Total cost: 15744Open status:1 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 1Assignment of customer:20 11 20 2 20 5 2 24 14 17 5 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 11 8 11 20 20 24 24 0 14 0 14 24 8 24 14 7 20 118 29 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 5 5 8 20 11 17 24 8 24 20 14 24 20 7 20 17 17 17 17 7 20 5 2 24 17 11 17 24 2 2 29 20 8 17 17 11 2 29 17 11 14 8 14 14 2 11 11 29 24 24 24 24 5 8 11 20 8 0 5 24 0 29 0 11 24 5 8 14 7 5 20 17 0 8 20 14 8 11 11 5 2 5Running Time : 4101msP37 result:Total cost: 11829Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0Assignment of customer:20 11 20 2 20 5 2 24 14 17 24 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 11 20 11 20 20 24 24 0 14 0 14 24 8 24 14 0 20 11 8 5 14 14 5 20 20 17 11 0 14 0 5 20 11 11 11 24 0 24 24 20 20 11 17 24 8 24 20 14 24 20 0 20 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 11 20 8 17 17 11 2 5 17 11 14 8 14 14 2 11 11 11 24 24 24 24 5 8 11 20 8 0 5 24 0 5 0 11 24 5 8 14 17 5 20 17 0 8 20 14 8 11 11 5 2 5Running Time : 3978msP38 result:Total cost: 11282Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 13 2 20 5 2 24 14 17 24 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 5 24 20 20 11 17 24 8 24 20 14 24 20 0 13 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 25 13 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 17 5 20 17 0 8 2014 8 25 25 5 2 5Running Time : 3980msP39 result:Total cost: 13482Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 2 20 5 2 24 14 17 24 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 13 20 17 11 11 14 0 5 20 11 11 11 24 0 24 24 20 20 11 17 24 8 24 20 14 24 20 0 13 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 25 20 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 17 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 3968msP40 result:Total cost: 15682Open status:1 0 1 0 0 1 0 0 1 0 0 1 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0Assignment of customer:20 11 20 2 20 5 2 24 14 17 24 8 8 20 17 14 14 17 5 11 2 0 5 17 5 8 2 24 5 24 5 25 20 25 20 20 24 24 0 14 0 14 24 8 24 14 0 13 11 8 5 14 14 5 20 20 17 11 11 14 0 5 20 11 11 11 24 0 24 24 20 20 11 17 24 8 24 20 14 24 20 0 20 17 17 17 17 0 20 5 2 24 17 11 17 24 2 2 25 13 8 17 17 25 2 25 17 11 14 8 14 14 2 11 11 25 24 24 24 24 5 8 25 13 8 0 5 24 0 25 0 11 24 5 8 14 17 5 20 17 0 8 20 14 8 25 25 5 2 5Running Time : 3984msP41 result:Total cost: 7039Open status:1 1 1 1 1 1 1 1 0 1Assignment of customer:5 6 4 1 7 9 3 7 5 3 4 6 2 6 2 7 7 3 0 6 6 1 4 1 6 5 5 4 5 5 5 0 0 0 3 9 2 6 6 9 2 7 3 3 3 5 0 5 6 4 1 1 6 6 2 7 2 3 3 3 0 0 1 5 0 6 6 6 4 4 0 4 4 0 7 7 2 2 9 5 7 2 2 7 9 9 9 9 9 2Running Time : 2158msP42 result:Total cost: 6491Open status:0 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 1Assignment of customer:12 18 11 11 15 18 16 13 16 1 11 18 19 19 19 15 15 13 14 14 14 11 11 11 12 12 11 16 16 13 1 19 19 18 14 19 19 15 1 1 1 12 13 1611 14 18 19 15 15 16 1 1 13 13 11 12 14 14 14 11 11 11 11 11 13 16 15 19 15 18 18 19 19 19 18 18 18 19 19Running Time : 2886msP43 result:Total cost: 6447Open status:0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 0 0 1 0 0 1 1 1Assignment of customer:18 20 18 24 13 20 9 21 27 29 24 1 13 9 18 18 21 21 18 21 13 9 20 20 20 13 29 18 29 29 29 24 13 13 21 9 1 1 21 18 27 1 28 24 2413 9 20 9 18 21 9 9 18 18 18 21 20 13 29 29 27 1 29 27 28 1 27 28 29Running Time : 3579msP44 result:Total cost: 7236Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:4 4 4 4 4 4 4 4 6 6 0 0 0 0 0 0 1 1 1 7 1 7 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 0 1 1 8 8 7 5 9 7 7 6 5 5 8 8 7 7 9 5 5 5 3 3 0 6 6 8 1 0 4 9 9 7 7 8 6 6 5 2 7 9 9 9 9 9 6 5 7 5Running Time : 2345msP45 result:Total cost: 7267Open status:1 1 0 1 0 1 0 0 0 1 0 1 1 1 0 0 0 1 0 1Assignment of customer:0 0 0 0 0 0 0 1 1 13 1 1 13 1 1 3 3 3 3 3 3 11 11 11 11 11 11 12 11 5 5 5 5 5 5 5 5 5 0 0 3 3 11 12 13 17 19 3 19 19 13 13 11 19 13 19 5 1 9 9 12 9 0 17 13 13 11 12 9 9 19 12 13 17 17 17 17 17 9 13Running Time : 3468msP46 result:Total cost: 7304Open status:1 1 0 0 0 0 1 0 1 1 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1Assignment of customer:0 0 0 0 0 0 0 1 15 1 15 1 1 1 1 21 21 14 21 12 21 6 6 6 6 6 6 8 8 8 9 8 9 9 0 21 21 17 24 28 29 12 15 28 24 14 14 17 29 28 29 17 8 1 24 14 29 28 12 24 12 15 28 28 14 14 14 14 15 12Running Time : 3918msP47 result:Total cost: 6405Open status:1 1 1 1 1 1 1 1 1 1Assignment of customer:0 0 0 0 0 0 2 0 2 0 1 2 1 1 2 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 7 7 6 7 6 0 7 7 7 7 7 8 8 8 6 6 8 8 8 8 9 9 9 2 9 0 9 0Running Time : 2068msP48 result:Total cost: 5964Open status:0 0 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 1Assignment of customer:19 19 19 17 3 5 3 5 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 9 9 9 11 9 9 9 9 9 9 9 11 11 11 11 11 11 13 13 13 13 13 13 13 14 14 13 14 13 17 14 14 14 14 17 17 17 17 17 17 17 17 19 19 19 19 19 19 19Running Time : 3067msP49 result:Total cost: 6025Open status:1 0 1 0 0 1 0 1 0 0 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 0Assignment of customer:0 0 0 2 2 2 2 2 5 5 5 5 5 7 7 7 7 7 7 7 7 7 7 7 7 7 7 13 13 13 13 13 13 13 13 13 16 16 16 16 16 16 20 20 20 20 20 20 21 20 21 20 0 23 23 23 23 26 26 26 26 26 26 26 26 26 26 0 0 0Running Time : 3843msP50 result:Total cost: 9477Open status:1 1 1 1 1 1 1 1 0 1Assignment of customer:3 6 3 6 2 9 5 5 3 7 7 4 6 1 9 9 9 5 5 3 0 0 0 4 0 6 7 4 4 7 7 7 3 3 3 5 9 2 0 6 0 9 9 9 5 5 5 5 5 3 3 5 6 0 0 0 9 6 1 2 2 7 7 7 3 3 0 4 7 7 3 6 6 0 0 4 4 3 3 4 3 5 2 2 2 2 6 7 2 7 9 9 2 1 1 1 9 9 1 9Running Time : 2625msP51 result:Total cost: 8618Open status:1 0 1 0 0 1 1 0 0 0 1 0 0 1 1 1 0 0 1 1Assignment of customer:15 6 19 10 13 13 5 5 15 5 5 14 6 13 6 13 13 5 2 15 0 0 10 14 14 14 15 19 19 15 2 15 19 19 15 5 13 13 10 0 0 13 13 13 5 5 5 5 515 15 5 0 14 14 10 6 6 18 13 13 5 5 5 15 15 10 19 15 15 15 0 0 0 10 19 19 19 19 19 19 5 5 13 13 13 6 2 18 5 13 13 18 18 18 18 18 18 13 13Running Time : 3205msP52 result:Total cost: 9288Open status:0 0 0 1 1 1 1 1 1 1Assignment of customer:7 7 7 7 7 7 7 7 3 4 4 4 4 4 4 4 4 8 3 8 3 3 3 8 8 9 9 9 9 9 9 9 9 5 6 6 6 6 6 6 6 6 6 6 7 7 4 8 8 5 5 3 4 6 7 5 3 3 3 4 6 5 5 8 8 3 5 7 4 7 6 6 4 3 3 5 3 4 7 6 6 3 3 5 5 3 3 7 5 4 5 5 6 5 5 6 3 4 3 7Running Time : 2279msP53 result:Total cost: 9808Open status:0 1 1 1 0 1 1 1 0 1 0 0 1 1 0 1 0 0 1 0Assignment of customer:5 5 5 5 5 5 5 5 1 7 7 7 7 7 7 7 7 12 12 13 12 13 13 13 12 9 9 9 9 9 15 9 15 9 18 18 18 18 18 18 18 18 18 18 5 5 7 12 13 15 15 3 7 18 5 15 3 3 1 6 18 2 15 13 3 13 2 18 6 5 18 18 6 3 3 15 3 6 6 2 18 1 13 15 15 3 1 6 15 1 15 2 2 2 2 18 1 6 1 5Running Time : 3257msP54 result:Total cost: 9369Open status:1 0 1 1 1 1 1 1 1 1Assignment of customer:9 7 7 7 7 7 7 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 6 6 6 8 6 8 8 8 8 8 8 8 3 6 6 6 6 6 6 6 6 6 5 5 6 5 5 5 6 6 0 0 0 0 5 7 0 0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 9 9 9 9 4 9 9Running Time : 2197msP55 result:Total cost: 8433Open status:1 0 1 0 0 0 1 1 1 1 0 0 0 1 1 1 0 0 1 0Assignment of customer:18 18 18 18 18 18 18 2 8 8 8 8 2 8 2 8 2 2 8 6 6 6 2 6 6 6 6 6 6 6 6 14 14 6 6 6 6 6 6 7 7 7 0 7 0 0 0 0 0 0 0 0 7 7 7 7 7 7 77 7 9 13 7 9 7 9 7 7 9 13 9 9 13 18 13 9 13 9 9 13 15 15 15 15 15 15 15 15 15 15 18 18 18 18 18 18 18 18 18Running Time : 3142msP56 result:Total cost: 23214Open status:1 0 1 0 1 1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 13 28 18 13 20 27 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 9 24 16 18 9 6 4 20 1913 21 19 14 24 16 24 16 20 6 11 9 18 25 29 0 7 20 13 11 5 14 28 25 18 12 19 9 23 23 20 23 20 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 13 11 6 0 28 28 21 25 18 4 0 4 24 27 13 19 4 27 12 12 20 28 7 17 20 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 13 1328 10 12 27 11 11 25 5 24 21 27 25 24 17 23 0 20 11 2 16 13 13 13 27 10 24 5 27 5 4 13 21 5 20 19 14 26 2 0 10 29 10 5 21 2 1912 9 28 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4176msP57 result:Total cost: 29596Open status:1 0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 13 28 18 13 20 27 0 18 16 5 24 10 18 27 19 4 2 19 19 4 16 27 6 20 9 24 16 18 9 6 4 20 19 13 21 19 20 24 16 24 16 20 6 11 9 18 7 4 0 7 20 13 11 5 17 28 25 18 12 19 9 23 23 20 23 20 16 10 0 9 25 4 13 6 5 27 7 28 6 25 25 2 13 11 6 0 28 28 21 25 18 4 0 4 24 27 13 19 4 27 12 12 20 28 7 17 20 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 13 13 28 10 12 27 11 11 25 5 24 21 27 25 24 17 23 0 20 11 2 16 13 13 13 27 10 24 5 27 5 4 13 21 5 20 19 10 26 2 0 10 4 10 5 21 2 19 12 928 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4117msP58 result:Total cost: 44716Open status:1 0 1 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 0 1 1 1Assignment of customer:18 19 2 27 2 12 15 27 22 28 29 28 13 13 28 18 3 20 22 0 18 16 5 24 20 18 27 19 29 2 19 19 19 16 27 6 20 8 24 16 18 8 6 29 8 1913 2 19 14 24 16 24 16 8 6 11 8 18 7 29 0 7 8 13 11 5 14 28 12 18 12 6 8 5 13 20 5 8 16 13 0 8 7 29 13 6 5 27 7 28 6 7 11 2 3 11 6 0 28 28 15 12 18 29 0 29 24 22 3 19 29 27 12 12 8 28 7 17 8 14 11 17 19 19 16 2 11 19 17 28 24 11 20 5 8 3 3 28 14 12 22 11 11 11 5 24 15 27 11 24 17 5 0 8 11 2 15 3 13 13 27 20 24 5 27 5 29 3 15 5 20 19 14 29 2 0 20 29 20 5 15 2 19 12 8 28 13 0 2 22 6 29 7 12 7 15 20 19Running Time : 4082msP59 result:Total cost: 34414Open status:1 0 1 1 1 1 1 1 0 1 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1Assignment of customer:7 19 21 27 2 6 21 27 22 28 4 28 13 13 28 7 3 20 22 0 27 16 5 24 10 27 27 19 29 2 19 19 4 16 27 6 20 9 24 16 7 9 6 4 20 19 13 21 19 14 24 16 24 16 20 6 11 9 22 25 29 0 7 20 13 11 5 14 28 25 7 6 19 9 23 23 20 23 20 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 23 11 6 0 28 28 21 25 7 4 0 4 24 22 3 19 4 27 6 11 20 28 7 17 20 9 11 17 19 9 16 2 11 19 17 28 24 25 20 23 9 3 3 28 10 11 22 1111 25 5 24 21 27 25 24 17 23 0 20 11 2 16 3 13 13 27 10 24 5 27 5 4 3 21 5 20 19 14 4 2 0 10 29 10 5 21 2 19 11 9 28 23 0 21 221 6 4 7 6 7 21 10 19Running Time : 4329msP60 result:Total cost: 23068Open status:1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1Assignment of customer:18 6 21 27 2 12 21 27 22 28 4 28 13 13 28 18 3 20 22 0 18 16 5 24 10 18 27 14 29 2 6 26 4 16 27 6 20 8 24 16 18 8 6 4 8 26 13 21 14 14 24 16 24 16 8 6 11 8 18 25 29 0 25 8 13 11 5 14 28 25 18 12 6 8 23 23 20 23 8 16 10 0 26 25 29 13 6 5 27 25 28 6 25 252 3 11 6 0 28 28 21 25 18 4 0 4 24 22 3 14 4 27 12 12 8 28 25 17 8 26 11 17 6 26 16 2 11 26 17 28 24 25 20 23 8 3 3 28 10 12 22 11 11 25 5 24 21 27 25 24 17 23 0 8 11 2 16 3 13 13 27 10 24 5 27 5 4 3 21 5 20 28 14 26 2 0 10 29 10 5 21 2 6 12 8 28 23 0 21 2 21 6 4 25 12 25 21 10 6Running Time : 4813msP61 result:Total cost: 29054Open status:1 0 1 0 1 1 1 0 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 0Assignment of customer:18 19 21 27 2 12 15 27 22 28 4 28 13 13 28 18 13 20 22 0 18 21 5 24 10 18 27 19 4 2 19 19 4 21 27 6 20 9 24 15 18 9 6 4 20 19 13 21 19 20 24 24 24 21 20 6 11 9 18 25 4 0 18 20 13 11 5 17 28 25 18 12 19 9 23 23 20 23 20 24 10 0 9 25 4 13 6 5 27 25 28 6 25 25 2 13 11 6 0 28 28 15 25 18 4 0 4 24 22 13 19 4 27 12 12 20 28 25 17 20 9 11 17 19 9 21 2 11 19 17 28 24 25 20 23 9 13 13 28 10 12 22 11 11 25 5 24 15 27 25 24 17 23 0 20 11 2 15 13 13 13 27 10 24 5 27 5 4 13 21 5 20 19 10 4 2 0 10 4 10 5 21 2 19 12 9 28 23 0 21 2 21 6 4 25 12 25 15 10 19Running Time : 4811msP62 result:Total cost: 43321Open status:1 0 1 0 1 1 1 1 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 1 1 1 0 1 1 0Assignment of customer:7 19 21 27 2 12 21 27 27 28 4 28 13 13 28 7 13 20 27 0 27 16 5 24 10 27 27 19 4 2 19 19 4 16 27 6 20 8 24 16 7 8 6 4 8 19 13 21 19 14 24 16 24 16 8 6 25 8 27 7 4 0 7 8 13 25 5 14 28 25 7 12 19 8 23 23 20 23 8 16 10 0 8 25 4 13 6 5 27 7 28 6 25 25 2 13 28 6 0 28 28 21 25 7 4 0 4 24 27 13 19 4 27 12 12 8 28 7 17 8 14 25 17 19 4 16 2 12 19 17 28 24 25 20 23 8 13 13 28 10 12 27 12 25 25 5 24 21 27 25 24 17 23 0 8 28 2 16 13 13 13 27 10 24 5 27 5 4 13 21 5 20 19 14 4 2 0 10 4 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4734msP63 result:Total cost: 33279Open status:1 0 1 0 1 0 1 1 1 1 1 1 1 1 0 1 0 1 0 1 1 1 1 1 1 1 0 1 1 0Assignment of customer:7 19 21 27 2 12 15 27 22 28 4 28 13 13 28 7 13 20 22 0 27 21 23 24 10 27 27 19 4 2 19 19 4 21 27 6 20 8 24 15 7 9 6 4 8 19 13 21 19 20 24 24 24 21 8 6 11 9 22 25 4 0 7 8 13 11 23 17 28 25 7 12 19 9 23 23 20 23 8 24 10 0 9 25 4 13 6 2 27 7 28 6 25 25 2 13 11 6 0 28 28 15 25 7 4 0 4 24 22 13 19 4 27 12 12 8 28 7 17 8 9 11 17 19 9 21 2 11 19 17 28 24 25 20 23 9 13 13 28 10 12 22 11 11 25 2 24 15 27 25 24 17 23 0 8 11 2 15 13 13 13 27 10 24 23 27 23 4 13 21 23 20 19 10 4 2 0 10 4 10 2 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 4607msP64 result:Total cost: 22985Open status:1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 1 1 0 1 1 1Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 13 28 18 3 20 27 0 18 16 5 24 10 18 27 19 29 2 19 19 4 16 27 6 20 9 24 16 18 9 6 4 20 19 13 21 19 14 24 16 24 16 20 6 11 9 18 25 29 0 7 20 13 11 5 14 28 25 18 12 19 9 23 23 20 23 20 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 21 25 18 4 0 4 24 27 3 19 4 27 12 12 20 28 7 17 20 9 11 17 19 9 16 2 11 19 17 28 24 25 20 23 9 3 3 28 10 12 27 11 11 25 5 24 21 27 25 24 17 23 0 20 11 2 16 3 13 13 27 10 24 5 27 5 4 3 21 5 20 19 14 4 2 0 10 29 10 5 21 2 19 12 9 28 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4461msP65 result:Total cost: 28849Open status:1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1 0 1 1 1 1 1 0 1 1 0Assignment of customer:7 19 21 27 2 12 21 27 22 28 4 28 13 13 28 7 13 10 22 0 27 21 5 24 10 27 27 19 4 2 19 19 4 21 27 6 8 8 24 21 7 9 6 4 8 19 13 2119 14 24 24 24 21 8 6 11 9 22 7 4 0 7 8 13 11 5 14 28 25 7 12 19 9 23 23 10 23 8 24 10 0 9 25 4 13 6 5 27 7 28 6 25 25 2 13 116 0 28 28 21 25 7 4 0 4 24 22 13 19 4 27 12 12 8 28 7 17 8 9 11 17 19 9 21 2 11 19 17 28 24 25 10 23 9 13 13 28 10 12 22 11 1125 5 24 21 27 25 24 17 23 0 8 11 2 21 13 13 13 27 10 24 5 27 5 4 13 21 5 8 19 14 4 2 0 10 4 10 5 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4849msP66 result:Total cost: 42181Open status:1 0 1 0 1 0 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0 1 1 1 0 1 1 0Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 13 28 18 13 20 27 0 18 16 23 24 10 18 27 19 4 2 19 19 4 16 27 6 20 9 24 16 18 9 6 4 20 1913 21 19 20 24 16 24 16 20 6 11 9 18 25 4 0 25 20 13 11 23 17 28 25 18 12 19 9 23 23 20 23 20 16 10 0 9 25 4 13 6 2 27 25 28 625 25 2 13 11 6 0 28 28 21 25 18 4 0 4 24 27 13 19 4 27 12 12 20 28 25 17 20 9 11 17 19 9 16 2 11 19 17 28 24 25 20 23 9 13 1328 10 12 27 11 11 25 2 24 21 27 25 24 17 23 0 20 11 2 16 13 13 13 27 10 24 23 27 23 4 13 21 23 20 19 10 4 2 0 10 4 10 2 21 2 19 12 9 28 23 0 21 2 21 6 4 25 12 25 21 10 19Running Time : 5078msP67 result:Total cost: 33005Open status:1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0 1 1 0Assignment of customer:18 19 21 27 2 12 15 27 27 28 4 28 13 13 28 18 13 20 27 0 18 16 23 24 10 18 27 19 4 2 19 19 4 16 27 6 20 8 24 15 18 8 6 4 8 19 13 21 19 14 24 16 24 16 8 6 11 8 18 7 4 0 7 8 13 11 23 14 28 12 18 12 19 20 23 23 20 23 8 16 10 0 8 7 4 13 19 2 27 7 28 6 11 112 13 27 6 0 28 28 15 12 18 4 0 4 24 27 13 19 4 27 12 12 8 28 7 17 8 14 11 17 19 4 16 2 11 19 17 28 24 11 20 23 8 13 13 28 10 12 18 11 11 7 2 24 15 27 11 24 17 23 0 8 11 2 15 13 13 13 27 10 24 23 27 23 4 13 21 23 20 19 14 4 2 0 10 4 10 2 21 2 19 12 8 28 23 0 21 2 21 6 4 7 12 7 15 10 19Running Time : 4884msP68 result:Total cost: 22745Open status:1 0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 13 28 18 3 20 27 0 18 16 5 24 10 18 27 19 4 2 19 19 4 16 27 6 20 9 24 16 18 9 6 4 20 19 13 21 19 20 24 16 24 16 20 6 11 9 18 7 4 0 7 20 13 11 5 17 28 25 18 12 19 9 23 23 20 23 20 16 10 0 9 25 4 13 6 5 27 7 28 6 25 252 3 11 6 0 28 28 21 25 18 4 0 4 24 27 3 19 4 27 12 12 20 28 7 17 20 26 11 17 19 26 16 2 11 26 17 28 24 25 20 23 9 3 3 28 10 1227 11 11 25 5 24 21 27 25 24 17 23 0 20 11 2 16 3 13 13 27 10 24 5 27 5 4 3 21 5 20 19 10 26 2 0 10 4 10 5 21 2 19 12 9 28 23 0 21 2 21 6 4 7 12 7 21 10 19Running Time : 4589msP69 result:Total cost: 29586Open status:0 1 1 0 1 1 1 0 1 1 0 0 1 1 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1Assignment of customer:18 19 21 27 2 12 21 27 18 28 4 28 13 1 28 18 1 20 27 27 18 16 5 24 23 18 27 19 29 2 19 19 4 16 27 6 20 8 24 16 18 9 6 4 8 19 13 21 19 14 24 16 24 16 8 6 25 9 18 25 29 2 25 8 13 25 5 14 28 25 18 12 19 9 23 23 20 23 8 16 23 17 9 25 29 13 6 5 27 25 28 6 2525 2 13 28 6 17 28 28 21 25 18 4 24 4 24 27 13 19 4 27 12 12 8 28 25 17 8 26 25 17 19 26 16 2 12 26 17 28 24 25 20 23 9 1 13 28 14 12 27 12 25 25 5 24 21 27 25 24 17 23 17 8 28 2 16 13 13 13 27 23 24 5 27 5 4 1 21 1 20 19 14 26 2 24 20 29 20 5 21 2 19 12 8 28 23 17 21 2 21 6 4 25 12 18 21 23 19Running Time : 5185msP70 result:Total cost: 42645Open status:1 0 1 0 1 1 0 1 1 0 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0Assignment of customer:18 19 21 27 2 11 21 27 22 17 4 17 13 13 19 18 13 20 22 0 18 21 5 24 10 18 27 19 4 2 19 19 4 21 27 19 20 8 24 21 18 8 19 4 8 1913 21 19 20 24 24 24 21 8 19 11 8 18 25 4 0 7 8 13 11 5 17 19 25 18 11 19 8 23 23 20 23 8 24 10 0 26 25 4 13 19 5 27 7 17 19 25 25 2 13 11 11 0 17 17 21 25 18 4 0 4 24 22 13 19 4 27 11 11 8 11 7 17 8 26 11 17 19 26 21 2 11 26 17 11 24 25 20 23 8 13 13 17 10 11 22 11 11 25 5 24 21 27 25 24 17 23 0 8 11 2 21 13 13 13 27 10 24 5 27 5 4 13 21 5 20 19 10 26 2 0 10 4 10 5 21 2 19 11 8 11 23 0 21 2 21 19 4 7 11 7 21 10 19Running Time : 4846msP71 result:Total cost: 33021Open status:1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 0 1 0 1 0 1 0 0 1 1 1 0 1 1 1Assignment of customer:18 6 2 27 2 12 2 27 18 28 4 28 13 13 28 18 3 20 27 0 18 16 5 24 10 18 27 14 29 2 6 4 4 16 27 6 20 9 24 16 18 9 6 4 20 4 13 2 14 14 24 16 24 16 20 6 11 9 18 7 29 0 7 20 13 11 5 14 28 25 18 12 6 9 23 23 20 23 20 16 10 0 9 25 29 13 6 5 27 7 28 6 25 25 2 3 11 6 0 28 28 16 25 18 4 0 4 24 27 3 14 4 27 12 12 20 28 7 14 20 9 11 28 6 9 16 2 11 4 0 28 24 25 20 23 9 3 3 28 10 12 27 11 11 25 5 24 16 27 25 24 0 23 0 20 11 2 16 3 13 13 27 10 24 5 27 5 4 3 2 5 20 28 14 4 2 0 10 29 10 5 16 2 6 12 9 28 23 0 24 2 2 6 4 7 12 7 2 10 6Running Time : 4519ms 总结可以从运行结果来比较这两种算法的效果： 贪心算法由于搜索次数比较少，因此耗时很少 SA算法是启发式搜索，温度和每轮迭代次数都会影响它的速度和效果，我设计的SA算法耗时比贪心多了很多 这两种算法在前面比较简单的情况下结果相差不大，但在后面复杂的情况下，SA会不断寻找更优的解，并适时跳出局部最优解，因此SA算法得到的结果会好很多 通过比较设施的打开状态，我们可以发现，对于复杂的情况，贪心基本把所有设施都打开了，而SA则不会，节省了大量opencost，而输入数据实例告诉了我们opencost是很昂贵的(1500一次)，因此SA确实找到了更好的解，它考虑了打开设施的花费]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-128]]></title>
    <url>%2F2018%2F12%2F09%2Fleetcode-128%2F</url>
    <content type="text"><![CDATA[最近在复习贪心算法，复习到了并查集这个数据结构，因此写一道用并查集来解决的算法题。 题目Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 1234&gt; Input: [100, 4, 200, 1, 3, 2]&gt; Output: 4&gt; Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.&gt; 分析这道题让我们求出一个无序数组中最长的连续序列的长度，难度在于时间复杂度要求在O(n)内，用并查集可以达到这个要求。 首先来复习一下并查集这个数据结构。 并查集并查集是一种树型数据结构，用于处理一些不相交集合的合并及查询问题，用它来判断元素所在集合所用时间接近常数级，Kruskal最小生成树算法就用到了并查集来实现。 假设有一个动态集合S={s1，s2，s3，…..sn}，每个子集合通过一个代表来标识，代表就是这个子集合中的一个元素，即根元素。要判断两个元素是否属于同一个子集合，判断它们的根元素是否是同一个代表即可。 随着union操作，子集合的个数会越来越少，因此称之为动态集合。 并查集主要涉及3种基本操作： makeset：初始化，每个元素作为一个子集合，它的父节点是本身，集合树高度为1 find(x)：找出某个元素x的根元素，所需时间与树的高度成正比。在优化的并查集中，经常在find(x)过程中把根节点更新为x的父节点，这样可以降低树的高度，在总体上提高find和union的效率，这个优化被称为路径压缩 union(x，y)：合并包含x和y的集合，一般是让较低的树的根指向较高的树的根。只有当两棵树高度相同时，合并后总高度才增加。 解法在本题中，连续的序列可以视为一个集合，集合中的元素值是连续的，而我们要做的事情就是找到最大的集合大小。 使用并查集，我们可以在O(n)时间内完成任务，因为经过优化后的find操作耗时接近常数级。 本题，我们可以遍历一次数组，假设当前遍历到的元素值为x，查询x+1和x-1是否在数组中，如果在，就合并它们所在的子集合，最终找出最大子集合的大小。 通过使用hash map，我们可以解决三个问题： 把在数组中操作的问题转成在并查集中操作，键值对作为数组元素与并查集元素之间的联系 并查集中不能有两个重复的元素，否则结果会偏大 查询x+1和x-1是否在数组中的操作耗时O(1) 另外需要注意，在这个问题的并查集中使用级别来合并子集合并不适用，要换成根节点所具有的孩子数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using std::cout;using std::vector;using std::unordered_map;class UnionFindSet &#123;private: int size; vector&lt;int&gt; parent; //child表示根节点的孩子数 vector&lt;int&gt; child;public: UnionFindSet(int size) &#123; this-&gt;size = size; parent = vector&lt;int&gt;(size); child = vector&lt;int&gt;(size); &#125; void makeSet() &#123; for (int i = 0; i &lt; size; ++i) &#123; parent[i] = i; child[i] = 1; &#125; &#125; int find(int x) &#123; //查找过程中使用路径压缩 if (x != parent[x]) parent[x] = find(parent[x]); return parent[x]; &#125; void Union(int x, int y) &#123; int parent_x = find(x); int parent_y = find(y); if (parent_x == parent_y) return; if (child[parent_x] &gt; child[parent_y]) &#123; parent[parent_y] = parent_x; child[parent_x] += child[parent_y]; &#125; else &#123; parent[parent_x] = parent_y; child[parent_y] += child[parent_x]; &#125; &#125; int max_child() &#123; int max = 1; for (auto i : child) &#123; if (max &lt; i) max = i; &#125; return max; &#125;&#125;;class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; //利用hashmap来记录元素是否存在 //键为元素值，值为元素在并查集中的位置 unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; nums.size(); ++i) &#123; map.insert(std::make_pair(nums[i], i)); &#125; UnionFindSet set(nums.size()); set.makeSet(); for (auto it = map.begin(); it != map.end(); ++it) &#123; auto smaller = map.find(it-&gt;first - 1); auto bigger = map.find(it-&gt;first + 1); //比元素小1的元素存在 if (smaller != map.end()) &#123; set.Union(it-&gt;second, map[it-&gt;first - 1]); &#125; //比元素小1的元素存在 if (bigger != map.end()) &#123; set.Union(it-&gt;second, map[it-&gt;first + 1]); &#125; &#125; return set.max_child(); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法实现]]></title>
    <url>%2F2018%2F12%2F07%2FMD5%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文阐述DES算法的基本原理及其C++实现方法，并给出源代码 算法原理概述MD5即Message-Digest Algorithm 5 (信息-摘要算法 5) ，是一种被广泛使用的密码散列(hash)函数，它使用小端模式，输入任意不定长的消息，产生的是128位(16个字节)的散列值(hash value)，用于确保信息传输的完整性和一致性。 MD5算法不是足够安全的，可以找到两个不同的512位的块，它们通过的MD5的hash值相同 但对于有意义的消息，还没有两个不同的消息，它们的MD5的hash值相同 总体结构MD5算法的基本流程如下图所示： 可以分成几个流程： 填充 分块 循环压缩 得出结果 使用unsigned char作为byte，unsigned int作为bit32 模块分解填充算法的输入我使用字符串，而一个字符占一个字节(8位)，而填充后的消息位数是512位(64字节)的倍数，因此可以按字节来填充，填充需要注意的是最后8个字节要使用原始消息长度的低8个字节来填充，其余需要填充的部分，第一个字节使用0x80，其余的字节都使用0x00。 计算填充字节数的方法如下： 1234//count表示要填充的字节数int count = length % 64;if (count &lt; 56) count = 64 - 8 - count;else count = 128 - 8 - count; 中间填充0x80，0x00就不必赘述，需要注意填充原始消息长度的低8个字节这个操作，要按照小端存储来把长度转为8个连续的字节，可以采用移位运算&gt;&gt;来帮助实现。 填充完成后，消息长度为64k字节，为了方便之后的步骤，还需要把消息分块。 分块分块操作主要是为了把填充好的消息分割成每64字节一组，也可以表示成一组16个32位的字(bit32)。 我使用vector&lt;bit32&gt;来存储每个分组里面的32位字，再用一个vector来存放所有的分组，因此最终分块后的消息存放在vector&lt;vector&lt;bit32&gt; &gt;中(vector&lt;bit32&gt;长度固定为16) 需要注意，填充后的消息中按byte存储，因此需要把连续的4个byte转成bit32，这里又需要按照小端存储的模式，比如4个byte值分别为0x01,0x02,0x03,0x04，转成bit32的值为0x04030201。可以借助左移位运算符&lt;&lt;来实现。 循环压缩这一部分包含了MD5算法进行加密的主要操作，主要流程是以512位的分组为单位，每一分组经过4轮循环，每轮循环16次迭代，输出128位的结果，存放在缓冲区中，作为下一轮循环缓冲区的输入。 4轮循环的逻辑如图所示： 从缓冲区输入128位，从消息分组输入512位，输出结果128位，要注意结果是由循环的结果加上缓冲区的值得到的(加法为模232加法)。 每轮循环中迭代的逻辑如图所示： 其中： a，b，c，d是缓冲区的当前值 g是4个轮函数之一，输入输出都是bit32，进行不同的逻辑运算 &lt;&lt;&lt;s是指把bit32循环左移s位，s可查表得到 X[k]是当前处理消息分组的第k个bit32，在每一轮循环中都由不同的公式计算出来 T[i]通过查表得到，32bit字 所有的加法都是模232加法 需要注意，在迭代过程中缓冲区的值会发生变化，因此要提前存储下循环开始时缓冲区的值，用于之后与循环结果相加。 4个轮函数逻辑如图所示： 每轮循环中X[k]所取的k的计算方法为： 取j为当前迭代轮次 第一轮循环：k = j 第二轮循环：k = (1 + 5 * j) % 16 第三轮循环：k = (5 + 3 * j) % 16 第四轮循环：k = (7 * j) % 16 得出结果经过前面的操作，我们已经得到了4个bit32的结果，但最直白的输出最好是字符串，许多在线工具也是把计算结果转成了32位长度的16进制字符串，便于使用。 要得到16进制字符串类型的结果，首先需要把这4个bit32转成16个byte，再把每一个byte用两位16进制字符来表示。 把bit32转成byte的过程又一次需要用到小端存储模式： 1234567for (int i = 0; i &lt; 4; ++i) &#123; //利用了小端编码 MD5[i * 4 + 0] = CV[i] &amp; 0xff; MD5[i * 4 + 1] = (CV[i] &gt;&gt; 8) &amp; 0xff; MD5[i * 4 + 2] = (CV[i] &gt;&gt; 16) &amp; 0xff; MD5[i * 4 + 3] = (CV[i] &gt;&gt; 24) &amp; 0xff;&#125; 之后输出每一个byte，分别计算出它除以16的商和余数即可： 123456789101112char HEX[16] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;;for (int i = 0; i &lt; 16; ++i) &#123; byte quotient = MD5[i] / 16; byte remainder = MD5[i] % 16; str.append(1, HEX[quotient]); str.append(1, HEX[remainder]);&#125; 最终得到的是一个长度为32的16进制字符串。 数据结构首先最重要的是表示方法，由于C++里char占8位，int占32位，因此分别使用unsigned char和unsigned int来表示byte和bit32是很合适的。 此外，要存放消息，使用vector这个数据结构十分方便，对每一个分块使用vector&lt;bit32&gt;来存放16个bit32，所有的分块存放在一个vector中方便检查填充和分块是否出错。 此外，用到了MD5算法固定使用的一些表： 12345678910111213141516171819202122//T表,共64个元素，每个元素为32位字，也称为加法常数bit32 T[64] = &#123; 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391&#125;;//s表，各次迭代运算采用的左循环移位的s值byte s[64] = &#123; 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21&#125;; 源代码在此贴出MD5算法主要部分的源码，完整源码见github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include "MD5.hpp"#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;using std::vector;using std::string;//存放填充完成后的原始消息//每个分组512位，即16个32位的字vector&lt;vector&lt;bit32&gt; &gt; groups;//128位的MD5缓冲区//表示为4个32位寄存器bit32 CV[4] = &#123;0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476&#125;;//缓冲区初始向量IVbit32 IV[4] = &#123;0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476&#125;;//加密结果，长度为16的字符串byte MD5[16];//填充函数//输入为字符串类型的原始消息和消息长度void padding(byte* input, int length) &#123; //由于输入的每一个字符占一个字节(8位) //因此按字节填充，而不是按位填充 //每一组64字节，最后一组的8个字节另外填 //count表示要填充的字节数 int count = length % 64; if (count &lt; 56) count = 64 - 8 - count; else count = 128 - 8 - count; //填充操作 byte* paddingInput = new byte[length + count + 8]; memcpy(paddingInput, input, length); paddingInput[length] = 0x80; for (int i = length + 1; i &lt; length + count - 8; ++i) &#123; paddingInput[i] = 0x00; &#125; //再向填充好的消息尾部附加消息长度的低8个字节 //int转byte要注意小端存储 for (int i = 0; i &lt; 8; ++i) &#123; //用((length * 8) &gt;&gt; (i * 8)) &amp; 0xff出现了奇怪的结果 //改用除法 paddingInput[length + count + i] = ((byte)((length * 8) / pow(2, (i * 8)))) &amp; 0xff; &#125; /* std::cout &lt;&lt; count + 8 &lt;&lt; std::endl; for (int i = 0; i &lt; length + count + 8; ++i) std::cout &lt;&lt; (int)paddingInput[i] &lt;&lt; " "; std::cout &lt;&lt; std::endl; */ vector&lt;bit32&gt; group; group.reserve(16); for (int i = 0, flag = 0; i &lt; length + count + 8; i += 4) &#123; bit32 word = 0; //4个byte转成一个int，采用小端存储 //如0x01,0x02,0x03,0x04 //int为0x04030201 for (int j = 0; j &lt; 4; ++j) &#123; word |= (paddingInput[i + j] &lt;&lt; (j * 8)); &#125; group.push_back(word); flag++; if (flag == 16) &#123; groups.push_back(group); flag = 0; group.clear(); &#125; &#125; &#125;//压缩函数//对每一个512位(16个32位字)的分组进行压缩//上一轮压缩的128位结果作为下一轮的CV输入//最终的结果存放在缓冲区中void HMD5() &#123; for (int i = 0; i &lt; groups.size(); ++i) &#123; bit32 A = CV[0]; bit32 B = CV[1]; bit32 C = CV[2]; bit32 D = CV[3]; //作4轮循环，每一轮作16次迭代 for (int j = 0; j &lt; 4; ++j) &#123; for (int q = 0; q &lt; 16; ++q) &#123; bit32 a = A, b = B, c = C, d = D; bit32 g; int k; switch (j) &#123; case 0: g = F(b, c, d); k = q; break; case 1: g = G(b, c, d); k = (1 + 5 * q) % 16; break; case 2: g = H(b, c, d); k = (5 + 3 * q) % 16; break; case 3: g = I(b, c, d); k = (7 * q) % 16; break; &#125; bit32 tmp = a + g + groups[i][k] + T[j * 16 + q]; a = b + shiftLeft(tmp, s[j * 16 + q]); //缓冲区作循环轮换 //(B, C, D, A) &lt;- (A, B, C, D) A = d; B = a; C = b; D = c; &#125; &#125; CV[0] += A; CV[1] += B; CV[2] += C; CV[3] += D; &#125;&#125;//把128位(4个32位字)的结果转成16个字节的输出void getBytes() &#123; for (int i = 0; i &lt; 4; ++i) &#123; //利用了小端编码 MD5[i * 4 + 0] = CV[i] &amp; 0xff; MD5[i * 4 + 1] = (CV[i] &gt;&gt; 8) &amp; 0xff; MD5[i * 4 + 2] = (CV[i] &gt;&gt; 16) &amp; 0xff; MD5[i * 4 + 3] = (CV[i] &gt;&gt; 24) &amp; 0xff; &#125;&#125;int main() &#123; string test; getline(std::cin, test); padding((byte*)test.c_str(), test.length()); HMD5(); getBytes(); // 输出十六进制字符串 string str = ""; char HEX[16] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; for (int i = 0; i &lt; 16; ++i) &#123; byte quotient = MD5[i] / 16; byte remainder = MD5[i] % 16; str.append(1, HEX[quotient]); str.append(1, HEX[remainder]); &#125; std::cout &lt;&lt; str &lt;&lt; std::endl;&#125; 编译运行结果首先来测试一个简单的字符串的MD5散列值： 1234$ g++ MD5.cpp -o MD5$ ./MD5hello,world!c0e84e870874dd37ed0d164c7986f03a 使用在线MD5加密工具查看结果： 再测试一个很长的字符串： 1234$ g++ MD5.cpp -o MD5$ ./MD5In cryptography, a keyed-hash message authentication code(HMAC) is a specific type of MAC involving a cryptographic hashfunction and a secret cryptographic key.It may be used to simultaneously verify both the data integrity andthe authentication of a message, as with any MAC.Any cryptographic hash function, such as MD5 or SHA-1, may beused in the calculation of an HMAC; the resulting MAC algorithm istermed HMAC-MD5 or HMAC-SHA1 accordingly.The cryptographic strength of the HMAC depends upon thecryptographic strength of the underlying hash function, the size ofits hash output, and on the size and quality of the keya939099e207813b92284271a3fd49dd5 使用在线工具查看结果： 可以看到，结果是正确的，因此实现的MD5算法是正确的。]]></content>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-210]]></title>
    <url>%2F2018%2F11%2F30%2Fleetcode-210%2F</url>
    <content type="text"><![CDATA[题目Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: 12345&gt;Input: 2, [[1,0]] &gt;Output: [0,1]&gt;Explanation: There are a total of 2 courses to take. To take course 1 you should have finished &gt; course 0. So the correct course order is [0,1] .&gt; Example 2: 123456&gt;Input: 4, [[1,0],[2,0],[3,1],[3,2]]&gt;Output: [0,1,2,3] or [0,2,1,3]&gt;Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both &gt; courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. &gt; So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .&gt; Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. 分析这道题是典型的图论的算法题，主题就是拓扑排序：把图中的所有节点排序，使得所有的边都从排在前面的节点指向排在后面的节点。 本题给出了节点数量和以节点对来表示的边的数组。 一般来说，要做拓扑排序，有两种解法： 遍历图，找到所有入度为0的节点(源)，然后删去这个节点以及从它出去的边，重复这个过程 使用DFS，记录每个节点的post值，然后按post值递减进行排序 此外，如果图不是DAG，图中有环的话，是没有拓扑排序的，这很容易理解，而上面两种方法也有不同的判断是否有环的方法： 在遍历过程中，如果在剩下的节点集合中找不到源，剩余节点数又大于0，就有环 在DFS过程中，如果有这样的一条边：从已计算出post值的节点指向一个已有prev值、但是没有post值的节点，则有环(即存在回边) 解法一采用删除源的方法，我们首先要记录所有节点的入度inDegree，然后重复以下过程： 找到源，把它加入到结果数组order的尾部 删除源，具体操作为：从记录inDegree的map中删除它的记录，然后删除从源出去的边，并把这些边指向的节点的inDegree减一 找不到源时，即有环，没有结果 通过使用unordered_map，我们不仅可以快速获取一个节点的入度，而且删除节点也十分高效。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;//解法一:删除源//判断有无环:没有源，但节点集合又不为空class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; int num = numCourses; unordered_map&lt;int, int&gt; inDegree; for (int i = 0; i &lt; numCourses; ++i) inDegree[i] = 0; vector&lt;int&gt; order; for (int i = 0; i &lt; prerequisites.size(); ++i) &#123; inDegree[prerequisites[i].first]++; &#125; while (num != 0) &#123; bool flag = false; for (unordered_map&lt;int, int&gt;::iterator itr = inDegree.begin(); itr != inDegree.end();) &#123; if (itr-&gt;second == 0) &#123; flag = true; order.push_back(itr-&gt;first); //删除从源出去的边 for (vector&lt;pair&lt;int, int&gt;&gt;::iterator it = prerequisites.begin(); it != prerequisites.end();) &#123; if (it-&gt;second == itr-&gt;first) &#123; inDegree[it-&gt;first]--; it = prerequisites.erase(it); &#125; else it++; &#125; //删除源 itr = inDegree.erase(itr); num--; &#125; else itr++; &#125; //有环 if (flag == false) return &#123;&#125;; &#125; return order; &#125;&#125;; 解法二使用DFS来遍历一次图，获取每个节点的post值，然后利用post值的降序来进行排序。 prev值表示开始访问节点返回的时刻 post值表示访问完节点返回的时刻 使用DFS来遍历图的伪代码： 1234567891011121314151617181920func dfs for all v in V do visited[v] = false for all v in V do if not visited[v] : explore(v)func explore(v) visited[v] = true previsit(v) for each edge (v, u) in E do if not visited[u] : explore(u) postvisit(v)func prevvisit(v) prev[v] = clock clock++ func postvisit(v) post[v] = clock clock++ 要判断是否有环的话，判断是否有回边即可：有边从已有post值的节点指向已有prev值、但没有post值的节点。 通过构建邻接表，我们可以快速获取从节点出发的边所指向的下一节点，实现O(V+E)的时间复杂度的DFS算法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;//解法二:通过DFS获取post值，按post值递减排序//判断有无环:如果有一条边由已有post值的点指向有prev值、但没有post值的点，则有环class Solution &#123;private: //邻接表 vector&lt;vector&lt;int&gt; &gt; adjList; vector&lt;bool&gt; visited; vector&lt;int&gt; prev; vector&lt;int&gt; post; int clock = 1; bool hasCircle = false; vector&lt;int&gt; order; void explore(int node) &#123; visited[node] = true; //previsit prev[node] = clock; clock++; for (int i = 0; i &lt; adjList[node].size(); ++i) &#123; if (visited[adjList[node][i]] == false) explore(adjList[node][i]); else if (post[adjList[node][i]] == 0) hasCircle = true; &#125; //postvisit post[node] = clock; clock++; order.insert(order.begin(), node); &#125;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; visited = vector&lt;bool&gt;(numCourses, false); prev = vector&lt;int&gt;(numCourses, 0); post = vector&lt;int&gt;(numCourses, 0); adjList = vector&lt;vector&lt;int&gt;&gt;(numCourses); //构建邻接表 for (int i = 0; i &lt; prerequisites.size(); ++i) adjList[prerequisites[i].second].push_back(prerequisites[i].first); for (int i = 0; i &lt; numCourses; ++i) &#123; if (visited[i] == false) &#123; explore(i); &#125; &#125; if (hasCircle == true) return &#123;&#125;; else return order; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-085]]></title>
    <url>%2F2018%2F11%2F24%2Fleetcode-085%2F</url>
    <content type="text"><![CDATA[上周做完Largest Rectangle in Histogram后leetcode推荐我接下来做这一题，因此本周算法题就选它了。 题目Maximal Rectangle Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 123456789&gt; Input:&gt; [&gt; ["1","0","1","0","0"],&gt; ["1","0","1","1","1"],&gt; ["1","1","1","1","1"],&gt; ["1","0","0","1","0"]&gt; ]&gt; Output: 6&gt; 分析这道题的意思很明确，给出一个二维矩阵，让我们从中找出由1组成的最大矩形面积，和上周那题一样，都是要求最大矩形面积，但输入由一维数组变成了二维数组。 解法如果采用暴力求解的话，我们可以先找出所有只由1组成的矩形(一个个遍历元素，从它开始向右、向下再向右扩展)，再从中计算出最大的矩形面积。但用暴力求解来解上周那一维输入的题运行时间都超了1000ms，这次肯定会超时，因此我没有采用这种解法。 实际上，这两道题之间有着很大的联系，不然我也不会一直提起上周那题。仔细想想，求解一维数组中最大矩形面积我们已经有了较快的解法，那么我们可以考虑把从二维数组求解转变成从一维数组求解。 我们从上往下，一行行来分解二维矩阵，就可以把问题转变成求m次一维数组的最大矩形面积(m为行数)：以一个一维数组来存放高度，当遍历到下一行时，从左往右遍历每一列位置，如果该位置为0，则高度为0；否则高度为上一行求得的高度+1。 例如，在例子中，遍历到每一行时高度分别为： 1234["1","0","1","0","0"],["2","0","2","1","1"],["3","1","3","2","2"],["4","0","0","3","0"] 运用上一周的算法即可算出答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) &#123; if (matrix.size() == 0) return 0; int result = 0; vector&lt;int&gt; heights(matrix[0].size(), 0); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = 0; j &lt; matrix[i].size(); ++j) &#123; if (matrix[i][j] == '0') heights[j] = 0; else heights[j]++; &#125; result = max(result, largestRectangleArea(heights)); &#125; return result; &#125; int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; int n = heights.size(); if (n == 0) return 0; int left[n], right[n]; left[0] = -1; right[n - 1] = n; for (int i = 1; i &lt; n; ++i) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = i - 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = left[i - 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != -1) &#123; tmp = left[tmp]; &#125; left[i] = tmp; &#125; &#125; for (int i = n - 2; i &gt;= 0; --i) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = i + 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = right[i + 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != n) &#123; tmp = right[tmp]; &#125; right[i] = tmp; &#125; result = max(result, (right[i] - left[i] - 1) * heights[i]); &#125; result = max(result, (right[n - 1] - left[n - 1] - 1) * heights[n - 1]); return result; &#125;&#125;;static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;(); 复杂度分析这个解法的复杂度重点在于求最大矩形面积的算法，在上周我们已经分析过，算法由于while循环的次数可以很少，因此算法时间复杂度可以逼近O(n)，空间复杂度O(2n) = O(n)。 因此这个解法的时间复杂度逼近O(mn)，空间复杂度为O(3n) = O(n)，其中m为matrix行数，n为matrix列数。 另外，在提交后查看别人的代码时，我发现了这么一段代码： 12345static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;(); 这段代码通过关闭cout与printf之间的同步、解除cin与cout之间的绑定提高了C++的IO效率。详情参见： https://blog.csdn.net/chenf1999/article/details/84452273 在这么做之后，这个解法在leetcode上运行时间为8ms。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-084]]></title>
    <url>%2F2018%2F11%2F16%2Fleetcode-084%2F</url>
    <content type="text"><![CDATA[题目Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 123&gt; Input: [2,1,5,6,2,3]&gt; Output: 10&gt; 分析这道题看起来和之前那道Trapping Rain Water很像，给的例题都有直方图，但这题要求的是直方图中能找到的最大矩形面积，要求连续的几个数数值越近越好，就能组成更大的面积，与之前那道正好相反。 解法一首先，最容易想到的解法就是对数组中的每个高度都求出对应的最大矩形面积，然后取最大值，即为答案。 要求固定高度h的最大矩形面积的话，我们需要遍历整个数组，然后记录每一个能够组成的高度为h的矩形面积，最后取最大值，伪代码如下： 123for i in heights do if (heights[i] &gt;= h) //这个元素作为当前矩形的一部分 else //该元素高度小于矩形高度，计算当前矩形面积 需要注意的几点： 计算矩形面积后要及时更新矩形的左右下标为初始值 当最后一个元素也大于矩形高度时，不能忽略这个矩形的高度 为了避免重复计算，可以用map来存储已经计算过的高度对应的面积 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; map&lt;int, int&gt;area; for (auto i : heights) &#123; //判断这个高度的矩形的面积是否被计算过 if (area.find(i) == area.end()) &#123; area.insert(std::pair&lt;int, int&gt;(i, calc(i, heights))); result = max(result, area[i]); &#125; &#125; return result; &#125;private: int calc(int h, const vector&lt;int&gt;&amp; heights) &#123; int left, right; left = right = -1; int area = 0; for (int i = 0; i &lt; heights.size(); ++i) &#123; //矩形左下标 if (heights[i] &gt;= h &amp;&amp; left == -1) left = right = i; //矩形右下标右移 else if (heights[i] &gt;= h) right++; //h小于矩形高度，计算当前最大矩形面积 else if (left != -1) &#123; area = max(area, (right - left + 1) * h); left = right = -1; &#125; &#125; //不要遗漏右下标为最后一个下标的矩形面积 if (right == heights.size() - 1) &#123; area = max(area, (right - left + 1) * h); &#125; return area; &#125;&#125;; 复杂度分析这种解法在最好情况下复杂度为O(2n)，即数组中所有元素值都相等时；最坏情况下复杂度为O(n2)，即数组中所有元素值都不相等时。 但是这种解法在leetcode上运行时间超过了1000ms，因此必须进行优化。 解法二上面那种解法在经过了使用map来避免重复计算后运行时间还是很高，这是因为计算每个高度对应的面积时都必须遍历整个数组，我们要从这一点入手来进行优化。 但是每个高度对应的面积之间貌似没有联系，不能通过一个值来推出其他值，因此我考虑换一种基本思路：计算每个包含当前元素的矩形面积，然后取最大值。这个计算要求我们从当前元素下标开始，分别向左和向右找第一个高度小于当前元素的下标，然后就是(right - left - 1) * height，伪代码如下： 123456for i in heights do for j = i - 1 to 0 do if (heights[j] &lt; heights[i]) left = j;break for j = i + 1 to 0 do if (heights[j] &lt; heights[i]) right = j;break result = max(result, (right - left - 1) * heights[i]) 这种基本思路的解法比解法一的复杂度还会稍微高一点，但是重点是它是可以优化的，因为相邻两个元素之间的left值和right值是有联系的： 假设从左往右遍历，如果当前元素高度大于它左边元素高度，那么它的left值就是左边元素的left值；否则，需要往左遍历去寻找left值。但是通过存储每个元素的left值和right值，可以简化这个遍历过程，伪代码如下： 12345678int left[n], right[n];for i in heights do if (heights[i] &gt; heights[i - 1]) left[i] = left[i - 1] else &#123; int tmp = left[i - 1] while (heights[i] &lt;= heights[tmp]) tmp = left[tmp] left[i] = tmp &#125; 因为元素j高度大于元素i高度，因此第一个高度小于元素i的下标一定&lt;=元素j的left值，通过利用数组，我们可以快速完成遍历，提高算法速度。 最终的算法需要遍历两次数组，分别求解出left和right数组，然后计算面积，可以把计算面积的过程放在求解right数组的循环种来减少运行时间。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; int n = heights.size(); if (n == 0) return 0; int left[n], right[n]; left[0] = -1; right[n - 1] = n; for (int i = 1; i &lt; n; ++i) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = i - 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = left[i - 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != -1) &#123; tmp = left[tmp]; &#125; left[i] = tmp; &#125; &#125; for (int i = n - 2; i &gt;= 0; --i) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = i + 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = right[i + 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != n) &#123; tmp = right[tmp]; &#125; right[i] = tmp; &#125; result = max(result, (right[i] - left[i] - 1) * heights[i]); &#125; result = max(result, (right[n - 1] - left[n - 1] - 1) * heights[n - 1]); return result; &#125;&#125;; 复杂度分析算法的复杂度在最坏情况下为O(n2)，但这种情况很难遇到，更一般的情况下可以逼近O(n)，在leetcode上运行时间为12ms。 总结第一种解法虽然利用map省去了重复计算，但是每一次计算的复杂度还是很高；而第二种解法利用每个矩形左右下标之间的联系，简化了计算的过程，使算法提速明显，因此我们在设计算法时要尽量利用已知来求解未知，简化计算过程。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-152]]></title>
    <url>%2F2018%2F11%2F11%2Fleetcode-152%2F</url>
    <content type="text"><![CDATA[题目Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 1234&gt; Input: [2,3,-2,4]&gt; Output: 6&gt; Explanation: [2,3] has the largest product 6.&gt; Example 2: 1234&gt; Input: [-2,0,-1]&gt; Output: 0&gt; Explanation: The result cannot be 2, because [-2,-1] is not a subarray.&gt; 分析这道题的意思是让我们计算出一个整数数组中乘积最大的子序列的乘积，要注意子序列必须是连续的。 这道题的难点在于负数的存在，可以让一个本来乘积为负数的子序列在增加一个元素后乘积为正，比如-2, 3, 4, 5, -3这个数组，如果没有最后的-3的话，答案就是60，子序列不能包含-2。但由于-3的存在，答案是360，子序列是整个数组。 这道题在leetcode中被划分为动态规划问题。 解法一既然这是一个动态规划问题，那首先我们就需要一个数组max[n]来记录以第i个数结尾的子序列的最大乘积(0 &lt;= i &lt; n)，类似于最大子序列和的问题。 那么对于max[i]，我们如何通过max[i - 1]来计算出max[i]呢？可能会想到类似于最大子序列和的解法，用max(max[i - 1] * nums[i], nums[i])来求解，即最大乘积要么就是第i个数，要么就是第i个数乘以原来的乘积。 这种解法是无法解决负数存在的问题的，比如上面那个例子。貌似我们不能从max[3](5结尾)来计算出max[4](-3结尾)的值，它们并没有直接的关系，因为max[3]没有把-2计算进去，而max[4]需要把-2计算进去。 如果我们不能通过上一个子问题的结果来计算下一个子问题的话，好像就不是动态规划了，因此肯定是计算max[i]的方法不对。 我们可以发现，-3会使结果变化的原因是前面子序列乘积的最小值是个负数，而且其绝对值是最大的乘积，因此新的结果就是原来乘积的最小值乘以-3。 想到这里就可以知道答案了，我们需要为以第i个数结尾的子序列维护最小乘积和最大乘积，这两个值同时用来计算以下一个数结尾的子序列的最小乘积和最大乘积。 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int min[n], max[n]; min[0] = max[0] = nums[0]; //min[i],max[i]分别表示以第i个数结尾的子序列的最小/最大值 for (int i = 1; i &lt; n; ++i) &#123; min[i] = std::min(std::min(min[i - 1] * nums[i], nums[i]), max[i - 1] * nums[i]); max[i] = std::max(std::max(max[i - 1] * nums[i], nums[i]), min[i - 1] * nums[i]); &#125; int result = max[0]; for (int i = 1; i &lt; n; ++i) if (result &lt; max[i]) result = max[i]; return result; &#125;&#125;; 解法二同样地，我们可以为这个DP算法优化空间复杂度，不难发现，我们可以把记录子序列最小/最大值的min，max数组优化成单个元素，因为每次计算min[i]时要用到的都是min[i - 1]和max[i - 1]。 如果只用min来存以第i个数结尾的子序列的最小值的话，当我们在计算出min[i]之前，实际上min里存的是min[i - 1]的值，即上一轮循环的结果还没有被更新，可以用来计算这一轮的结果 要注意当计算出min之后，上一轮的min值就被覆盖了，而计算这一轮的max需要用到上一轮的min值，因此需要一个临时变量来存储上一轮的min值 优化后算法空间复杂度O(1)，时间复杂度O(n) 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int result; int min, max; result = min = max = nums[0]; //min,max分别表示以第i个数结尾的子序列的最小/最大值 for (int i = 1; i &lt; n; ++i) &#123; int tmp = min; min = std::min(std::min(min * nums[i], nums[i]), max * nums[i]); max = std::max(std::max(max * nums[i], nums[i]), tmp * nums[i]); if (result &lt; max) result = max; &#125; return result; &#125;&#125;; 总结这道题也是很典型的动态规划问题，难点在于由于负数的存在，最小乘积也是会影响到结果的，而我们一般只会想到要维护最大乘积的值，就比较难求解。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-072]]></title>
    <url>%2F2018%2F11%2F04%2Fleetcode-072%2F</url>
    <content type="text"><![CDATA[题目Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 1234567&gt; Input: word1 = "horse", word2 = "ros"&gt; Output: 3&gt; Explanation: &gt; horse -&gt; rorse (replace 'h' with 'r')&gt; rorse -&gt; rose (remove 'r')&gt; rose -&gt; ros (remove 'e')&gt; Example 2: 123456789&gt; Input: word1 = "intention", word2 = "execution"&gt; Output: 5&gt; Explanation: &gt; intention -&gt; inention (remove 't')&gt; inention -&gt; enention (replace 'i' with 'e')&gt; enention -&gt; exention (replace 'n' with 'x')&gt; exention -&gt; exection (replace 'n' with 'c')&gt; exection -&gt; execution (insert 'u')&gt; 分析这道题是很经典的字符串编辑距离问题，是动态规划解决问题的一个典型例子。题目问的是我们通过一次只能增加、减少或替换一个字符的操作，最少几次操作能把两个字符串改成相同的字符串。 解法一使用动态规划来解决问题。 考虑长度为i的字符串str1和长度为j的字符串str2，用dist[i][j]来代表它们之间的编辑距离。 首先，容易知道，如果其中一个字符串为0，那么编辑距离就是另一个字符串的长度，即i = 0时 dist[0][j] = j，j = 0时dist[i][0] = i。 要计算dist[i][j]，我们考虑从str1和str2的最后一个字符(char1和char2)入手： 如果char1 == char2，那么dist[i][j] = dist[i - 1][j - 1]，这应该是很容易看出来的，最后一个字符相等，那么有没有它们对编辑距离都没有影响 如果char1 != char2，这时候可以对最后一个字符进行3个操作： 把char2替换成char1，那么dist[i][j] = 1 + dist[i - 1][j - 1]，这是因为替换后就相当于char1 == char2的情况了，因此只需要加上那替换的开销1 在str2最后加一个字符char1，那么dist[i][j] = 1 + dist[i - 1][j]，这相当于给str2加了一个长度，此时的char1 == char2，同样需要额外的开销1 删掉str2的最后一个字符char2，那么dist[i][j] = 1 + dist[i][j - 1]，这种情况相当于str2长度减1，当然就是要算dist[i][j - 1]了，同样需要额外开销1 上面对char2的操作也可以改成对char1的操作，但结果没有区别 根据上面的结论，很容易得到动态规划方程： 12dist[i][j] = min(1 + dist[i - 1][j], 1 + dist[i][j - 1], diff(char1, char2) + dist[i - 1][j - 1])//diff(char1, char2) = (char1 == char2) ? 0 : 1 根据动态规划可以写出下面的代码，时间复杂度O(mn)，空间复杂度O(mn)。 代码12345678910111213141516171819202122232425262728293031#include &lt;string&gt;#include &lt;iostream&gt;using std::min;using std::string;class Solution &#123;public: int minDistance(string word1, string word2) &#123; //对于长度为i的word1子串和长度为j的word2子串 //dist[i][j]表示这两个子串之间的编辑距离 int m = word1.length(), n = word2.length(); int dist[m + 1][n + 1]; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; if (i == 0) dist[i][j] = j; else if (j == 0) dist[i][j] = i; else dist[i][j] = __INT_MAX__; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dist[i][j] = min(min(1 + dist[i - 1][j], 1 + dist[i][j - 1]), diff(word1[i - 1], word2[j - 1]) + dist[i - 1][j - 1]); &#125; &#125; return dist[m][n]; &#125;private: int diff(char c1, char c2) &#123; return !(c1 == c2); &#125;&#125;; 解法二很多DP算法都可以进行空间复杂度的优化，本题也不例外，通过优化，我们可以把空间花费降至线性。 考虑解法一中的双重循环，转换到如下表格的话，不难知道是一行行地算出结果的。在初始时表格第一行和第一列的值是确定的，这由前面的讨论可以知道。 考虑当计算到任意位置的dist[i][j]，我们可以由解法一算法得知，dist[i][j]取决于它左边、上面、以及左上角表格的值，现在我们可以考虑把空间压缩到一维了： dist[n]只存每一行的值，初始情况即第一行。 当要计算dist[j]时，由于我们是从左往右计算每一行的，所以左边的值就是dist[j - 1]，而上面的值就是dist[j](因为此时dist[j])还没有被覆盖，存放的仍是上一行的值，而dist[j - 1]就已经被覆盖，存放的是这一行的值。所以我们也能够知道，我们必须事先存储左上角的值，因为会被覆盖，左上角的值即在计算上一个dist[j]时未被覆盖的上面的值。 优化后的代码空间复杂度为O(n)，时间复杂度不变。 很多DP算法都可以通过这种画表格的方式来优化空间。 代码123456789101112131415161718192021222324252627282930#include &lt;string&gt;#include &lt;iostream&gt;using std::min;using std::string;class Solution &#123;public: int minDistance(string word1, string word2) &#123; //对于长度为i的word1子串和长度为j的word2子串 //dist[i][j]表示这两个子串之间的编辑距离 int m = word1.length(), n = word2.length(); if (m == 0) return n; if (n == 0) return m; int dist[n + 1]; for (int i = 0; i &lt;= n; ++i) dist[i] = i; int leftNor; for (int i = 1; i &lt;= m; ++i) &#123; leftNor = i - 1; dist[0] = i; for (int j = 1; j &lt;= n; ++j) &#123; int tmp = dist[j]; int diff = word1[i - 1] == word2[j - 1] ? 0 : 1; dist[j] = min(min(dist[j] + 1, dist[j - 1] + 1), diff + leftNor); leftNor = tmp; &#125; &#125; return dist[n]; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链热身报告]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[区块链project热身报告安装以太坊Geth是以太坊智能合约开发中最常用的工具，执行在GO上运行的完整以太坊节点，通过Geth，我们可以实现以太坊的各种功能，如账户的新建、编辑、删除，开启挖矿，以太币的转移，智能合约的部署和执行等等。 windows下安装在官网下载安装包即可(需翻墙)，安装过程会自动配置环境变量，在cmd中使用geth version可以查看是否安装成功 ubuntu下安装同样去官网下载对应版本，这是一个tar.gz包，下载后解压即可得到geth可执行文件，配置好环境变量就可以使用了 私有链搭建进入到为搭建私有链创建的文件夹privatechain后，执行以下操作 配置文件要搭建私有链，首先需要编写创始区块配置文件，命名为genesis.json，内容如下: 1234567891011121314151617&#123; "config": &#123; "chainId": 10, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0 &#125;, "alloc" : &#123;&#125;, "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x20000", "extraData" : "", "gasLimit" : "0xffffffff", "nonce" : "0x0000000000000042", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"&#125; 要注意几点： chainId不能为0，否则部署智能合约时会出错： 1invalid sender undefined gaslimit不能太小，否则部署智能合约时会报错： 1Error: exceeds block gas limit undefined difficulty会影响到你节点的挖矿速度 初始化私有链1geth --datadir data0 init genesis.json 这条命令表示初始化私有链到文件夹data0中，这条链的数据存放在data0里，并根据genesis.json中的内容把创世区块写入区块链，通过log信息中的Successfully wrote genesis state我们知道初始化成功。 初始化后的初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 启动私有链节点1geth --datadir data0 --networkid 1108 console geth console，表示启动节点并进入交互式控制台，控制台是一个交互式的Javascript执行环境 –-datadir选项指定使用data0作为数据目录，即运行我们前面初始化的那条私有链 –-networkid选项指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id 一些简单操作查看账户 1&gt;eth.accounts 创建账户 123&gt;personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase: 查看账户余额 1&gt; eth.getBalance(eth.accounts[0]) 启动&amp;停止挖矿 12&gt; miner.start(10)#参数10表示挖矿使用的线程数&gt; miner.stop()： 解锁账户 1&gt; personal.unlockAccount(eth.accounts[0]) 发送交易 12&gt; amount = web3.toWei(10,'ether')&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)#这个交易表示从账户0向账户1转账10个以太币 私有链节点加入要向私有链中加入节点，我们需要同时运行两个节点，同时启动节点的命令是有要求的，我启动两个节点(同一台电脑)的命令分别为： 1geth --networkid 1108 --nodiscover --datadir data0 --port 30303 --rpc --rpcapi net,eth,web3,personal --rpcport 8545 --rpcaddr localhost --verbosity 6 console 2&gt;&gt;geth0.log --ipcpath "geth0.rpc" 1geth --networkid 1108 --nodiscover --datadir data1 --port 55554 --rpc --rpcapi net,eth,web3,personal --rpcport 8101 --rpcaddr localhost --verbosity 6 console 2&gt;&gt;geth1.log --ipcpath "geth1.rpc" 当然，首先得搭建两个节点data0和data1. 参数解释： 123456789--nodiscover 关闭p2p网络的自动发现，需要手动添加节点，这样有利于我们隐藏私有网络--datadir 区块链数据存储目录--port 网络监听端口，默认30303--networkid 网络标识，私有链取一个大于4的随意的值--rpc 启用ipc服务--rpcport ipc服务端口，默认端口号8545--rpcapi 表示可以通过ipc调用的对象--rpcaddr ipc监听地址，默认为127.0.0.1，只能本地访问console 打开一个可交互的javascript环境 这之中要注意的几个地方是： 端口号必须不同 rpc端口号必须不同 ipcpath必须不同 进入了Javascript Console之后，首先在第一个节点data0那执行命令查看enode： 1admin.nodeInfo.enode 然后在第二个节点data1那执行命令 1admin.addPeer(&quot;xxx&quot;) 括号内填查看到的data0的enode信息，返回true即可成功加入节点，加入后data1就会自动开始同步data0的所有区块。 之后可以使用以下命令来查看节点是否添加成功： 12net.peerCountadmin.peers 在data1使用eth.blockNumber来查看区块是否同步成功。 注意： windows下节点同步可能会失败，所以最好在Linux下进行加入节点的操作 要保证两个节点在同一个区块链上工作的话首先要保证genesis创世区块链是一样的，所以注意使用同样的genesis.json文件来创建． 解释getBlock字段使用getBlock来得到区块相关信息： 1234567891011121314151617181920212223 eth.getBlock(0)&#123; difficulty: 131072, extraData: "0x", gasLimit: 4294967295, gasUsed: 0, hash: "0x04786260f9e2b8a341a6a07949d74365c53bc4fd1edb00ff3b5f209f86906579", logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", miner: "0x0000000000000000000000000000000000000000", mixHash: "0x0000000000000000000000000000000000000000000000000000000000000000", nonce: "0x0000000000000042", number: 0, parentHash: "0x0000000000000000000000000000000000000000000000000000000000000000", receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", size: 508, stateRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", timestamp: 0, totalDifficulty: 131072, transactions: [], transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", uncles: []&#125; 参数为0，查看的是创世区块，也可以把参数设为”latest”来查看最新区块。 difficulty：当前块的难度。 extraData：包含这个区块的任意字节相关数据。 gasLimit：当前区块允许使用的最大gas，这个值是我们genesis.json中的gasLimit值。 gasUsed：当前区块累计使用的总的gas。 hash：区块的哈希串。当这个区块处于pending将会返回null。 logsBloom：由日志信息组成的一个Bloom过滤器 （数据结构）。当这个区块处于pending将会返回null。 miner：这个区块获得奖励的矿工。 mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算 nonce：在挖矿过程中起作用，POW生成的哈希。当这个区块处于pending将会返回null。 number：区块号。当这个区块处于pending将会返回null。 parentHash：父区块的哈希值。由于这是创始区块，因此该值为0。 receiptsRoot：包含此区块所列的所有交易收据的树的根节点Hash值 sha3Uncles：叔区块的哈希值。 size：当前这个块的字节大小。 stateRoot：区块的最终状态前缀树的根。 timestamp：区块打包时的unix时间戳。 totalDifficulty：区块链到当前块的总难度。 transactions：交易对象。或者是32字节的交易哈希。 transactionsRoot：包含此区块所列的所有交易的树的根节点Hash值 uncles：叔哈希的数组。 叔块是什么？在上面的区块中有叔块的信息，那么叔块是什么呢？ 我们都知道在挖矿过程中，只有最长的那条链才会被所有节点所承认，挖到在最长链的那些区块的矿工才能获得奖励。如果一个块不是最长链的一部分，那么它被称为是“孤块”。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。 根据Ethereum的GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。在以太坊中，孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献。 由于GHOST协议支付报酬给叔块，这激励了矿工在新发现的块中去引用叔块。引用叔块使主链更重。在比特币，最长的链是主链。在以太坊中，主链是指最重的链 解释日志输出通过在启动私有链节点时在命令最后加上2 &gt;&gt;xxx.log即可把日志输出到log文件中，通过设置选项--verbosity n可以设置日志的程度。 我选取了一些日志进行解释： 日志1 这个日志是我在给私有链添加节点时的日志输出，可以看到，执行命令后的第一个日志输出就是Adding p2p peer，表示加入节点。connnection set up表示建立连接，之后直到Ethereum peer connected，连接成功。然后就要开始为节点上区块链的同步做准备了，Block synchronisation started表示区块同步开始。此后要经过一系列的准备工作，比如获取链高度、下载区块体、获取区块头…最后可以看到一连串的Inserted new block，这就表示同步区块正式开始啦，可以从右边的number得知同步进度。 日志2 这个日志是挖矿的日志。一开始的Updated mining threads表示更新挖矿的线程，右边可以看到线程数量为10，这是在miner.start(10)中设置的。Etherbase automatically configured表示使用默认的coinbase，默认的是本地账户中的第一个账户，即eth.accounts[0]，挖矿所得到的所有奖励都会进入这个账户中。之后Commit new mining work表示挖矿正式开始，那个🔨开头的日志说明成功挖到了矿，可以从右边的number看到挖到区块的数目。 日志3 这个简短的日志是进行一笔交易的日志，不知道为啥设置verbosity为6也还是看不到更具体的信息。Pooled new future transaction表示提交到交易缓冲池，Promoting queued transaction表示选择一部分交易进入pending队列进行处理，Submitted transaction表示交易被成功处理并提交，最后的Broadcast transaction表示把这笔交易广播出去。 部署智能条约编写合约首先编写智能合约，用solidity语言实现： 12345678910111213141516171819202122232425contract Mortal &#123; /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() &#123; owner = msg.sender; &#125; /* Function to recover the funds on the contract */ function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125; contract Greeter is Mortal &#123; /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public &#123; greeting = _greeting; &#125; /* Main function */ function greet() constant returns (string) &#123; return greeting; &#125;&#125; 由于Solidity同样具有继承的特性，通过只声明Greeter是Mortal的，Greeter就可以继承”Mortal”合约的所有特征。 这段代码的主函数是greet()，我们之后将调用这个函数来调用智能合约。 编译合约使用在线编译器remix来编译(需要翻墙)： 首先确定右窗格中选择的是Greeter而不是Mortal，然后点击Details来获取编译后的代码，复制WEB3DEPLOY中的代码： 保存到js文件中，命名为contract.js，并修改第一行为： 1var _greeting = "Hello World!" 部署合约执行loadScript(&quot;contract.js&quot;)导入文件，报错如下： 这是因为我们必须要先解锁账户，因为我们需要支付部署合约的GAS费用，解锁后继续执行： 执行eth.getCode(greeter.address)来验证代码是否部署成功： 报错是因为部署合约需要挖矿，启动挖矿后再次执行： 部署成功！ 调用合约执行greeter.greet()，我们可以看到输出： 由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何Gas费用 使用其他节点调用合约这首先要求添加节点到私有链中，因此转到ubuntu操作： 上图是在data0进行部署合约的操作 然后，我们要知道通过其他节点调用这个合约需要两个信息： 合同所在地址 ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台 获取合同所在地址很简单，greeter.address;即可 要获取ABI，就需要去Remix官网，同样在Detail中获得，复制ABI文本框即可，然后暂时保存到一个abi.txt文件。如果我们想直接把它复制到终端是不行的，因为它含有换行符，因此需要去掉换行符(替换为空格)： 1cat abi.txt | tr '\n' ' ' 然后就可以把abi.txt中内容复制到以太坊交互式控制台中，把这段内容赋值给abi，查看赋值后abi的值： 在data1中执行以下命令： 1myContract = web3.eth.contract(abi).at(address) address为合约地址 查看myContract以及调用合约： 在节点data1中调用合约好像需要先解锁账户，但是这里我没有解锁也成功了，我想可能是因为这个调用不要消耗Gas值吧 解释交易字段首先解锁账户0： 1234&gt; personal.unlockAccount(eth.accounts[0])Unlock account 0xb01a469b117268418619e61f1b1a6e2fc7e4e7cePassphrase:true 发送交易(从账户0向账户1发送10个以太币)： 12345&gt; amout = web3.toWei(10, 'ether')"10000000000000000000"&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amout&#125;)INFO [11-04|16:56:58.227] Setting new local account address=0xB01A469b117268418619E61f1B1a6E2fc7e4E7cEINFO [11-04|16:56:58.235] Submitted transaction fullhash=0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76 recipient=0x20949144E5A4590857726BD3B4D95dce04731e78 最后返回的那个字符串即是交易的地址，可以通过getTransaction来查看交易信息，需要注意，此时交易还处于Pending状态(已提交但还未被处理的交易)，需要启动挖矿: 1miner.start(1);admin.sleepBlocks(1);miner.stop(); 这样交易就得到处理，使用getTransaction来查看交易： 12345678910111213141516171819&gt; eth.getTransaction("0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76")&#123; blockHash: "0x897bbbd6b0aeffadb707ad7b37149e93428c1b361809772b6ef99de96713f1e0", blockNumber: 13, from: "0xb01a469b117268418619e61f1b1a6e2fc7e4e7ce", gas: 90000, gasPrice: 1000000000, hash: "0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76", input: "0x", nonce: 0, r: "0x64f0b414949135360554da5165d5115d0df842776d323861121c6dab36e49255", s: "0x62b9702c7b734a7521f7d1853965c58f54bfe84f0d8273fd52f4381aa8b32524", to: "0x20949144e5a4590857726bd3b4d95dce04731e78", transactionIndex: 0, v: "0x37", value: 10000000000000000000&#125;&gt; eth.accounts["0xb01a469b117268418619e61f1b1a6e2fc7e4e7ce", "0x20949144e5a4590857726bd3b4d95dce04731e78"] blockHash: 交易所在区块的哈希值。当这个区块处于pending将会返回null。 blockNumber:交易所在区块的块号。当这个区块处于pending将会返回null。 from: 交易发起者的地址。在这里为accouts[0]。 gas:交易发起者提供的gas。 gasPrice:交易发起者配置的gas价格，单位是wei。 hash:交易的哈希值。 input:交易附带的数据。 nonce:交易的发起者在之前进行过的交易数量。 r:用于产生标识交易发生者的签名(ECDSA签名值) s:用于产生标识交易发生者的签名(ECDSA签名值) to:交易接收者的地址。当这个区块处于pending将会返回null，如果是部署智能合约的交易，这个值也是null。在这里显示为accouts[1]。 transactionIndex:交易在区块中的序号。当这个区块处于pending将会返回null。 v:用于产生标识交易发生者的签名(ECDSA签名值) value:交易附带的货币量，单位为Wei。在这里即是转账的值 参考链接如何搭建以太坊私有链 添加私有链节点 部署智能合约 叔块的概念]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DES算法实现]]></title>
    <url>%2F2018%2F11%2F02%2FDES%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文阐述DES算法的基本原理及其C++实现方法，并给出源代码 算法概述DES 是一种典型的块加密方法：它以64位为分组长度，64位一组的明文作为算法的输入，通过一系列复杂的操作，输出同样64位长度的密文。DES 采用64位密钥，但由于每8位中的最后1位用于奇偶校验，实际有效密钥长度为56位。密钥可以是任意的56位的数，且可随时改变。其中极少量的数被认为是弱密钥，但能容易地避开它们。所有的保密性依赖于密钥。虽然56位的密钥对于现在来说加密强度不够，但是可以通过多次DES加密来加强加密强度。DES 算法的基本过程是换位和置换。 总体结构DES算法的总体结构如图所示： 加密和解密过程都适用于上图，唯一的差别在于子密钥的调度顺序不同： 输入64位明文 M 时，子密钥按 (K1K2… K16)次序调度，是加密过程。输入64位密文 C 时，子密钥按 (K16K15 … K1)次序调度，是解密过程 下面以加密为例，阐述DES算法的具体过程： 分解明文按照8个字节(64位)一组来将明文分组，原始明文消息按PKCS#5 (RFC 8018) 规范进行字节填充，即： 最后一组长度不够8个字节时，在末尾以字节填满，填入的字节取值相同，都是填充的字节数目 原始明文消息刚好分组完全时，在末尾填充8个字节 (即增加一个完整分组)，字节取值都是08 接下来的每一组作为DES算法的输入M，开始加密 接下来的下标除了S盒之外，都是从1开始，而不是从0开始 初始置换IP通过固定的初始置换表来重排M中的二进制位，以下表为例： 置换的过程即是把M[58]的值赋给M[1]，M[50]的值赋给M[2]。 要注意的是下标不是从0开始 之后的所有置换都类似于这种情况 置换后得到64位二进制串M0 = L0R0，L0、R0分别为前32位和后32位 16轮迭代T这是算法最复杂的部分，迭代过程如图所示： 上一步得到的L0、R0作为这一步骤的初始输入，开始迭代。 这一轮的右32位Ri-1直接作为下一轮的左32位Li 这一轮的左32位Li-1与输出为32位的Feistel 函数进行异或运算之后得到下一轮的右32位Ri-1 这个过程要持续16次，即得到L16、R16 Feistel函数从迭代过程的图可以看到，Feistel的输入输出为： 输入1：上一轮迭代结果的右32位Ri-1 输入2：长度为48位的子密钥Ki 输出：32位的结果 此函数的具体工作过程为： 将长度为32位的串Ri-1进行 E-扩展，成为48位的串 E(Ri-1)，E-扩展的原理类似于IP置换，通过借助E-扩展规则 (比特-选择表) 来实现 将 E(Ri-1) 和长度为48位的子密钥 Ki 作异或运算，Ki 由密钥 K 生成(稍后解释生成子密钥过程) 将 (2) 得到的结果分成8个分组，每个分组长度6位(可以直接按照下标顺序来分组)。各个分组分别经过8个不同的 S-盒进行 6-4 转换，得到8个长度分别为4位的分组(S-盒操作也稍后解释) 将 (3) 得到的分组结果顺序连接得到长度为32位的串 将 (4) 的结果经过 P-置换，得到的结果作为Feistel函数的最终32位输出 生成子密钥根据给定的64位密钥K，生成16个48位的子密钥 K1-K16 原理为： 对64位密钥K进行PC-1置换，得到去掉了8位检验位的56位串，C0和D0分别为前28位和后28位结果，令i = 1 分别对Ci和Di进行循环左移，如果i=1,2,9,16，则循环左移一位，否则循环左移两位，得到Ci+1和Di+1 对56位的CiDi进行PC-2置换压缩，得到48位的子密钥Ki，i = i + 1，返回第二步，直到生成第16个子密钥Ki 生成过程图解： S-盒前面已经介绍，S-盒用于把6位二进制串转换成4位二进制串，Feistel函数中有8个6位的分组，因此用到了8个不同的S-盒 S-盒原理为： 每一个S-盒是一个4行(编号 0-3)、16列(编号 0-15) 的表，表中元素值是10进制的值 假设 Si 的6位输入为b1b2b3b4b5b6，则由 n = (b1b6)10 确定行号，由 m = (b2b3b4b5)10 确定列号，[ Si ]n,m元素的值的二进制形式即为所要的 Si 的输出 在这里要注意，行号和列号都是从0开始的，这一点与其他地方不同 用一个例子来说明： S1盒的表如图所示： 设S1 的6位输入b1b2b3b4b5b6 = 101100，则： n = (b1b6)10 = (10)10 = 2 m = (b2b3b4b5)10 = (0110)10 = 6 [ S1 ]2,6可通过上表得知是2 2 = (0010)2即为输出 交换置换W将第十六轮迭代生成的串L16R16交换位置，输出R16L16 逆置换IP-1操作类似于IP置换，只是换了置换表为IP逆置换表 模块分解根据DES算法特点，我将算法分解为以下几个模块： 进制转换convert：用于8位的字符串和64位的二进制01字符串互相转换 DES总体结构des：实现DES算法的总体结构，利用到了辅助模块： 循环左移leftshift 生成子密钥createkey 同时在des中会按需调用其他模块，用以算法实现 全局变量globalVar：存放DES算法中需要用到的各种表(如IP置换表) T迭代iteration：描述16轮迭代过程，其中用到了辅助模块： 轮函数feistel 置换transform：进行各种置换：IP置换、IP逆置换、PC-1置换、PC-2置换、E-扩展置换、P-置换 测试main：进行算法的测试，查看算法是否正确 数据结构C++中有bitset这个类库来管理一系列的bit位，但本实验中为了输入输出转换方便，我使用了char来存放一个bit位，用到的其他数据结构只有string 输入的明文是string，经过convert模块转换后成为了每组64位的二进制字符串，字符串用char数组表示，因此最后得到的密文也是每组64位的二进制字符串 密文经过convert模块转换后成为string 算法中还需要自己定义一些数据结构，即各种表，都是二维/三维的char数组 源代码源代码地址：https://github.com/chenf99/DES/tree/master/C%2B%2B 编译运行结果12345PS C:\Users\11638\Desktop\DES\C++&gt; g++ .\main.cpp -o desPS C:\Users\11638\Desktop\DES\C++&gt; ./desplain:TAKERS Championshipencrypt:▊噴。償挒皷煗硵柊decrypt:TAKERS Championship]]></content>
      <tags>
        <tag>DES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-374]]></title>
    <url>%2F2018%2F10%2F28%2Fleetcode-374%2F</url>
    <content type="text"><![CDATA[题目Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... Example 1: 123&gt; Input: nums = [1, 5, 1, 1, 6, 4]&gt; Output: One possible answer is [1, 4, 1, 5, 1, 6].&gt; Example 2： 123&gt; Input: nums = [1, 3, 2, 2, 3, 1]&gt; Output: One possible answer is [2, 3, 1, 3, 1, 2].&gt; Note:You may assume all input has valid answer. Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space? 分析这道题的意思是把一个无序的数组进行摆动排序，即在奇数下标(1, 3, 5, …)的元素值大于它相邻的偶数下标(0, 2, 4, …)的元素值。如果画出元素值大小随下标变化的图像的话，图像就随着下标的增大在上下不断摆动。 题目保证给出的输入一定有对应有效的输出。 我认为这道题的难点主要在于输入的值中可能有很多相同的值，如果值各异的话，通过简单的遍历来进行值的交换即可，每次遍历到的元素只需要与已确定的部分的最后一个元素比较大小。但由于存在相同的值，这种方法会导致相同的值会聚集在一起，无法得到正确结果。 解法一一种比较容易想到的解法是先找到数组的中位数，然后把所有大于中位数的元素放在奇数位置，所有小于中位数的元素放在偶数位置，等于中位数的元素则需要好好考虑，要尽量把它们分开来存放，如果两个等于中位数的元素相邻也是不满足要求的。 首先把数组排序，就能够找到中位数，然后把大于中位数的元素从左往右开始存放到奇数位置，把小于中位数的元素从右往左存放到偶数位置，等于中位数的元素存放在剩余位置。由于数组已经排好序，所以对于奇数位置，等于中位数的元素是放在右边的，而对于偶数位置，等于中位数的元素是放在左边的，这样就一定能够满足要求。所以寻找中位数不能使用nth_element()函数，因为这个函数并不会把数组排序，之后的操作也就无法保证能把等于中位数的元素分离开。 这种解法时间复杂度为排序的复杂度，O(nlogn)，空间复杂度O(n)。 代码1234567891011121314151617181920class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); //nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); int len = nums.size(); int mid = nums[len / 2]; int odd = 1, even = (len % 2) ? len - 1 : len - 2; vector&lt;int&gt; tmp(len, mid); for(int i = len - 1; i &gt; len / 2; i--) &#123; tmp[odd] = nums[i]; odd += 2; &#125; for(int i = 0; i &lt; len / 2; i++) &#123; tmp[even] = nums[i]; even -= 2; &#125; nums = tmp; &#125;&#125;; 解法二解法一的时间复杂度和空间复杂度都不是最优的，在Discuss中有人给出了时间复杂度O(n)，空间复杂度O(1)的解法，用到了virtual indexing和three-way-partition的技巧。 主要想法跟解法一类似，都是去找中位数，然后把大于中位数的元素放奇数位置，小于中位数的元素放偶数位置，等于中位数的元素放在剩余位置。 要解决时间复杂度的问题，可以用nth_element()函数来寻找中位数；要解决空间复杂度的问题，就不能够构造另外的数组，要进行就地置换(in_place)。 现在总结一下需要解决的问题：大于中位数的放1, 3, 5,…位置，小于中位数的放2, 4, 6,…位置，等于中位数的位置可以不变，同时在交换位置的过程中不能开辟额外的内存空间。 通过结合下标映射和3分法可以解决问题：把下标映射成1，3，5，…，2， 4， 6，…的形式，然后利用3分法，大于中位数的放左边，即映射后的1，3， 5，…下标；小于中位数的放右边，即映射后的2，4，6…下标。 映射是return (1 + 2 * index) % (len | 1);，其中len | 1在len为偶数时取len + 1，在len为奇数时取len。映射把从0～len - 1的index映射到1, 3, 5, …, 2, 4, 6, …。 之后就交给三分法来解决问题，只不过用于三分法的数组下标始终是经过映射后得到的下标。 时间复杂度为O(n)，空间复杂度为O(1)。 代码12345678910111213141516171819202122232425class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); int len = nums.size(); int mid = nums[len / 2]; for (int i = 0, left = 0, right = len - 1; i &lt;= right;) &#123; if (nums[mappedIndex(i, len)] &gt; mid) swap(nums, mappedIndex(left++, len), mappedIndex(i++, len)); else if (nums[mappedIndex(i, len)] &lt; mid) swap(nums, mappedIndex(right--, len), mappedIndex(i, len)); else i++; &#125; &#125;private: void swap(vector&lt;int&gt;&amp; nums, int index1, int index2) &#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125; //把从0～len - 1的index映射到1, 3, 5, ..., 2, 4, 6, ... int mappedIndex(int index, int len) &#123; return (1 + 2 * index) % (len | 1); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-279]]></title>
    <url>%2F2018%2F10%2F21%2Fleetcode-279%2F</url>
    <content type="text"><![CDATA[题目Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example1 123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example2 123Input: n = 13Output: 2Explanation: 13 = 4 + 9. 分析这道题目的意思是给定一个正整数，要求我们找到最少的平方数，它们的和等于这个正整数。 解法一一开始我尝试从这个正整数减去它最大的平方数入手，判断剩下的数能由多少个平方数组成。但这样做的问题是很可能找不到最少的平方数数目，因为剩下那部分数可能只能由1组成，比如12按这种做法得到的结果就是4。 对于这种问题，最好的方法是分解问题成为一个个易求解的子问题，再分别求解。 我分解问题的方法其实也是在前面的想法上进行改进得到的。 假设问题要求解的是num[n]，n为输入的正整数，我们可以把问题分解成： 1num[n] = min(num[n], num[n - i * i] + 1) 其中i是范围在[1, sqrt(n)]的正整数。通过赋值num[0] = 0，我们可以求出很多num[平方数] = 1，这样一层层求解出来就可以得到num[n]了。 代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; num(n + 1, __INT_MAX__); num[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= sqrt(i); ++j) &#123; num[i] = min(num[i - j * j] + 1, num[i]); &#125; &#125; return num[n]; &#125;&#125;; 解法二解法二是我在Discuss中看到的，是一种数学解法，利用到了四平方和定理，简单来说就是任何一个正整数都可以表示成4个平方数之和，因此答案 &lt;= 4。同时这个定理中还有一个公式：4k(8m + 7)，如果一个正整数不满足这个公式，那么它可以表示成3个平方数之和，此时答案 &lt;= 3；反之，满足这个公式的话答案 == 4。还有个重要的性质：就是如果一个数n是4的倍数，那么num[n] = num[n / 4]。 利用这个数学定理，我们可以更加快速地求出这个问题的答案，利用最后那个性质可以把正整数n缩小，很大地简化了后续求解过程。 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;class Solution &#123;public: int numSquares(int n) &#123; //是4的倍数的话可以除以4，不影响结果 while (n % 4 == 0) n /= 4; //满足8m + 7的数 if (n % 8 == 7) return 4; else &#123; //能否拆成两个平方数之和 for (int i = 0; i * i &lt;= n; ++i) &#123; int tmp = sqrt(n - i * i); if (tmp * tmp == n - i * i) &#123; return !!i + !!tmp; &#125; &#125; //拆不了的话答案就一定是3 return 3; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-135]]></title>
    <url>%2F2018%2F10%2F10%2Fleetcode-135%2F</url>
    <content type="text"><![CDATA[题目Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: 123Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: 1234Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. 分析这道题的意思是给排成一排的孩子发糖果，每个孩子都有级别，发糖果必须满足两个要求： 每个孩子至少一个糖果 级别比相邻孩子高的哪个孩子，得到的糖果也要比相邻孩子的多 解法这道题难度虽然被leetcode标记为Hard，但是并不难解决。第一个要求容易满足，主要是需要满足第二个要求，我们通过简单的遍历就可以得到每个孩子所分得的糖果数了。 输入的数组可以划分为三种子数组：从左至右递增的数组、从右至左递增的数组以及级别数相同的子数组。 对于输入[0, 1, 2, 3, 4]，易知所需的最小糖果数为15，每个孩子得到的糖果数为[1, 2, 3, 4, 5]。输入的孩子级别从左至右递增，因此他们得到的糖果数自然也需要从左至右递增。输入从右至左递增的情况也类似。 如果输入的子数组中级别数相同，如[2, 2, 2]，那中间那个孩子的糖果数为1(给中间孩子发满足条件的最少的糖果数)，另外两个孩子的糖果数取决于他们邻居的级别和糖果数。 以从左至右为例，我们采取的遍历的思想为：当前孩子的级别如果比他左边孩子的级别高，而且他的糖果数不比左边孩子的多的话，就把他的糖果数设置为左边孩子的糖果数 + 1(分配满足条件的最少的糖果数)。 但显然一次遍历是不够的，我们需要分别从左边和右边开始进行两次遍历，同时为了方便，统一把初始的糖果数置为0，这样前面讨论的3种情况都可以解决了。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;numeric&gt;using namespace std;class Solution &#123;public: int candy(const vector&lt;int&gt;&amp; ratings) &#123; vector&lt;int&gt; candy(ratings.size(), 0); //从两边开始分别遍历一次 for (int i = 1; i &lt; ratings.size(); ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candy[i] = candy[i - 1] + 1; &#125; &#125; for (int i = ratings.size() - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1] &amp;&amp; candy[i] &lt;= candy[i + 1]) &#123; candy[i] = candy[i + 1] + 1; &#125; &#125; //该函数的第三个参数指定累加的初值 return accumulate(candy.begin(), candy.end(), candy.size()); &#125;&#125;; 算法时间复杂度为O(n),空间复杂度为O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-025]]></title>
    <url>%2F2018%2F10%2F05%2Fleetcode-025%2F</url>
    <content type="text"><![CDATA[题目Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. 分析这道题目的意思是给出一个链表和一个正整数k，把链表按照每k个的顺序反转，即把链表分解成长度为k的子链表，反转这些子链表，然后再连接起来。需要注意的是如果链表长度不是k的整数，最后的那部分子链表长度不为k，则这一部分不需要反转。 解法对于此题，我的想法是写两个函数来解决问题： 分解链表的函数，把链表分解成长度为k的各个子链表 反转一段链表的函数，用于反转分解后得到的子链表 先实现反转一段链表的函数，这个函数比较容易实现，我们也经常遇到这种问题。实现的思路是用curr指针遍历链表，用pre记录curr的前一项，在遍历的过程中，把curr-&gt;next指向pre，再把pre赋值给curr，一直遍历下去，这样就完成了链表的反转，时间复杂度为O(n)，空间复杂度为O(1)。 稍微难一点的是分解链表的函数，因为链表长度未知，在分解完成、反转完成后还要连接各个子链表，因此不仅需要各个子链表的头，还要各个子链表的尾，而为了满足O(1)的空间复杂度，最好是在遍历的过程中分别用两个变量来记录头和尾，而不能另外开辟空间。 我的思路是：遍历一遍链表，通过count来计数，count ！= k时count++，继续遍历；当count == k时即找到一个子链表，反转这个子链表，并与前面已经完成反转操作的子链表连接，count设为0，再继续遍历。 在这之中需要注意几点： 要记录最终链表的头用以返回，这即是第一个反转后的子链表的头 每次分解需要记录子链表的头和尾，即更新curr_head和curr_tail 要注意处理链表长度不是k的倍数和k大于链表长度的情况 弄明白了这几点之后代码也就不难实现了，但这种解法的效率貌似并不高，应该是由于分解链表的效率低，因此还需要找更好的算法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: //反转一段链表 ListNode* reverse_List(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) return head; ListNode *curr = head, *prev = NULL; while (curr-&gt;next != NULL) &#123; ListNode* tmp = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = tmp; &#125; curr-&gt;next = prev; return curr; &#125; //先把整段链表分解成每k个一段，再对每一段进行反转，最后连接起来 ListNode* reverseKGroup(ListNode* head, int k) &#123; int count = 0;//用于计算一段链表的长度 ListNode* tmp = head; ListNode* curr_head = head;//用作小段链表的头 ListNode* curr_tail = NULL;//当前已完成反转部分链表的尾 ListNode* result_head = NULL; while (tmp != NULL) &#123; count++; if (count == k) &#123; ListNode* remaining = tmp-&gt;next; tmp-&gt;next = NULL; curr_head = reverse_List(curr_head);//反转小段链表 if (result_head == NULL) result_head = curr_head; if (curr_tail != NULL) curr_tail-&gt;next = curr_head; while (curr_head-&gt;next != NULL) &#123; curr_head = curr_head-&gt;next; &#125; curr_tail = curr_head; curr_head = remaining; tmp = remaining; count = 0; &#125; else tmp = tmp-&gt;next; &#125; //输入的链表长度不是k的倍数时会剩下未反转的部分链表 if (count != 0 &amp;&amp; curr_tail != NULL) curr_tail-&gt;next = curr_head; //输入的k大于链表长度的情况 else if (count != 0 &amp;&amp; curr_tail == NULL) return head; return result_head; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-032]]></title>
    <url>%2F2018%2F09%2F30%2Fleetcode-032%2F</url>
    <content type="text"><![CDATA[题目Longest Valid Parentheses Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example1 123Input: "(()"Output: 2Explanation: The longest valid parentheses substring is "()" Example2 123Input: ")()())"Output: 4Explanation: The longest valid parentheses substring is "()()" 分析这道题的意思是给出一个只含有小括号符&quot;(&quot;和&quot;)&quot;的字符串，求出这个字符串中能够成功进行括号匹配的子串的长度，虽然看起来与括号匹配类似，但由于是求能够匹配成功的子串，因此难度加大了不少。 解法一开始我致力于在括号匹配算法的基础进行改进，以求得最长的可以匹配的子串。但这个想法似乎很难实现，因为我不知道在括号能够匹配时它的子串中的具体位置，例如： 对于&quot;((()()))&quot;这个字符串，括号匹配算法遍历到第4个字符&#39;)&#39;才能第一次匹配成功,随后在第6，7，8个字符时可以连续匹配成功3次，但是如何知道后两次成功匹配的字符都分别在子串的首尾部呢？这比较难求，我们也不关心这个，因此不如在匹配成功时计算长度。 但是要求出长度也不是那么容易的，因为括号匹配算法遍历字符串时，我们不能预测接下来的字符能否与之前栈里的字符成功匹配，例如： 对于&quot;((()()(()&quot;这个字符串，最大匹配成功的子串长度为4，但要是它后面还有一个字符&#39;)&#39;，即字符串&quot;((()()(())&quot;，那最大匹配成功的子串长度就是8了；如果接下来的字符是&#39;(&#39;，答案就还是4。其中的区别在于，如果两个能成功匹配的子串相邻，那自然就有了更长的符合条件的子串。 那怎么判断相邻的子串呢？考虑到只有遍历到的字符是&#39;)&#39;时才有可能匹配成功，我们可以通过判断匹配后(会弹出栈顶的&#39;(&#39;元素)栈是否为空来入手： 如果栈为空，就代表在这一对匹配的括号前面没有其他符号来阻隔它与之前的子串，即它与之前匹配的子串相邻，可以加长子串了(当然也不一定是前面，毕竟这一对括号可能分别在之前子串的首尾部) 如果栈不为空，那就说明当前匹配的括号与之前子串不相邻，但由于栈中还有&#39;(&#39;字符，可能与之后的字符匹配，因此不需要变化start 算法思路如下： 用变量result和start来记录当前最大匹配的子串长度和当前匹配的子串首字符位置 利用括号匹配算法，遍历字符串，遇到&#39;(&#39;把它的下标压栈，而&#39;)&#39;则不压栈 若遇到&#39;)&#39;，需谨慎处理： 如果栈为空，则由于&#39;)&#39;一定不会与之后的字符匹配，因此前面的子串一定不会与后面的子串相邻了，start = indexOf(&#39;)&#39;) + 1，即现在要匹配的子串首字符从&#39;)&#39;下一个字符开始 如果栈不为空，那一定会匹配(栈里面只有&#39;(&#39;)，因此弹出栈顶，继续判断 如果弹出栈后栈空，则匹配的子串相邻，需要更新result，方法是判断result和当前匹配子串长度哪个大 否则子串不相邻(这是暂时的，因为start还没有变化)，更新result，不需要与之前的子串比较，因为已经比较过了，比较当前匹配的就好 可以找出一些字符串例子来帮助理解这个思路。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;class Solution &#123;public: int longestValidParentheses(string str) &#123; int result = 0, start = 0; stack&lt;int&gt; s; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] == '(') s.push(i); else &#123; if (s.empty()) start = i + 1; else &#123; s.pop(); if (s.empty()) result = max(result, i - start + 1); else result = max(result, i - s.top()); //已经pop过一次了，所以不需要再加1 &#125; &#125; &#125; return result; &#125;&#125;;int main() &#123; Solution s; cout &lt;&lt; s.longestValidParentheses("()(()");&#125; 算法时间复杂度为O(n)，空间复杂度为O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang入门:环境配置]]></title>
    <url>%2F2018%2F09%2F27%2FGolang%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言在前一篇博客中我们学习了如何配置Centos私有云，下一步我们将要学习Go语言编程。 什么是Go语言？ Go语言由Google于2009年发布，它是一种静态强类型、编译型、并发型、解释型的编程语言，并且具有便利的垃圾回收和强大的运行时反射。 Go语言是简洁的和有效率的，实用性很强。 要学习Go语言编程，第一步就是要学习配置需要的相关环境。 Centos安装Golang有两种方法可以安装Golang: 下载最新版本的go1.11.linux-amd64.tar.gz，然后解压并配置环境变量，这种方法相对复杂些 利用系统包管理工具直接下载Golang，这种方法简单。但Golang不是最新版本的，但也不影响使用 安装最新版Golang下载二进制包可以去官网下载，也可以利用wget工具自动下载： 1wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz 然后解压，可以指定解压到的目录： 1sudo tar -zxvf go1.11.linux-amd64.tar.gz -C /opt/ 记得一定要加上-C(大写)这个参数，创建默认文件夹才能被成功解压，否则报错如下： 设置环境变量，sudo vi /etc/profile，在底部加上 12export GOROOT=/opt/goexport PATH=$PATH:$GOROOT/bin 然后source /etc/profile更新环境变量，再使用go version检查配置是否正常： 我们可以使用go env来查看Go的环境变量，其中比较重要的是GOROOT和GOPATH，GOROOT里面放置系统代码和中间文件，而GOPATH可以作为我们的工作空间。GOROOT和GOPATH中都有三个子目录： src:存放被组织成包的源代码(.go .c .h .s等) pkg:存放编译后生成的文件(.a) bin:存放编译后生成的可执行文件 为了方便，可以把bin加入到 $PATH 变量中，便于直接运行Go程序 创建工作空间： 1mkdir $HOME/gowork 修改配置文件，sudo vi /etc/profile： 12export GOPATH=$HOME/goworkexport PATH=$PATH:$GOPATH/bin 更新配置文件后可以通过go env来查看是否设置成功。 利用包管理工具安装Golang1sudo yum install golang 查看Golang安装的目录： 1rpm -ql golang |more 测试安装： 1go version 然后是创建工作空间和配置GOPATH、PATH这两个环境变量，步骤同上。 安装工具和插件安装VSCode安装过程参考官方给出的教程： 123456sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo'yum check-updatesudo yum install code 然后就可以打开VSCode了。 编写Hello，World首先创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 然后使用VSCode编写一个hello.go文件(VSCode会提示安装Go相关插件)： 1234567package mainimport "fmt"func main() &#123; fmt.Printf("hello, world\n")&#125; 在终端运行： 安装git客户端由于Go语言的插件主要在github上，因此git客户端必不可少 1sudo yum install git 但这样安装的git太老，总觉得用着不舒服，因此我选择更新： 首先移除安装的旧版本 1sudo yum remove git 安装所需的软件包 123sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develsudo yum install gcc perl-ExtUtils-MakeMaker 去官网下载安装包并解压 12wget https://www.kernel.org/pub/software/scm/git/git-2.9.2.tar.gztar -zxvf git-2.9.2.tar.gz 编译安装 123cd git-2.9.2make prefix=/usr/local/git allsudo make prefix=/usr/local/git install 配置环境变量，在/etc/profile中添加 1export PATH=$PATH:/usr/local/git/bin 更新环境变量 1source /etc/profile 如果此时查看git仍是旧版本，执行以下语句： 1234sudo yum remove -y gitsource /etc/bashrccd ~/git --version 安装Go的一些工具当我们进入VSCode打开hello.go时，VSCode会提示我们安装go-outline，点击Install却失败了，需要手动安装： 下载源码到本地 123456# 创建文件夹mkdir -p $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 安装工具包 1go install $GOPATH/src/golang.org/x/tools/go/buildutil 重启VSCode，按照提示安装即可 安装运行 hello world 1go install github.com/github-user/hello 安装go tour1go get -u github.com/Go-zh/tour/gotour 安装好之后会在工作空间的 bin 目录中创建一个 gotour 可执行文件 运行Go语言之旅 1go tool tour 绑定git远程仓库之前我们已经在github.com文件夹下创建了与自己的github账户同名的文件夹，现在需要把这个文件夹绑定git上的远程仓库，用来保存我们以后编写的Go语言代码。 在github上创建一个仓库用于同步之后就可以来绑定远程仓库了，本地执行指令如下： 1234git init git config --global user.name "xxx"git config --global user.email "xxx@xxx"git remote add origin your_repo_url 以上传hello文件夹为例： 123git add hello/git commit -m 'first commit'git push -u origin master git相关指令详见git学习笔记]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-042]]></title>
    <url>%2F2018%2F09%2F23%2Fleetcode-042%2F</url>
    <content type="text"><![CDATA[题目Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 分析这道题目的意思是给出一个数组来代表柱子的高度，让我们计算可以有多少水陷在这些柱子围成的空隙中，注意最左边和最右边是没有阻挡作用的。 解法一要让水陷入，就必须有左右各一个柱子比中间的所有柱子都高，因此我的想法是用一个bottom变量来记录矮一点的左边柱子，用一个栈stack来存放两个柱子中的矮柱子高度，当遍历到高度&gt;=bottom的柱子时就形成了一个可以陷入水的空隙，再遍历数组去找到所有可能的这种空隙。算法思路如下： 数组arr长度&lt;=2时无法形成空隙，必为0 bottom = arr[0]，stack&lt;int&gt; s 1234for i : arr if (bottom &lt;= arr[i]) //计算空隙中的水量 else s.push(arr[i]) 而计算空隙中的水量也很简单，其实就是个计算面积的问题：以矮柱子bottom的高度为宽，中间柱子数bar_num为宽计算整个长方形面积，再减去中间柱子的总高度rock即可：water = bottom * bar_num - rock 要得到中间的柱子数bar_num和中间柱子的总高度rock，只需一步步弹出栈即可 循环部分的代码如下： 1234567891011121314151617for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i;&#125; else s.push(height[i]);&#125; 但这个思路还没有完全解决问题，因为我假设的bottom是左边的柱子，然后通过找高度&gt;=bottom的柱子来寻找空隙，但是如果没有高度&gt;=bottom的柱子也是可能存在空隙的，比如例子中最右边的那个空隙。解决办法是记录最高的那个柱子，然后再从右边以同样的方法遍历，直到最高的这个柱子为止，来寻找那些第一次遍历时错过的空隙(十分暴力的解法)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; stack&lt;int&gt; s; int bottom = height[0]; int top = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; &#125; else s.push(height[i]); &#125; stack&lt;int&gt; s2; bottom = height[height.size() - 1]; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s2.empty()) &#123; int tmp = s2.top(); s2.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; &#125; else s2.push(height[i]); &#125; return result; &#125; &#125;; 这种解法的时间复杂度是O(n2)，而且最坏情况(最高的柱子为最左边的柱子)下需要遍历两次，效率很低了，必须得优化下。 解法二我的优化思路是从堆栈入手，一开始我使用栈是因为想用它来管理那些中间的矮柱子，但其实好像并不需要，因为我只需要得到3条关于它们的信息： 高度&lt;=bottom 矮柱子个数 矮柱子总高度 这3条信息在遍历的过程中都可以得到，而额外弹出栈还需要再套一个循环，完全没必要，因此使用堆栈这一点是显而易见需要优化的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; int bottom = height[0]; int top = 0; int rock = 0, bar_num = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; bottom = height[height.size() - 1]; rock = bar_num = 0; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; return result; &#125; &#125;;int main() &#123; vector&lt;int&gt; test = &#123;0,1,0,2,1,0,1,3,2,1,2,1&#125;; Solution s; cout &lt;&lt; s.trap(test);&#125; 优化后的代码时间复杂度为O(n)，但是最坏情况下还是可能遍历两次，因此我还需要找出一次遍历就能解决问题的算法，这可能要同时从两边开始遍历。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-023]]></title>
    <url>%2F2018%2F09%2F16%2Fleetcode-023%2F</url>
    <content type="text"><![CDATA[题目Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 分析这道题的描述十分简单，要求也清晰，就是要我们把k个有序的链表合并成一个有序的链表，我们熟悉的应该是合并两个链表，但这里链表数目增加了，算法的设计就自然变难了。 合并两个有序链表我们先回顾经典的合并两个链表的问题，最好的方法如下： 从合并两个链表头节点开始，比较两个链表头节点值的大小，若list的头节点值更小，则把result_list的头指针指向这个节点，并把list的头节点往后移一次 循环判断剩余节点：继续比较两个链表头节点大小，若list的头节点值更小，则把result_list尾节点的next指针指向list的头节点，并把list的头节点往后移一次。推出循环的条件是两个链表中有一个头节点指针为空 使result_list的尾节点的next指针指向不为空的那个链表的头节点 代码如下： 1234567891011121314151617181920212223242526272829//list1和list2分别指向要合并的两个有序链表的头节点 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; 这种方法的时间复杂度最大为O(n)，而空间复杂度为O(1)，效率挺不错了。 合并k个有序链表有了前面的基础后再回到这个题目，很容易会想采用同样的方法：比较这k个链表的头节点的值，然后把最小的那个头节点作为合并后链表的头节点，再不断循环。但这样的话每得到一个正确位置的节点就要循环一次，开销太大了，不适用于此种情况。 鉴于最近课上一直在讲分治算法，很自然地我就想到了用分治法来解决这个问题。既然一次性合并k个链表是困难的，而一次性合并两个链表是容易的，那使用分治法来把这个大问题(合并k个)分成很多个小问题(合并2个)，再一一解决，就很容易了。 解法按照前面的思路，解决方法可以分为以下几个步骤： 使用二分法把这k个链表不断递归分成两个子部分，最终得到的子部分所含有的链表数全为1，这是最底层 最底层不需要合并，因为一个链表的合并自然就是它本身 向上递归，倒数第二层的合并全是两个有序链表的合并，这在之前已经得到解决，合并之后链表数减半，再继续递归合并，一层层合并完就得到了最终的链表 这种方法的时间复杂度是O(Nlogk)，总共分成了logk层，而每一层中合并两个有序链表总共的时间复杂度为O(N)，因此总的就为O(Nlogk) 至于空间复杂度，我们在合并两个链表的过程中并没有额外开辟新的空间，而是仅通过改变指针的指向就实现了合并，因此为O(1) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.Example:Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;private: //合并两个有序链表 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; ListNode* mergelist(vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123; int mid = (left + right) / 2; if (left &lt; right) &#123; ListNode* list1 = mergelist(lists, left, mid); ListNode* list2 = mergelist(lists, mid + 1, right); ListNode* mergedList = merge(list1, list2); return mergedList; &#125; return lists[left]; &#125;public: //思路:先采用分治法把问题分成两个子问题(不断向下递归分解)，到最后一层得到的是单独的一条链表 // 合并两条链表为一条，向上递归继续合并 // 思路很类似于归并排序 ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; return mergelist(lists, 0, lists.size() - 1); &#125;&#125;;int main() &#123; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F09%2F13%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git学习笔记 前言git作为世界上最先进的分布式版本控制系统，为我们管理自己的代码提供了很多便利，它的指令强大且复杂多样，而我一直都只用着git add、git push等最简单的指令，十分惭愧。希望这篇笔记能帮助我之后的git学习，也帮助到有需要的同学。 配置git12345678910111213#查看版本信息git --version#查看配置信息git config --list#查看配置信息，输入后会启动默认的git编辑器，可以编辑用户名和邮箱，#git的配置文件在C:Users\用户名\目录下，是.gitconfig文件git config -e --global#分别为设置用户名和邮箱，如果不加最后面的参数，就是查看用户名和邮箱git config --global user.name "xxx"git config --global user.email "xxx@xxx" 新建仓库12345#在指定目录初始化仓库，会创建一个.git隐藏文件夹，默认在当前目录下初始化仓库git init [dir]#下载一个项目和代码历史，会在本地当前目录自动创建一个项目名的文件夹，用于存放项目git clone [url] 增加和删除文件123456789101112131415161718#添加文件到暂存区，参数是一个.或-A的话为添加所有文件git add [file1] [file2]...#添加指定目录到暂存区，包括该目录的子目录git add [dir]#添加每个变化前，都会要求确认#对于同一个文件的多处变化，可以实现分次提交git add -p#删除工作区文件，并将这次删除放入暂存区git rm [file1] [file2]...#把暂存区的文件删除，但该文件会保留在工作区git rm --cached [file]#重命名文件，并将这次命名放入暂存区git mv [file-original] [file-renamed] 提交修改123456789101112131415161718#提交暂存区到仓库区，message用于描述这次提交git commit -m [message]#提交暂存区的指定文件git commit [file1] [file2]... -m [message]#提交工作区自上次commit之后的变化，直接到仓库区git commit -a#提交时显示所有diff信息git commit -v#使用一次新的commit，替代上一次提交#如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]#重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839#列出所有本地分支git branch#列出所有远程分支git branch -r#列出所有本地分支和远程分支git branch -a#新建一个分支，但依然停留在当前分支git branch [branch-name]#新建一个分支，并切换到该分支git checkout -b [branch]#新建一个分支，指向指定commitgit branch [branch] [commit]#新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]#切换到指定分支，并更新工作区git checkout [branch-name]#建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]#合并指定分支到当前分支git merge [branch]#选择一个commit，合并进当前分支git cherry-pick [commit]#删除分支git branch -d [branch-name]#删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526#列出所有taggit tag#新建一个tag在当前commitgit tag [tag]#新建一个tag在指定commitgit tag [tag] [commit]#删除本地taggit tag -d [tag]#删除远程taggit push origin :refs/tags/[tagName]#查看tag信息git show [tag]#提交指定taggit push [remote] [tag]#提交所有taggit push [remote] --tags#新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#显示有变更的文件git status#显示当前分支的版本历史git log#显示commit历史，以及每次commit发生变更的文件git log --stat#搜索提交历史，根据关键词git log -S [keyword]#显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s#显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature#显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]#显示指定文件相关的每一次diffgit log -p [file]#显示过去5次提交git log -5 --pretty --oneline#显示所有提交过的用户，按提交次数排序git shortlog -sn#显示指定文件是什么人在什么时间修改过git blame [file]#显示暂存区和工作区的差异git diff#显示暂存区和上一个commit的差异git diff --cached [file]#显示工作区与当前分支最新commit之间的差异git diff HEAD#显示两次提交之间的差异git diff [first-branch]...[second-branch]#显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"#显示某次提交的元数据和内容变化git show [commit]#显示某次提交发生变化的文件git show --name-only [commit]#显示某次提交时，某个文件的内容git show [commit]:[filename]#显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223#下载远程仓库的所有变动git fetch [remote]#显示所有远程仓库git remote -v#显示某个远程仓库的信息git remote show [remote]#增加一个新的远程仓库，并命名git remote add [shortname] [url]#取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]#上传本地指定分支到远程仓库git push [remote] [branch]#强行推送当前分支到远程仓库，即使有冲突git push [remote] --force#推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031#恢复暂存区的指定文件到工作区git checkout [file]#恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]#恢复暂存区的所有文件到工作区git checkout .#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]#重置暂存区与工作区，与上一次commit保持一致git reset --hard#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]#重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]#新建一个commit，用来撤销指定commit#后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]#暂时将未提交的变化移除，稍后再移入git stashgit stash pop 理解工作区和暂存区先上图： 工作区就是电脑上的文件夹 在工作区中有一个隐藏的.git文件夹，它不属于工作区，是git的版本库，这里包含所有git操作所需要的东西 版本库中最重要的东西就是暂存区(index/stage)，还有自动创建的第一个分支master和指向master的指针HEAD 下面通过简单的指令来理解暂存区的概念： 首先git init初始化一个空的版本库，git会自动帮我们创建一个分支master，此时的git commit就是往master分支上修改。假设工作区已经有一个readme.txt文件，那此时工作区有一个文件，暂存区和版本库都没有文件： 我们先对readme.txt进行修改，内容随意；再在工作区新增一个文件LICENSE，然后使用git status来查看状态： 可以看到readme.txt被修改了，而LICENSE文件还没有被git add过，因此是Untracked的 使用git add来把这两个文件从工作区复制到暂存区，然后用git status查看状态： 此时暂存区的状态如下图： 然后使用git commit来把暂存区中的文件提交到分支： 此时的版本库如下，暂存区已经没有任何内容了： gitignore有时候我们需要把一些文件放到git的工作区当中，但是又不想提交它们，.gitignore配置文件就是用来忽略文件的。 不用担心不会写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 需要注意的是，.gitignore文件也是需要放入到版本库中的，并且也可以对它进行版本管理。前面我们知道git status会显示一些Untracked的文件，看起来很不舒服，但如果我们利用.gitignore来忽略该文件，git status就会显示working directory clean了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-031]]></title>
    <url>%2F2018%2F09%2F09%2Fleetcode-031%2F</url>
    <content type="text"><![CDATA[题目Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1234&gt; 1,2,3 → 1,3,2&gt; 3,2,1 → 1,2,3&gt; 1,1,5 → 1,5,1&gt; 分析这道题目的意思是给出一个序列，要求给出它的下一个置换，即按照字典序比它大的最小的那个序列。如果找不到这样的置换，那么就输出最小的那个序列(即按升序排序)。in-place的意思是让我们在交换元素时不要花费过多空间，花费的额外空间只能是常量。 解法首先要判断是否有下一个置换，这可能不太直观，但判断没有下一个置换是很容易的：当序列已经是降序时就已经是最大的序列了，当然就不存在下一个置换，此时只要将它反过来就可以得到所求序列。因此，只要序列不是降序的，那么置换就存在。 要判断序列是否是降序，可以采取从后往前遍历的方式，如果相邻的两个元素，后面那个(right)一直比前面那个(left)小，那么就是降序的。当我们找到这样两个元素:right &gt; left时，就找到求下一个置换的突破口了，因为这意味着在left后面的那一段子序列都是降序的，已经不存在下一个置换了，即是时候把left这个位置的元素的值变大了。 找到这样的left之后我的第一个想法是把它与后面那段子序列中比它大的最小的那个元素交换位置，再把子序列排序，这样就得到了比原始序列大的最小的序列，即下一个置换。这样的确是可以得到答案的，但是这样我们就使用了排序了，复杂度就成了O(n2)，算法自然就没那么好了。 实际上，我们知道那段子序列是降序的，那么只要把它反过来就是一个升序的序列了，这样的时间复杂度是O(n)，排好序后再去找比left大的最小的那个元素，交换它们的位置就好了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 1) return; bool flag = false; //是否存在下一个置换 int index; for (index = len - 1; index &gt; 0; --index) &#123;//找left和right if (nums[index] &gt; nums[index - 1]) &#123; flag = true; break; &#125; &#125; if (flag == false) reverse(nums.begin(), nums.end());//没有下一个置换 reverse(nums.begin() + index, nums.end()); int small_index = -1; for (int i = index; i &lt; len; ++i) &#123;//找比left大的最小元素 if (nums[i] &gt; nums[index - 1]) &#123; if (small_index == -1) small_index = i; else if (nums[i] &lt; nums[small_index]) small_index = i; &#125; &#125; int temp = nums[small_index]; nums[small_index] = nums[index - 1]; nums[index - 1] = temp; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox + CentOS让PC提供云服务]]></title>
    <url>%2F2018%2F09%2F09%2Fcentos-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BA%91%2F</url>
    <content type="text"><![CDATA[前期准备安装Git客户端直接百度git for windows即可找到官网的下载链接，安装好对应系统版本后应在任何地方右键鼠标都会出现git bash here： 安装VirtualBox直接到官网下载最新版本的安装包并安装，在Downloads界面选择windows版本的： 配置VirtualBox 点击管理-&gt;全局设定-&gt;常规，设置默认虚拟电脑存储位置，最好把默认的C盘路径改掉，方便自己查找，同时也不消耗系统盘空间。 创建虚拟机内部虚拟网络，使得 Vbox 内部虚拟机可以通过它，实现虚拟机之间、虚拟机与主机的通讯： 管理-&gt;主机网络管理器-&gt;创建，创建一块虚拟网卡，并把IPv4地址设为：192.168.100.1/24，这是虚拟内部网络host的默认地址(这一步好像有同学创建不了，据说回退到4.3版本可以，但他直接换Vmware了…) 用cmd输入ipconfig可以查看到刚创建的网卡VirtualBox Host-Only Network #2: 第一个是本机的网卡，可以通过它看到本机的ip地址，这在之后会有用到。 下载CentOS镜像直接到官网下载Minimal ISO镜像即可，点击Minimal ISO后进入下载界面选第一个就好了 安装虚拟机安装第一个虚拟机进入VirtualBox，点击新建，在名称那里输入centos，就会自动选择类型和版本了： 注意：如果没有64位选择的话，有几种可能： 电脑不是64位的 电脑未开启硬件可虚拟化，具体解决方法是进入BIOS把对应可虚拟化的选项设为enable,一般是Intel Virtual Technology 电脑开启了hyper-v，解决方法是进入控制面板-&gt;卸载程序-&gt;启用或关闭Windows功能，取消选择hyper-v即可，重启就可以了 选好后继续安装，点击下一步，分配内存依据自己电脑配置，2G差不多了，然后创建虚拟硬盘，选择现在创建虚拟硬盘，文件类型选择VDI，动态分配和固定大小按自己个人喜好选就好，文件位置一般会自动选择在之前设置的默认虚拟电脑位置文件夹下，大小选择分配30G，方便以后扩展，然后就创建好了。 接下来选择刚创建的虚拟机点击设置，在系统那里把启动顺序设为硬盘第一(不然装好系统后再次启动可能又会进入安装系统界面)；存储那里点击没有盘片： 然后选择之前下载的Minimal ISO；在网络那里第一块网卡默认NAT，第二块网卡选择Host-Only,接口就是前面创建的虚拟网卡： 设置好之后就可以点击启动来安装系统了，选择Install Centos 7，选择语言后点击继续， 在这个界面要注意两个地方，一个是黄色感叹号那个选项，点击进入后选择安装位置，就选之前分配的虚拟硬盘，然后还要注意点击NETWORK &amp; HOST NAME，进去把网络连接打开， 然后就可以安装了，在这个过程中还可以设置root密码和添加用户。 安装好之后进入系统，首先进行升级OS内核： 获取wget：sudo yum install wget 配置源163源或者阿里云源： 具体操作为(以163源为例): 备份/etc/yum.repos.d/CentOS-Base.repo(即改名): 1sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 进入yum源配置文件：cd /etc/yum.repos.d 下载网易163源： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 下载好后把163源设置为默认源： 1sudo mv CentOS7-Base-163.repo CentOS-Base.repo 然后生成缓存： 12yum clean allyum makecache 升级OS内核：sudo yum update 升级内核之后进行下一步，检查网卡配置： 输入nmtui，配置第二块网卡地址： 选择第一项，然后选择第二个网卡的edit: 在IPv4那里点击Show，在下面的Addresses点击Add，配置第二块网卡地址，格式如192.168.100.50/24, 然后退出nmtui界面。 ping主机，如ping 192.168.100.1 第一个虚拟机的操作完成，关闭虚拟机。 安装第二个虚拟机利用虚拟机复制功能，直接获取新虚拟机：右键之前创建的虚拟机，选择复制，为新虚拟机取名并一定要选择重新初始化所有网卡的 MAC 地址： 然后选链接复制，完成。 启动新的虚拟机，配置主机名和第二块网卡： 配置主机名要使用sudo nmtui，修改网卡地址操作与之前相同，但地址变为了192.168.100.100/24。改好后回退到nmtui的第一个界面，选择第二项来激活第二个网卡，两个网卡名前面都有*号就表示都已激活。 再回到nmtui的第一个界面选第三项，更改主机名，改完后退出，重启。 重启后需重新激活第二个网卡，在windows上进入git bash，ping刚才修改的地址，即ping 192.168.100.100： 通过ssh来访问该虚拟机。到官网下载putty,安装后启动，输入虚拟机第二块网卡的地址，点击open即可连接到虚拟机(windows需启动git bash)：经老师提示发现windows安装了git bash(Unix命令行模拟环境)就有ssh客户端了，可以通过git bash来进行ssh连接，例如我的虚拟机地址是192.168.100.4,则ssh连接的命令为 1ssh [用户名]@[虚拟机地址] 相应操作为： 此时已经差不多完成了，能通过ssh访问到虚拟机就已经搭好私有云环境了，但为了centos更方便使用，继续安装centos桌面： 首先重新配置虚拟机的CPU、内存、显存，因为使用centos桌面对配置要求更高。先关闭虚拟机，选择对应的虚拟机后点击设置来进行配置，CPU 1~2个，内存2G或4G，显存越大越好，同时勾选启动3D加速 启动虚拟机，安装桌面sudo yum groupinstall &quot;GNOME Desktop&quot;,这个很大，耗费时间比较长，需要耐心等待，如果下载不成功，可能需要更换yum源 安装好后设置启动目标为桌面，然后重启: 1ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 此时我们已经可以通过图形化界面来使用centos，但因为虚拟机对鼠标的捕获很不友好，导致使用很不方便，而且也不能全屏，那么就需要安装VirtualBox的扩展功能了： 先安装kernel-devel和gcc：sudo yum install -y kernel-devel gcc 点击VirtuaBox的设备-&gt;安装增强功能，此时可能会报错： 这个错误挺常见的，也容易解决： 弹出后再选择安装增强功能就好了： 点击Run即可开始安装。 装好之后重启时突然报错：Failed to load selinux policy.然后就一直卡在进度条满的状态，无法进入系统，重启很多次也没用，上网查之后发现是因为/etc/selinux/config配置文件不对，虽然我没有修改这个文件，但还是试了试网上方法： 首先在启动时选择启动项的界面按e进入grub编辑界面： 进入grub编辑界面后找到linux16那一行，在最后面的LANG=zh_CN.UTF-8之后空格，加上selinux=0，如上图所示，然后Ctrl + X启动即可进入系统 进入系统后当然要解决这个问题了，sudo vi /etc/selinux/config,可以看到SELINUX=enforcing,我们要做的是改成disabled,且记SELINUXTYPE=targeted原始配置不用改！ 解决上个那个错误后重启就发现增强功能已经装好了，鼠标可以自由移动，也可以全屏了。 接下来安装Google Chrome(可选)： 直接去官网下载可能会被墙，可以移步国内新浪科技网下载，选择正式版RPM，直接下载 进入下载的安装包所在路径，利用yum来安装sudo yum localinstall google-chrome-stable_current_x86_64.rpm,yum会自动分析依赖，并完成安装 在这里插入一个可能的问题：有了图形化界面后我们就可以很方便地通过设置来把第二块网卡设置自动激活了，避免每次开机都要手动激活的痛苦。在这个过程中我发现了一个问题，貌似系统把我之前设置的第二块网卡的IPv4地址修改了： 现在的地址是192.168.100.4，而之前我是把它设置成了192.168.100.100，而且貌似修改后重启又会变成这个，干脆就使用这个地址吧，在使用ssh访问的时候要注意IP地址的变化。 使用远程桌面访问虚拟机安装扩展包首先关闭所有虚拟机，然后去VirtualBox官网下载扩展包，在下载界面选择VirtualBox 5.2.18 Oracle VM VirtualBox Extension Pack(扩展包版本要与VBox版本相同)： 下载好后点击管理-&gt;全局设定-&gt;扩展，点击添加新包，找到正确的扩展包并添加 装好扩展包后重启Windows(注意不是重启虚拟机) 设置虚拟机端口点击对应的虚拟机，点击设置后选择显示，在远程桌面那里启用服务器，然后设置端口号，这里需要注意每台虚拟机的端口号必须不同，因此最好手动修改端口号而不是使用默认。认证方式选择空，我使用外部的认证方式无法连接： 使用远程桌面直接在win10小娜姐姐那里输入远程，就可以启动windows自带的远程桌面连接，在计算机一栏那里输入的地址为本机IP地址:端口号，注意是本机地址，不是虚拟机的地址！！ 再点击连接，就成功啦： 注： 部分同学发现在不开启第二块网卡时虚拟机可以ping到192.168.100.1,但开启了第二块网卡之后就不行了，经大佬提示后发现是windows防火墙的问题…关闭之后就好了，不过没有必要，因为已经可以实现远程访问了。]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>配置环境</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-004]]></title>
    <url>%2F2018%2F09%2F07%2Fleetcode-004%2F</url>
    <content type="text"><![CDATA[题目Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析这个题目的意思是给出两个已排好序的数组，要求我们给出包含两个数组中所有数的中位数。我首先想到的方法是利用两个循环变量i， j来同时遍历这两个数组 nums1、nums2 ，当 nums1[i] &lt; nums2[j]时i++ ，否则 j++ ，并且选出小的那个数，直到总共遍历了(m + n) / 2 个元素，有点类似于合并两个有序链表的算法。此时就可以找到中位数了： 如果总数是奇数，那么中位数就是最后一个选出来的数 如果总数是偶数，那么中位数就是最后两个选出来的数的平均数 代码如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m == 0) return n % 2 == 0 ? (nums2[n/2 - 1] + nums2[n/2]) / 2.0 : nums2[n/2]; else if (n == 0) return m % 2 == 0 ? (nums1[m/2 - 1] + nums1[m/2]) / 2.0 : nums1[m/2]; int mid = (m + n) / 2; vector&lt;int&gt; sortedArr; for (int i = 0, j = 0; i + j &lt;= mid; ) &#123; if (i == m) sortedArr.push_back(nums2[j++]); else if (j == n) sortedArr.push_back(nums1[i++]); else if (nums1[i] &lt;= nums2[j]) sortedArr.push_back(nums1[i++]); else sortedArr.push_back(nums2[j++]); &#125; return (m + n) % 2 == 0 ? (sortedArr[mid - 1] + sortedArr[mid]) / 2.0 : sortedArr[mid]; &#125;&#125;; 这种方法的时间复杂度是 O((m + n) / 2), 并不满足题目要求的O(log(m + n)) ,因此还是得找效率更高的方法。 解法实际上看到有 log 的复杂度，我们就应该想到要使用分治法，但这题要怎么使用二分法来把两个有序数组合并起来并找到中位数呢？其实，我们并不需要非得这样做，从中位数的定义入手，我们可以知道，如果数组中的一个数在把数组分成长度相等的两部分，且一部分的数值总大于等于另一部分，那这个数就是中位数，即： 把数组nums1 分成两个部分： 1nums1[0],nums1[1]...nums1[i - 1] | nums1[i], nums1[i + 1]...nums[m - 1] 左边部分数目为i，右边部分数目为m - i且 max(left) &lt;= min(right)当i = m - i 时（nums1[i - 1] + nums1[i]) / 2就是中位数 同理，我们无需把两个数组合并起来排序再找中位数，只需要把它们分成两个长度相等的部分，并使max(left) &lt;= min(right)就可以找到中位数了，即： 12nums1[0]...nums1[i - 1] | nums1[i]...nums1[m - 1]nums2[0]...nums2[j - 1] | nums2[j]...nums2[n - 1] 长度相等即: i + j = m - i + n - j ,当总长度为奇数时左边会比右边少一个 max(left) &lt;= min(right) 即: nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]。 那么现在我们的问题就变成了找到这样的 i和j来满足上面两个条件。 i 的范围是 [0, m] ，由第一个条件可以知道 j = (m + n) / 2 - i ,当 m &lt;= n 时 j &gt;= 0 ，否则为负数 现在我们就可以用二分法来解决这个问题了，伪代码如下： 123456781.imin = 0, imax = m2.j = (m + n) / 2 - i3. if nums1[i - 1] &gt; nums2[j] imax = i - 1 //i较大，因此需要减小遍历i的范围 else if nums2[j - 1] &gt; nums1[i] imin = i + 1 //i较小，因此需要增大遍历i的范围 else //找到了合适的i if (m + n) % 2 == 0 return (max(left) + min(right)) / 2.0 else return min(right) 当然我们需要考虑临界问题：i = 0, i = m, j = 0, j = n时怎么办？访问nums1[i - 1],nums2[j],nums2[j - 1],nums1[i]是可能越界的。 实际上，由j = (m + n) / 2 - i ，0 &lt; i &lt; m， n &gt;= m可知0 &lt; j &lt; n，因此我们只需要判断i的临界范围就可以了。 对于nums1[i - 1] &gt; nums2[j],需加上i &gt; imin的判断，防止读取到nums1[-1]和nums2[n] 对于nums2[j - 1] &gt; nums1[i],需加上i &lt; imax的判断，防止读取到nums2[-1]和nums1[m] 最终代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m &gt; n) &#123; //确保n&gt;=m nums1.swap(nums2); int temp = m; m = n; n = temp; &#125; int imin = 0, imax = m, mid = (m + n) / 2; while (imin &lt;= imax) &#123; int i = (imin + imax) / 2; int j = mid - i; if (i &gt; imin &amp;&amp; nums1[i - 1] &gt; nums2[j]) imax = i - 1; else if (i &lt; imax &amp;&amp; nums2[j - 1] &gt; nums1[i]) imin = i + 1; else &#123;//找到了使max(left) &lt; min(right)的i int minRight; if (i == m) minRight = nums2[j]; else if (j == n) minRight = nums1[i]; else minRight = min(nums1[i], nums2[j]); if ((m + n) % 2 != 0) return minRight; int maxLeft; if (i == 0) maxLeft = nums2[j - 1]; else if (j == 0) maxLeft = nums1[i - 1]; else maxLeft = max(nums1[i - 1], nums2[j - 1]); return (maxLeft + minRight) / 2.0; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
</search>
