<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MD5算法实现]]></title>
    <url>%2F2018%2F12%2F07%2FMD5%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文阐述DES算法的基本原理及其C++实现方法，并给出源代码 算法原理概述MD5即Message-Digest Algorithm 5 (信息-摘要算法 5) ，是一种被广泛使用的密码散列(hash)函数，它使用小端模式，输入任意不定长的消息，产生的是128位(16个字节)的散列值(hash value)，用于确保信息传输的完整性和一致性。 MD5算法不是足够安全的，可以找到两个不同的512位的块，它们通过的MD5的hash值相同 但对于有意义的消息，还没有两个不同的消息，它们的MD5的hash值相同 总体结构MD5算法的基本流程如下图所示： 可以分成几个流程： 填充 分块 循环压缩 得出结果 使用unsigned char作为byte，unsigned int作为bit32 模块分解填充算法的输入我使用字符串，而一个字符占一个字节(8位)，而填充后的消息位数是512位(64字节)的倍数，因此可以按字节来填充，填充需要注意的是最后8个字节要使用原始消息长度的低8个字节来填充，其余需要填充的部分，第一个字节使用0x80，其余的字节都使用0x00。 计算填充字节数的方法如下： 1234//count表示要填充的字节数int count = length % 64;if (count &lt; 56) count = 64 - 8 - count;else count = 128 - 8 - count; 中间填充0x80，0x00就不必赘述，需要注意填充原始消息长度的低8个字节这个操作，要按照小端存储来把长度转为8个连续的字节，可以采用移位运算&gt;&gt;来帮助实现。 填充完成后，消息长度为64k字节，为了方便之后的步骤，还需要把消息分块。 分块分块操作主要是为了把填充好的消息分割成每64字节一组，也可以表示成一组16个32位的字(bit32)。 我使用vector&lt;bit32&gt;来存储每个分组里面的32位字，再用一个vector来存放所有的分组，因此最终分块后的消息存放在vector&lt;vector&lt;bit32&gt; &gt;中(vector&lt;bit32&gt;长度固定为16) 需要注意，填充后的消息中按byte存储，因此需要把连续的4个byte转成bit32，这里又需要按照小端存储的模式，比如4个byte值分别为0x01,0x02,0x03,0x04，转成bit32的值为0x04030201。可以借助左移位运算符&lt;&lt;来实现。 循环压缩这一部分包含了MD5算法进行加密的主要操作。 得出结果经过前面的操作，我们已经得到了4个bit32的结果，但最直白的输出最好是字符串，许多在线工具也是把计算结果转成了32位长度的16进制字符串，便于使用。 要得到16进制字符串类型的结果，首先需要把这4个bit32转成16个byte，再把每一个byte用两位16进制字符来表示。 把bit32转成byte的过程又一次需要用到小端存储模式： 1234567for (int i = 0; i &lt; 4; ++i) &#123; //利用了小端编码 MD5[i * 4 + 0] = CV[i] &amp; 0xff; MD5[i * 4 + 1] = (CV[i] &gt;&gt; 8) &amp; 0xff; MD5[i * 4 + 2] = (CV[i] &gt;&gt; 16) &amp; 0xff; MD5[i * 4 + 3] = (CV[i] &gt;&gt; 24) &amp; 0xff;&#125; 之后输出每一个byte，分别计算出它除以16的商和余数即可： 123456789101112char HEX[16] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;;for (int i = 0; i &lt; 16; ++i) &#123; byte quotient = MD5[i] / 16; byte remainder = MD5[i] % 16; str.append(1, HEX[quotient]); str.append(1, HEX[remainder]);&#125; 最终得到的是一个长度为32的16进制字符串。 数据结构首先最重要的是表示方法，由于C++里char占8位，int占32位，因此分别使用unsigned char和unsigned int来表示byte和bit32是很合适的。 此外，要存放消息，使用vector这个数据结构十分方便，对每一个分块使用vector&lt;bit32&gt;来存放16个bit32，所有的分块存放在一个vector中方便检查填充和分块是否出错。 此外，用到了MD5算法固定使用的一些表： 12345678910111213141516171819202122//T表,共64个元素，每个元素为32位字，也称为加法常数bit32 T[64] = &#123; 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391&#125;;//s表，各次迭代运算采用的左循环移位的s值byte s[64] = &#123; 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21&#125;; 源代码在此贴出MD5算法主要部分的源码，完整源码见github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include "MD5.hpp"#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;using std::vector;using std::string;//存放填充完成后的原始消息//每个分组512位，即16个32位的字vector&lt;vector&lt;bit32&gt; &gt; groups;//128位的MD5缓冲区//表示为4个32位寄存器bit32 CV[4] = &#123;0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476&#125;;//缓冲区初始向量IVbit32 IV[4] = &#123;0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476&#125;;//加密结果，长度为16的字符串byte MD5[16];//填充函数//输入为字符串类型的原始消息和消息长度void padding(byte* input, int length) &#123; //由于输入的每一个字符占一个字节(8位) //因此按字节填充，而不是按位填充 //每一组64字节，最后一组的8个字节另外填 //count表示要填充的字节数 int count = length % 64; if (count &lt; 56) count = 64 - 8 - count; else count = 128 - 8 - count; //填充操作 byte* paddingInput = new byte[length + count + 8]; memcpy(paddingInput, input, length); paddingInput[length] = 0x80; for (int i = length + 1; i &lt; length + count - 8; ++i) &#123; paddingInput[i] = 0x00; &#125; //再向填充好的消息尾部附加消息长度的低8个字节 //int转byte要注意小端存储 for (int i = 0; i &lt; 8; ++i) &#123; //用((length * 8) &gt;&gt; (i * 8)) &amp; 0xff出现了奇怪的结果 //改用除法 paddingInput[length + count + i] = ((byte)((length * 8) / pow(2, (i * 8)))) &amp; 0xff; &#125; /* std::cout &lt;&lt; count + 8 &lt;&lt; std::endl; for (int i = 0; i &lt; length + count + 8; ++i) std::cout &lt;&lt; (int)paddingInput[i] &lt;&lt; " "; std::cout &lt;&lt; std::endl; */ vector&lt;bit32&gt; group; group.reserve(16); for (int i = 0, flag = 0; i &lt; length + count + 8; i += 4) &#123; bit32 word = 0; //4个byte转成一个int，采用小端存储 //如0x01,0x02,0x03,0x04 //int为0x04030201 for (int j = 0; j &lt; 4; ++j) &#123; word |= (paddingInput[i + j] &lt;&lt; (j * 8)); &#125; group.push_back(word); flag++; if (flag == 16) &#123; groups.push_back(group); flag = 0; group.clear(); &#125; &#125; &#125;//压缩函数//对每一个512位(16个32位字)的分组进行压缩//上一轮压缩的128位结果作为下一轮的CV输入//最终的结果存放在缓冲区中void HMD5() &#123; for (int i = 0; i &lt; groups.size(); ++i) &#123; bit32 A = CV[0]; bit32 B = CV[1]; bit32 C = CV[2]; bit32 D = CV[3]; //作4轮循环，每一轮作16次迭代 for (int j = 0; j &lt; 4; ++j) &#123; for (int q = 0; q &lt; 16; ++q) &#123; bit32 a = A, b = B, c = C, d = D; bit32 g; int k; switch (j) &#123; case 0: g = F(b, c, d); k = q; break; case 1: g = G(b, c, d); k = (1 + 5 * q) % 16; break; case 2: g = H(b, c, d); k = (5 + 3 * q) % 16; break; case 3: g = I(b, c, d); k = (7 * q) % 16; break; &#125; bit32 tmp = a + g + groups[i][k] + T[j * 16 + q]; a = b + shiftLeft(tmp, s[j * 16 + q]); //缓冲区作循环轮换 //(B, C, D, A) &lt;- (A, B, C, D) A = d; B = a; C = b; D = c; &#125; &#125; CV[0] += A; CV[1] += B; CV[2] += C; CV[3] += D; &#125;&#125;//把128位(4个32位字)的结果转成16个字节的输出void getBytes() &#123; for (int i = 0; i &lt; 4; ++i) &#123; //利用了小端编码 MD5[i * 4 + 0] = CV[i] &amp; 0xff; MD5[i * 4 + 1] = (CV[i] &gt;&gt; 8) &amp; 0xff; MD5[i * 4 + 2] = (CV[i] &gt;&gt; 16) &amp; 0xff; MD5[i * 4 + 3] = (CV[i] &gt;&gt; 24) &amp; 0xff; &#125;&#125;int main() &#123; string test; getline(std::cin, test); padding((byte*)test.c_str(), test.length()); HMD5(); getBytes(); // 输出十六进制字符串 string str = ""; char HEX[16] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; for (int i = 0; i &lt; 16; ++i) &#123; byte quotient = MD5[i] / 16; byte remainder = MD5[i] % 16; str.append(1, HEX[quotient]); str.append(1, HEX[remainder]); &#125; std::cout &lt;&lt; str &lt;&lt; std::endl;&#125; 编译运行结果首先来测试一个简单的字符串的MD5散列值： 1234$ g++ MD5.cpp -o MD5$ ./MD5hello,world!c0e84e870874dd37ed0d164c7986f03a 使用在线MD5加密工具查看结果： 再测试一个很长的字符串： 1234$ g++ MD5.cpp -o MD5$ ./MD5In cryptography, a keyed-hash message authentication code(HMAC) is a specific type of MAC involving a cryptographic hashfunction and a secret cryptographic key.It may be used to simultaneously verify both the data integrity andthe authentication of a message, as with any MAC.Any cryptographic hash function, such as MD5 or SHA-1, may beused in the calculation of an HMAC; the resulting MAC algorithm istermed HMAC-MD5 or HMAC-SHA1 accordingly.The cryptographic strength of the HMAC depends upon thecryptographic strength of the underlying hash function, the size ofits hash output, and on the size and quality of the keya939099e207813b92284271a3fd49dd5 使用在线工具查看结果： 可以看到，结果是正确的，因此实现的MD5算法是正确的。]]></content>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-210]]></title>
    <url>%2F2018%2F11%2F30%2Fleetcode-210%2F</url>
    <content type="text"><![CDATA[题目Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: 12345&gt;Input: 2, [[1,0]] &gt;Output: [0,1]&gt;Explanation: There are a total of 2 courses to take. To take course 1 you should have finished &gt; course 0. So the correct course order is [0,1] .&gt; Example 2: 123456&gt;Input: 4, [[1,0],[2,0],[3,1],[3,2]]&gt;Output: [0,1,2,3] or [0,2,1,3]&gt;Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both &gt; courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. &gt; So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .&gt; Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. 分析这道题是典型的图论的算法题，主题就是拓扑排序：把图中的所有节点排序，使得所有的边都从排在前面的节点指向排在后面的节点。 本题给出了节点数量和以节点对来表示的边的数组。 一般来说，要做拓扑排序，有两种解法： 遍历图，找到所有入度为0的节点(源)，然后删去这个节点以及从它出去的边，重复这个过程 使用DFS，记录每个节点的post值，然后按post值递减进行排序 此外，如果图不是DAG，图中有环的话，是没有拓扑排序的，这很容易理解，而上面两种方法也有不同的判断是否有环的方法： 在遍历过程中，如果在剩下的节点集合中找不到源，剩余节点数又大于0，就有环 在DFS过程中，如果有这样的一条边：从已计算出post值的节点指向一个已有prev值、但是没有post值的节点，则有环(即存在回边) 解法一采用删除源的方法，我们首先要记录所有节点的入度inDegree，然后重复以下过程： 找到源，把它加入到结果数组order的尾部 删除源，具体操作为：从记录inDegree的map中删除它的记录，然后删除从源出去的边，并把这些边指向的节点的inDegree减一 找不到源时，即有环，没有结果 通过使用unordered_map，我们不仅可以快速获取一个节点的入度，而且删除节点也十分高效。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;//解法一:删除源//判断有无环:没有源，但节点集合又不为空class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; int num = numCourses; unordered_map&lt;int, int&gt; inDegree; for (int i = 0; i &lt; numCourses; ++i) inDegree[i] = 0; vector&lt;int&gt; order; for (int i = 0; i &lt; prerequisites.size(); ++i) &#123; inDegree[prerequisites[i].first]++; &#125; while (num != 0) &#123; bool flag = false; for (unordered_map&lt;int, int&gt;::iterator itr = inDegree.begin(); itr != inDegree.end();) &#123; if (itr-&gt;second == 0) &#123; flag = true; order.push_back(itr-&gt;first); //删除从源出去的边 for (vector&lt;pair&lt;int, int&gt;&gt;::iterator it = prerequisites.begin(); it != prerequisites.end();) &#123; if (it-&gt;second == itr-&gt;first) &#123; inDegree[it-&gt;first]--; it = prerequisites.erase(it); &#125; else it++; &#125; //删除源 itr = inDegree.erase(itr); num--; &#125; else itr++; &#125; //有环 if (flag == false) return &#123;&#125;; &#125; return order; &#125;&#125;; 解法二使用DFS来遍历一次图，获取每个节点的post值，然后利用post值的降序来进行排序。 prev值表示开始访问节点返回的时刻 post值表示访问完节点返回的时刻 使用DFS来遍历图的伪代码： 1234567891011121314151617181920func dfs for all v in V do visited[v] = false for all v in V do if not visited[v] : explore(v)func explore(v) visited[v] = true previsit(v) for each edge (v, u) in E do if not visited[u] : explore(u) postvisit(v)func prevvisit(v) prev[v] = clock clock++ func postvisit(v) post[v] = clock clock++ 要判断是否有环的话，判断是否有回边即可：有边从已有post值的节点指向已有prev值、但没有post值的节点。 通过构建邻接表，我们可以快速获取从节点出发的边所指向的下一节点，实现O(V+E)的时间复杂度的DFS算法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;//解法二:通过DFS获取post值，按post值递减排序//判断有无环:如果有一条边由已有post值的点指向有prev值、但没有post值的点，则有环class Solution &#123;private: //邻接表 vector&lt;vector&lt;int&gt; &gt; adjList; vector&lt;bool&gt; visited; vector&lt;int&gt; prev; vector&lt;int&gt; post; int clock = 1; bool hasCircle = false; vector&lt;int&gt; order; void explore(int node) &#123; visited[node] = true; //previsit prev[node] = clock; clock++; for (int i = 0; i &lt; adjList[node].size(); ++i) &#123; if (visited[adjList[node][i]] == false) explore(adjList[node][i]); else if (post[adjList[node][i]] == 0) hasCircle = true; &#125; //postvisit post[node] = clock; clock++; order.insert(order.begin(), node); &#125;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; visited = vector&lt;bool&gt;(numCourses, false); prev = vector&lt;int&gt;(numCourses, 0); post = vector&lt;int&gt;(numCourses, 0); adjList = vector&lt;vector&lt;int&gt;&gt;(numCourses); //构建邻接表 for (int i = 0; i &lt; prerequisites.size(); ++i) adjList[prerequisites[i].second].push_back(prerequisites[i].first); for (int i = 0; i &lt; numCourses; ++i) &#123; if (visited[i] == false) &#123; explore(i); &#125; &#125; if (hasCircle == true) return &#123;&#125;; else return order; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-085]]></title>
    <url>%2F2018%2F11%2F24%2Fleetcode-085%2F</url>
    <content type="text"><![CDATA[上周做完Largest Rectangle in Histogram后leetcode推荐我接下来做这一题，因此本周算法题就选它了。 题目Maximal Rectangle Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 123456789&gt; Input:&gt; [&gt; ["1","0","1","0","0"],&gt; ["1","0","1","1","1"],&gt; ["1","1","1","1","1"],&gt; ["1","0","0","1","0"]&gt; ]&gt; Output: 6&gt; 分析这道题的意思很明确，给出一个二维矩阵，让我们从中找出由1组成的最大矩形面积，和上周那题一样，都是要求最大矩形面积，但输入由一维数组变成了二维数组。 解法如果采用暴力求解的话，我们可以先找出所有只由1组成的矩形(一个个遍历元素，从它开始向右、向下再向右扩展)，再从中计算出最大的矩形面积。但用暴力求解来解上周那一维输入的题运行时间都超了1000ms，这次肯定会超时，因此我没有采用这种解法。 实际上，这两道题之间有着很大的联系，不然我也不会一直提起上周那题。仔细想想，求解一维数组中最大矩形面积我们已经有了较快的解法，那么我们可以考虑把从二维数组求解转变成从一维数组求解。 我们从上往下，一行行来分解二维矩阵，就可以把问题转变成求m次一维数组的最大矩形面积(m为行数)：以一个一维数组来存放高度，当遍历到下一行时，从左往右遍历每一列位置，如果该位置为0，则高度为0；否则高度为上一行求得的高度+1。 例如，在例子中，遍历到每一行时高度分别为： 1234["1","0","1","0","0"],["2","0","2","1","1"],["3","1","3","2","2"],["4","0","0","3","0"] 运用上一周的算法即可算出答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) &#123; if (matrix.size() == 0) return 0; int result = 0; vector&lt;int&gt; heights(matrix[0].size(), 0); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = 0; j &lt; matrix[i].size(); ++j) &#123; if (matrix[i][j] == '0') heights[j] = 0; else heights[j]++; &#125; result = max(result, largestRectangleArea(heights)); &#125; return result; &#125; int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; int n = heights.size(); if (n == 0) return 0; int left[n], right[n]; left[0] = -1; right[n - 1] = n; for (int i = 1; i &lt; n; ++i) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = i - 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = left[i - 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != -1) &#123; tmp = left[tmp]; &#125; left[i] = tmp; &#125; &#125; for (int i = n - 2; i &gt;= 0; --i) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = i + 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = right[i + 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != n) &#123; tmp = right[tmp]; &#125; right[i] = tmp; &#125; result = max(result, (right[i] - left[i] - 1) * heights[i]); &#125; result = max(result, (right[n - 1] - left[n - 1] - 1) * heights[n - 1]); return result; &#125;&#125;;static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;(); 复杂度分析这个解法的复杂度重点在于求最大矩形面积的算法，在上周我们已经分析过，算法由于while循环的次数可以很少，因此算法时间复杂度可以逼近O(n)，空间复杂度O(2n) = O(n)。 因此这个解法的时间复杂度逼近O(mn)，空间复杂度为O(3n) = O(n)，其中m为matrix行数，n为matrix列数。 另外，在提交后查看别人的代码时，我发现了这么一段代码： 12345static int x = []() &#123; ios::sync_with_stdio(false); cin.tie(NULL); return 0; &#125;(); 这段代码通过关闭cout与printf之间的同步、解除cin与cout之间的绑定提高了C++的IO效率。详情参见： https://blog.csdn.net/chenf1999/article/details/84452273 在这么做之后，这个解法在leetcode上运行时间为8ms。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-084]]></title>
    <url>%2F2018%2F11%2F16%2Fleetcode-084%2F</url>
    <content type="text"><![CDATA[题目Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 123&gt; Input: [2,1,5,6,2,3]&gt; Output: 10&gt; 分析这道题看起来和之前那道Trapping Rain Water很像，给的例题都有直方图，但这题要求的是直方图中能找到的最大矩形面积，要求连续的几个数数值越近越好，就能组成更大的面积，与之前那道正好相反。 解法一首先，最容易想到的解法就是对数组中的每个高度都求出对应的最大矩形面积，然后取最大值，即为答案。 要求固定高度h的最大矩形面积的话，我们需要遍历整个数组，然后记录每一个能够组成的高度为h的矩形面积，最后取最大值，伪代码如下： 123for i in heights do if (heights[i] &gt;= h) //这个元素作为当前矩形的一部分 else //该元素高度小于矩形高度，计算当前矩形面积 需要注意的几点： 计算矩形面积后要及时更新矩形的左右下标为初始值 当最后一个元素也大于矩形高度时，不能忽略这个矩形的高度 为了避免重复计算，可以用map来存储已经计算过的高度对应的面积 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; map&lt;int, int&gt;area; for (auto i : heights) &#123; //判断这个高度的矩形的面积是否被计算过 if (area.find(i) == area.end()) &#123; area.insert(std::pair&lt;int, int&gt;(i, calc(i, heights))); result = max(result, area[i]); &#125; &#125; return result; &#125;private: int calc(int h, const vector&lt;int&gt;&amp; heights) &#123; int left, right; left = right = -1; int area = 0; for (int i = 0; i &lt; heights.size(); ++i) &#123; //矩形左下标 if (heights[i] &gt;= h &amp;&amp; left == -1) left = right = i; //矩形右下标右移 else if (heights[i] &gt;= h) right++; //h小于矩形高度，计算当前最大矩形面积 else if (left != -1) &#123; area = max(area, (right - left + 1) * h); left = right = -1; &#125; &#125; //不要遗漏右下标为最后一个下标的矩形面积 if (right == heights.size() - 1) &#123; area = max(area, (right - left + 1) * h); &#125; return area; &#125;&#125;; 复杂度分析这种解法在最好情况下复杂度为O(2n)，即数组中所有元素值都相等时；最坏情况下复杂度为O(n2)，即数组中所有元素值都不相等时。 但是这种解法在leetcode上运行时间超过了1000ms，因此必须进行优化。 解法二上面那种解法在经过了使用map来避免重复计算后运行时间还是很高，这是因为计算每个高度对应的面积时都必须遍历整个数组，我们要从这一点入手来进行优化。 但是每个高度对应的面积之间貌似没有联系，不能通过一个值来推出其他值，因此我考虑换一种基本思路：计算每个包含当前元素的矩形面积，然后取最大值。这个计算要求我们从当前元素下标开始，分别向左和向右找第一个高度小于当前元素的下标，然后就是(right - left - 1) * height，伪代码如下： 123456for i in heights do for j = i - 1 to 0 do if (heights[j] &lt; heights[i]) left = j;break for j = i + 1 to 0 do if (heights[j] &lt; heights[i]) right = j;break result = max(result, (right - left - 1) * heights[i]) 这种基本思路的解法比解法一的复杂度还会稍微高一点，但是重点是它是可以优化的，因为相邻两个元素之间的left值和right值是有联系的： 假设从左往右遍历，如果当前元素高度大于它左边元素高度，那么它的left值就是左边元素的left值；否则，需要往左遍历去寻找left值。但是通过存储每个元素的left值和right值，可以简化这个遍历过程，伪代码如下： 12345678int left[n], right[n];for i in heights do if (heights[i] &gt; heights[i - 1]) left[i] = left[i - 1] else &#123; int tmp = left[i - 1] while (heights[i] &lt;= heights[tmp]) tmp = left[tmp] left[i] = tmp &#125; 因为元素j高度大于元素i高度，因此第一个高度小于元素i的下标一定&lt;=元素j的left值，通过利用数组，我们可以快速完成遍历，提高算法速度。 最终的算法需要遍历两次数组，分别求解出left和right数组，然后计算面积，可以把计算面积的过程放在求解right数组的循环种来减少运行时间。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int result = 0; int n = heights.size(); if (n == 0) return 0; int left[n], right[n]; left[0] = -1; right[n - 1] = n; for (int i = 1; i &lt; n; ++i) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = i - 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = left[i - 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != -1) &#123; tmp = left[tmp]; &#125; left[i] = tmp; &#125; &#125; for (int i = n - 2; i &gt;= 0; --i) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = i + 1; else &#123; //找第一个小于当前元素的元素下标 int tmp = right[i + 1]; while (heights[i] &lt;= heights[tmp] &amp;&amp; tmp != n) &#123; tmp = right[tmp]; &#125; right[i] = tmp; &#125; result = max(result, (right[i] - left[i] - 1) * heights[i]); &#125; result = max(result, (right[n - 1] - left[n - 1] - 1) * heights[n - 1]); return result; &#125;&#125;; 复杂度分析算法的复杂度在最坏情况下为O(n2)，但这种情况很难遇到，更一般的情况下可以逼近O(n)，在leetcode上运行时间为12ms。 总结第一种解法虽然利用map省去了重复计算，但是每一次计算的复杂度还是很高；而第二种解法利用每个矩形左右下标之间的联系，简化了计算的过程，使算法提速明显，因此我们在设计算法时要尽量利用已知来求解未知，简化计算过程。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-152]]></title>
    <url>%2F2018%2F11%2F11%2Fleetcode-152%2F</url>
    <content type="text"><![CDATA[题目Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 1234&gt; Input: [2,3,-2,4]&gt; Output: 6&gt; Explanation: [2,3] has the largest product 6.&gt; Example 2: 1234&gt; Input: [-2,0,-1]&gt; Output: 0&gt; Explanation: The result cannot be 2, because [-2,-1] is not a subarray.&gt; 分析这道题的意思是让我们计算出一个整数数组中乘积最大的子序列的乘积，要注意子序列必须是连续的。 这道题的难点在于负数的存在，可以让一个本来乘积为负数的子序列在增加一个元素后乘积为正，比如-2, 3, 4, 5, -3这个数组，如果没有最后的-3的话，答案就是60，子序列不能包含-2。但由于-3的存在，答案是360，子序列是整个数组。 这道题在leetcode中被划分为动态规划问题。 解法一既然这是一个动态规划问题，那首先我们就需要一个数组max[n]来记录以第i个数结尾的子序列的最大乘积(0 &lt;= i &lt; n)，类似于最大子序列和的问题。 那么对于max[i]，我们如何通过max[i - 1]来计算出max[i]呢？可能会想到类似于最大子序列和的解法，用max(max[i - 1] * nums[i], nums[i])来求解，即最大乘积要么就是第i个数，要么就是第i个数乘以原来的乘积。 这种解法是无法解决负数存在的问题的，比如上面那个例子。貌似我们不能从max[3](5结尾)来计算出max[4](-3结尾)的值，它们并没有直接的关系，因为max[3]没有把-2计算进去，而max[4]需要把-2计算进去。 如果我们不能通过上一个子问题的结果来计算下一个子问题的话，好像就不是动态规划了，因此肯定是计算max[i]的方法不对。 我们可以发现，-3会使结果变化的原因是前面子序列乘积的最小值是个负数，而且其绝对值是最大的乘积，因此新的结果就是原来乘积的最小值乘以-3。 想到这里就可以知道答案了，我们需要为以第i个数结尾的子序列维护最小乘积和最大乘积，这两个值同时用来计算以下一个数结尾的子序列的最小乘积和最大乘积。 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int min[n], max[n]; min[0] = max[0] = nums[0]; //min[i],max[i]分别表示以第i个数结尾的子序列的最小/最大值 for (int i = 1; i &lt; n; ++i) &#123; min[i] = std::min(std::min(min[i - 1] * nums[i], nums[i]), max[i - 1] * nums[i]); max[i] = std::max(std::max(max[i - 1] * nums[i], nums[i]), min[i - 1] * nums[i]); &#125; int result = max[0]; for (int i = 1; i &lt; n; ++i) if (result &lt; max[i]) result = max[i]; return result; &#125;&#125;; 解法二同样地，我们可以为这个DP算法优化空间复杂度，不难发现，我们可以把记录子序列最小/最大值的min，max数组优化成单个元素，因为每次计算min[i]时要用到的都是min[i - 1]和max[i - 1]。 如果只用min来存以第i个数结尾的子序列的最小值的话，当我们在计算出min[i]之前，实际上min里存的是min[i - 1]的值，即上一轮循环的结果还没有被更新，可以用来计算这一轮的结果 要注意当计算出min之后，上一轮的min值就被覆盖了，而计算这一轮的max需要用到上一轮的min值，因此需要一个临时变量来存储上一轮的min值 优化后算法空间复杂度O(1)，时间复杂度O(n) 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int result; int min, max; result = min = max = nums[0]; //min,max分别表示以第i个数结尾的子序列的最小/最大值 for (int i = 1; i &lt; n; ++i) &#123; int tmp = min; min = std::min(std::min(min * nums[i], nums[i]), max * nums[i]); max = std::max(std::max(max * nums[i], nums[i]), tmp * nums[i]); if (result &lt; max) result = max; &#125; return result; &#125;&#125;; 总结这道题也是很典型的动态规划问题，难点在于由于负数的存在，最小乘积也是会影响到结果的，而我们一般只会想到要维护最大乘积的值，就比较难求解。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-072]]></title>
    <url>%2F2018%2F11%2F04%2Fleetcode-072%2F</url>
    <content type="text"><![CDATA[题目Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 1234567&gt; Input: word1 = "horse", word2 = "ros"&gt; Output: 3&gt; Explanation: &gt; horse -&gt; rorse (replace 'h' with 'r')&gt; rorse -&gt; rose (remove 'r')&gt; rose -&gt; ros (remove 'e')&gt; Example 2: 123456789&gt; Input: word1 = "intention", word2 = "execution"&gt; Output: 5&gt; Explanation: &gt; intention -&gt; inention (remove 't')&gt; inention -&gt; enention (replace 'i' with 'e')&gt; enention -&gt; exention (replace 'n' with 'x')&gt; exention -&gt; exection (replace 'n' with 'c')&gt; exection -&gt; execution (insert 'u')&gt; 分析这道题是很经典的字符串编辑距离问题，是动态规划解决问题的一个典型例子。题目问的是我们通过一次只能增加、减少或替换一个字符的操作，最少几次操作能把两个字符串改成相同的字符串。 解法一使用动态规划来解决问题。 考虑长度为i的字符串str1和长度为j的字符串str2，用dist[i][j]来代表它们之间的编辑距离。 首先，容易知道，如果其中一个字符串为0，那么编辑距离就是另一个字符串的长度，即i = 0时 dist[0][j] = j，j = 0时dist[i][0] = i。 要计算dist[i][j]，我们考虑从str1和str2的最后一个字符(char1和char2)入手： 如果char1 == char2，那么dist[i][j] = dist[i - 1][j - 1]，这应该是很容易看出来的，最后一个字符相等，那么有没有它们对编辑距离都没有影响 如果char1 != char2，这时候可以对最后一个字符进行3个操作： 把char2替换成char1，那么dist[i][j] = 1 + dist[i - 1][j - 1]，这是因为替换后就相当于char1 == char2的情况了，因此只需要加上那替换的开销1 在str2最后加一个字符char1，那么dist[i][j] = 1 + dist[i - 1][j]，这相当于给str2加了一个长度，此时的char1 == char2，同样需要额外的开销1 删掉str2的最后一个字符char2，那么dist[i][j] = 1 + dist[i][j - 1]，这种情况相当于str2长度减1，当然就是要算dist[i][j - 1]了，同样需要额外开销1 上面对char2的操作也可以改成对char1的操作，但结果没有区别 根据上面的结论，很容易得到动态规划方程： 12dist[i][j] = min(1 + dist[i - 1][j], 1 + dist[i][j - 1], diff(char1, char2) + dist[i - 1][j - 1])//diff(char1, char2) = (char1 == char2) ? 0 : 1 根据动态规划可以写出下面的代码，时间复杂度O(mn)，空间复杂度O(mn)。 代码12345678910111213141516171819202122232425262728293031#include &lt;string&gt;#include &lt;iostream&gt;using std::min;using std::string;class Solution &#123;public: int minDistance(string word1, string word2) &#123; //对于长度为i的word1子串和长度为j的word2子串 //dist[i][j]表示这两个子串之间的编辑距离 int m = word1.length(), n = word2.length(); int dist[m + 1][n + 1]; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; if (i == 0) dist[i][j] = j; else if (j == 0) dist[i][j] = i; else dist[i][j] = __INT_MAX__; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dist[i][j] = min(min(1 + dist[i - 1][j], 1 + dist[i][j - 1]), diff(word1[i - 1], word2[j - 1]) + dist[i - 1][j - 1]); &#125; &#125; return dist[m][n]; &#125;private: int diff(char c1, char c2) &#123; return !(c1 == c2); &#125;&#125;; 解法二很多DP算法都可以进行空间复杂度的优化，本题也不例外，通过优化，我们可以把空间花费降至线性。 考虑解法一中的双重循环，转换到如下表格的话，不难知道是一行行地算出结果的。在初始时表格第一行和第一列的值是确定的，这由前面的讨论可以知道。 考虑当计算到任意位置的dist[i][j]，我们可以由解法一算法得知，dist[i][j]取决于它左边、上面、以及左上角表格的值，现在我们可以考虑把空间压缩到一维了： dist[n]只存每一行的值，初始情况即第一行。 当要计算dist[j]时，由于我们是从左往右计算每一行的，所以左边的值就是dist[j - 1]，而上面的值就是dist[j](因为此时dist[j])还没有被覆盖，存放的仍是上一行的值，而dist[j - 1]就已经被覆盖，存放的是这一行的值。所以我们也能够知道，我们必须事先存储左上角的值，因为会被覆盖，左上角的值即在计算上一个dist[j]时未被覆盖的上面的值。 优化后的代码空间复杂度为O(n)，时间复杂度不变。 很多DP算法都可以通过这种画表格的方式来优化空间。 代码123456789101112131415161718192021222324252627282930#include &lt;string&gt;#include &lt;iostream&gt;using std::min;using std::string;class Solution &#123;public: int minDistance(string word1, string word2) &#123; //对于长度为i的word1子串和长度为j的word2子串 //dist[i][j]表示这两个子串之间的编辑距离 int m = word1.length(), n = word2.length(); if (m == 0) return n; if (n == 0) return m; int dist[n + 1]; for (int i = 0; i &lt;= n; ++i) dist[i] = i; int leftNor; for (int i = 1; i &lt;= m; ++i) &#123; leftNor = i - 1; dist[0] = i; for (int j = 1; j &lt;= n; ++j) &#123; int tmp = dist[j]; int diff = word1[i - 1] == word2[j - 1] ? 0 : 1; dist[j] = min(min(dist[j] + 1, dist[j - 1] + 1), diff + leftNor); leftNor = tmp; &#125; &#125; return dist[n]; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链热身报告]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%83%AD%E8%BA%AB%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[区块链project热身报告安装以太坊Geth是以太坊智能合约开发中最常用的工具，执行在GO上运行的完整以太坊节点，通过Geth，我们可以实现以太坊的各种功能，如账户的新建、编辑、删除，开启挖矿，以太币的转移，智能合约的部署和执行等等。 windows下安装在官网下载安装包即可(需翻墙)，安装过程会自动配置环境变量，在cmd中使用geth version可以查看是否安装成功 ubuntu下安装同样去官网下载对应版本，这是一个tar.gz包，下载后解压即可得到geth可执行文件，配置好环境变量就可以使用了 私有链搭建进入到为搭建私有链创建的文件夹privatechain后，执行以下操作 配置文件要搭建私有链，首先需要编写创始区块配置文件，命名为genesis.json，内容如下: 1234567891011121314151617&#123; "config": &#123; "chainId": 10, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0 &#125;, "alloc" : &#123;&#125;, "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x20000", "extraData" : "", "gasLimit" : "0xffffffff", "nonce" : "0x0000000000000042", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"&#125; 要注意几点： chainId不能为0，否则部署智能合约时会出错： 1invalid sender undefined gaslimit不能太小，否则部署智能合约时会报错： 1Error: exceeds block gas limit undefined difficulty会影响到你节点的挖矿速度 初始化私有链1geth --datadir data0 init genesis.json 这条命令表示初始化私有链到文件夹data0中，这条链的数据存放在data0里，并根据genesis.json中的内容把创世区块写入区块链，通过log信息中的Successfully wrote genesis state我们知道初始化成功。 初始化后的初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 启动私有链节点1geth --datadir data0 --networkid 1108 console geth console，表示启动节点并进入交互式控制台，控制台是一个交互式的Javascript执行环境 –-datadir选项指定使用data0作为数据目录，即运行我们前面初始化的那条私有链 –-networkid选项指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id 一些简单操作查看账户 1&gt;eth.accounts 创建账户 123&gt;personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase: 查看账户余额 1&gt; eth.getBalance(eth.accounts[0]) 启动&amp;停止挖矿 12&gt; miner.start(10)#参数10表示挖矿使用的线程数&gt; miner.stop()： 解锁账户 1&gt; personal.unlockAccount(eth.accounts[0]) 发送交易 12&gt; amount = web3.toWei(10,'ether')&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)#这个交易表示从账户0向账户1转账10个以太币 私有链节点加入要向私有链中加入节点，我们需要同时运行两个节点，同时启动节点的命令是有要求的，我启动两个节点(同一台电脑)的命令分别为： 1geth --networkid 1108 --nodiscover --datadir data0 --port 30303 --rpc --rpcapi net,eth,web3,personal --rpcport 8545 --rpcaddr localhost --verbosity 6 console 2&gt;&gt;geth0.log --ipcpath "geth0.rpc" 1geth --networkid 1108 --nodiscover --datadir data1 --port 55554 --rpc --rpcapi net,eth,web3,personal --rpcport 8101 --rpcaddr localhost --verbosity 6 console 2&gt;&gt;geth1.log --ipcpath "geth1.rpc" 当然，首先得搭建两个节点data0和data1. 参数解释： 123456789--nodiscover 关闭p2p网络的自动发现，需要手动添加节点，这样有利于我们隐藏私有网络--datadir 区块链数据存储目录--port 网络监听端口，默认30303--networkid 网络标识，私有链取一个大于4的随意的值--rpc 启用ipc服务--rpcport ipc服务端口，默认端口号8545--rpcapi 表示可以通过ipc调用的对象--rpcaddr ipc监听地址，默认为127.0.0.1，只能本地访问console 打开一个可交互的javascript环境 这之中要注意的几个地方是： 端口号必须不同 rpc端口号必须不同 ipcpath必须不同 进入了Javascript Console之后，首先在第一个节点data0那执行命令查看enode： 1admin.nodeInfo.enode 然后在第二个节点data1那执行命令 1admin.addPeer(&quot;xxx&quot;) 括号内填查看到的data0的enode信息，返回true即可成功加入节点，加入后data1就会自动开始同步data0的所有区块。 之后可以使用以下命令来查看节点是否添加成功： 12net.peerCountadmin.peers 在data1使用eth.blockNumber来查看区块是否同步成功。 注意： windows下节点同步可能会失败，所以最好在Linux下进行加入节点的操作 要保证两个节点在同一个区块链上工作的话首先要保证genesis创世区块链是一样的，所以注意使用同样的genesis.json文件来创建． 解释getBlock字段使用getBlock来得到区块相关信息： 1234567891011121314151617181920212223 eth.getBlock(0)&#123; difficulty: 131072, extraData: "0x", gasLimit: 4294967295, gasUsed: 0, hash: "0x04786260f9e2b8a341a6a07949d74365c53bc4fd1edb00ff3b5f209f86906579", logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", miner: "0x0000000000000000000000000000000000000000", mixHash: "0x0000000000000000000000000000000000000000000000000000000000000000", nonce: "0x0000000000000042", number: 0, parentHash: "0x0000000000000000000000000000000000000000000000000000000000000000", receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", size: 508, stateRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", timestamp: 0, totalDifficulty: 131072, transactions: [], transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", uncles: []&#125; 参数为0，查看的是创世区块，也可以把参数设为”latest”来查看最新区块。 difficulty：当前块的难度。 extraData：包含这个区块的任意字节相关数据。 gasLimit：当前区块允许使用的最大gas，这个值是我们genesis.json中的gasLimit值。 gasUsed：当前区块累计使用的总的gas。 hash：区块的哈希串。当这个区块处于pending将会返回null。 logsBloom：由日志信息组成的一个Bloom过滤器 （数据结构）。当这个区块处于pending将会返回null。 miner：这个区块获得奖励的矿工。 mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算 nonce：在挖矿过程中起作用，POW生成的哈希。当这个区块处于pending将会返回null。 number：区块号。当这个区块处于pending将会返回null。 parentHash：父区块的哈希值。由于这是创始区块，因此该值为0。 receiptsRoot：包含此区块所列的所有交易收据的树的根节点Hash值 sha3Uncles：叔区块的哈希值。 size：当前这个块的字节大小。 stateRoot：区块的最终状态前缀树的根。 timestamp：区块打包时的unix时间戳。 totalDifficulty：区块链到当前块的总难度。 transactions：交易对象。或者是32字节的交易哈希。 transactionsRoot：包含此区块所列的所有交易的树的根节点Hash值 uncles：叔哈希的数组。 叔块是什么？在上面的区块中有叔块的信息，那么叔块是什么呢？ 我们都知道在挖矿过程中，只有最长的那条链才会被所有节点所承认，挖到在最长链的那些区块的矿工才能获得奖励。如果一个块不是最长链的一部分，那么它被称为是“孤块”。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。 根据Ethereum的GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。在以太坊中，孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献。 由于GHOST协议支付报酬给叔块，这激励了矿工在新发现的块中去引用叔块。引用叔块使主链更重。在比特币，最长的链是主链。在以太坊中，主链是指最重的链 解释日志输出通过在启动私有链节点时在命令最后加上2 &gt;&gt;xxx.log即可把日志输出到log文件中，通过设置选项--verbosity n可以设置日志的程度。 我选取了一些日志进行解释： 日志1 这个日志是我在给私有链添加节点时的日志输出，可以看到，执行命令后的第一个日志输出就是Adding p2p peer，表示加入节点。connnection set up表示建立连接，之后直到Ethereum peer connected，连接成功。然后就要开始为节点上区块链的同步做准备了，Block synchronisation started表示区块同步开始。此后要经过一系列的准备工作，比如获取链高度、下载区块体、获取区块头…最后可以看到一连串的Inserted new block，这就表示同步区块正式开始啦，可以从右边的number得知同步进度。 日志2 这个日志是挖矿的日志。一开始的Updated mining threads表示更新挖矿的线程，右边可以看到线程数量为10，这是在miner.start(10)中设置的。Etherbase automatically configured表示使用默认的coinbase，默认的是本地账户中的第一个账户，即eth.accounts[0]，挖矿所得到的所有奖励都会进入这个账户中。之后Commit new mining work表示挖矿正式开始，那个🔨开头的日志说明成功挖到了矿，可以从右边的number看到挖到区块的数目。 日志3 这个简短的日志是进行一笔交易的日志，不知道为啥设置verbosity为6也还是看不到更具体的信息。Pooled new future transaction表示提交到交易缓冲池，Promoting queued transaction表示选择一部分交易进入pending队列进行处理，Submitted transaction表示交易被成功处理并提交，最后的Broadcast transaction表示把这笔交易广播出去。 部署智能条约编写合约首先编写智能合约，用solidity语言实现： 12345678910111213141516171819202122232425contract Mortal &#123; /* Define variable owner of the type address */ address owner; /* This function is executed at initialization and sets the owner of the contract */ function Mortal() &#123; owner = msg.sender; &#125; /* Function to recover the funds on the contract */ function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125; contract Greeter is Mortal &#123; /* Define variable greeting of the type string */ string greeting; /* This runs when the contract is executed */ function Greeter(string _greeting) public &#123; greeting = _greeting; &#125; /* Main function */ function greet() constant returns (string) &#123; return greeting; &#125;&#125; 由于Solidity同样具有继承的特性，通过只声明Greeter是Mortal的，Greeter就可以继承”Mortal”合约的所有特征。 这段代码的主函数是greet()，我们之后将调用这个函数来调用智能合约。 编译合约使用在线编译器remix来编译(需要翻墙)： 首先确定右窗格中选择的是Greeter而不是Mortal，然后点击Details来获取编译后的代码，复制WEB3DEPLOY中的代码： 保存到js文件中，命名为contract.js，并修改第一行为： 1var _greeting = "Hello World!" 部署合约执行loadScript(&quot;contract.js&quot;)导入文件，报错如下： 这是因为我们必须要先解锁账户，因为我们需要支付部署合约的GAS费用，解锁后继续执行： 执行eth.getCode(greeter.address)来验证代码是否部署成功： 报错是因为部署合约需要挖矿，启动挖矿后再次执行： 部署成功！ 调用合约执行greeter.greet()，我们可以看到输出： 由于这个调用没引起在区块链上的任何变化，因此它会立即返回并且无需任何Gas费用 使用其他节点调用合约这首先要求添加节点到私有链中，因此转到ubuntu操作： 上图是在data0进行部署合约的操作 然后，我们要知道通过其他节点调用这个合约需要两个信息： 合同所在地址 ABI（应用程序二进制接口），这是一种用户手册，描述合同功能的名称以及如何将它们调用到您的JavaScript控制台 获取合同所在地址很简单，greeter.address;即可 要获取ABI，就需要去Remix官网，同样在Detail中获得，复制ABI文本框即可，然后暂时保存到一个abi.txt文件。如果我们想直接把它复制到终端是不行的，因为它含有换行符，因此需要去掉换行符(替换为空格)： 1cat abi.txt | tr '\n' ' ' 然后就可以把abi.txt中内容复制到以太坊交互式控制台中，把这段内容赋值给abi，查看赋值后abi的值： 在data1中执行以下命令： 1myContract = web3.eth.contract(abi).at(address) address为合约地址 查看myContract以及调用合约： 在节点data1中调用合约好像需要先解锁账户，但是这里我没有解锁也成功了，我想可能是因为这个调用不要消耗Gas值吧 解释交易字段首先解锁账户0： 1234&gt; personal.unlockAccount(eth.accounts[0])Unlock account 0xb01a469b117268418619e61f1b1a6e2fc7e4e7cePassphrase:true 发送交易(从账户0向账户1发送10个以太币)： 12345&gt; amout = web3.toWei(10, 'ether')"10000000000000000000"&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amout&#125;)INFO [11-04|16:56:58.227] Setting new local account address=0xB01A469b117268418619E61f1B1a6E2fc7e4E7cEINFO [11-04|16:56:58.235] Submitted transaction fullhash=0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76 recipient=0x20949144E5A4590857726BD3B4D95dce04731e78 最后返回的那个字符串即是交易的地址，可以通过getTransaction来查看交易信息，需要注意，此时交易还处于Pending状态(已提交但还未被处理的交易)，需要启动挖矿: 1miner.start(1);admin.sleepBlocks(1);miner.stop(); 这样交易就得到处理，使用getTransaction来查看交易： 12345678910111213141516171819&gt; eth.getTransaction("0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76")&#123; blockHash: "0x897bbbd6b0aeffadb707ad7b37149e93428c1b361809772b6ef99de96713f1e0", blockNumber: 13, from: "0xb01a469b117268418619e61f1b1a6e2fc7e4e7ce", gas: 90000, gasPrice: 1000000000, hash: "0x5eeae4989feab2ef1d3a3c68f3cba9a5a9adafcaef4c4af79ba3088f01df0e76", input: "0x", nonce: 0, r: "0x64f0b414949135360554da5165d5115d0df842776d323861121c6dab36e49255", s: "0x62b9702c7b734a7521f7d1853965c58f54bfe84f0d8273fd52f4381aa8b32524", to: "0x20949144e5a4590857726bd3b4d95dce04731e78", transactionIndex: 0, v: "0x37", value: 10000000000000000000&#125;&gt; eth.accounts["0xb01a469b117268418619e61f1b1a6e2fc7e4e7ce", "0x20949144e5a4590857726bd3b4d95dce04731e78"] blockHash: 交易所在区块的哈希值。当这个区块处于pending将会返回null。 blockNumber:交易所在区块的块号。当这个区块处于pending将会返回null。 from: 交易发起者的地址。在这里为accouts[0]。 gas:交易发起者提供的gas。 gasPrice:交易发起者配置的gas价格，单位是wei。 hash:交易的哈希值。 input:交易附带的数据。 nonce:交易的发起者在之前进行过的交易数量。 r:用于产生标识交易发生者的签名(ECDSA签名值) s:用于产生标识交易发生者的签名(ECDSA签名值) to:交易接收者的地址。当这个区块处于pending将会返回null，如果是部署智能合约的交易，这个值也是null。在这里显示为accouts[1]。 transactionIndex:交易在区块中的序号。当这个区块处于pending将会返回null。 v:用于产生标识交易发生者的签名(ECDSA签名值) value:交易附带的货币量，单位为Wei。在这里即是转账的值 参考链接如何搭建以太坊私有链 添加私有链节点 部署智能合约 叔块的概念]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DES算法实现]]></title>
    <url>%2F2018%2F11%2F02%2FDES%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文阐述DES算法的基本原理及其C++实现方法，并给出源代码 算法概述DES 是一种典型的块加密方法：它以64位为分组长度，64位一组的明文作为算法的输入，通过一系列复杂的操作，输出同样64位长度的密文。DES 采用64位密钥，但由于每8位中的最后1位用于奇偶校验，实际有效密钥长度为56位。密钥可以是任意的56位的数，且可随时改变。其中极少量的数被认为是弱密钥，但能容易地避开它们。所有的保密性依赖于密钥。虽然56位的密钥对于现在来说加密强度不够，但是可以通过多次DES加密来加强加密强度。DES 算法的基本过程是换位和置换。 总体结构DES算法的总体结构如图所示： 加密和解密过程都适用于上图，唯一的差别在于子密钥的调度顺序不同： 输入64位明文 M 时，子密钥按 (K1K2… K16)次序调度，是加密过程。输入64位密文 C 时，子密钥按 (K16K15 … K1)次序调度，是解密过程 下面以加密为例，阐述DES算法的具体过程： 分解明文按照8个字节(64位)一组来将明文分组，原始明文消息按PKCS#5 (RFC 8018) 规范进行字节填充，即： 最后一组长度不够8个字节时，在末尾以字节填满，填入的字节取值相同，都是填充的字节数目 原始明文消息刚好分组完全时，在末尾填充8个字节 (即增加一个完整分组)，字节取值都是08 接下来的每一组作为DES算法的输入M，开始加密 接下来的下标除了S盒之外，都是从1开始，而不是从0开始 初始置换IP通过固定的初始置换表来重排M中的二进制位，以下表为例： 置换的过程即是把M[58]的值赋给M[1]，M[50]的值赋给M[2]。 要注意的是下标不是从0开始 之后的所有置换都类似于这种情况 置换后得到64位二进制串M0 = L0R0，L0、R0分别为前32位和后32位 16轮迭代T这是算法最复杂的部分，迭代过程如图所示： 上一步得到的L0、R0作为这一步骤的初始输入，开始迭代。 这一轮的右32位Ri-1直接作为下一轮的左32位Li 这一轮的左32位Li-1与输出为32位的Feistel 函数进行异或运算之后得到下一轮的右32位Ri-1 这个过程要持续16次，即得到L16、R16 Feistel函数从迭代过程的图可以看到，Feistel的输入输出为： 输入1：上一轮迭代结果的右32位Ri-1 输入2：长度为48位的子密钥Ki 输出：32位的结果 此函数的具体工作过程为： 将长度为32位的串Ri-1进行 E-扩展，成为48位的串 E(Ri-1)，E-扩展的原理类似于IP置换，通过借助E-扩展规则 (比特-选择表) 来实现 将 E(Ri-1) 和长度为48位的子密钥 Ki 作异或运算，Ki 由密钥 K 生成(稍后解释生成子密钥过程) 将 (2) 得到的结果分成8个分组，每个分组长度6位(可以直接按照下标顺序来分组)。各个分组分别经过8个不同的 S-盒进行 6-4 转换，得到8个长度分别为4位的分组(S-盒操作也稍后解释) 将 (3) 得到的分组结果顺序连接得到长度为32位的串 将 (4) 的结果经过 P-置换，得到的结果作为Feistel函数的最终32位输出 生成子密钥根据给定的64位密钥K，生成16个48位的子密钥 K1-K16 原理为： 对64位密钥K进行PC-1置换，得到去掉了8位检验位的56位串，C0和D0分别为前28位和后28位结果，令i = 1 分别对Ci和Di进行循环左移，如果i=1,2,9,16，则循环左移一位，否则循环左移两位，得到Ci+1和Di+1 对56位的CiDi进行PC-2置换压缩，得到48位的子密钥Ki，i = i + 1，返回第二步，直到生成第16个子密钥Ki 生成过程图解： S-盒前面已经介绍，S-盒用于把6位二进制串转换成4位二进制串，Feistel函数中有8个6位的分组，因此用到了8个不同的S-盒 S-盒原理为： 每一个S-盒是一个4行(编号 0-3)、16列(编号 0-15) 的表，表中元素值是10进制的值 假设 Si 的6位输入为b1b2b3b4b5b6，则由 n = (b1b6)10 确定行号，由 m = (b2b3b4b5)10 确定列号，[ Si ]n,m元素的值的二进制形式即为所要的 Si 的输出 在这里要注意，行号和列号都是从0开始的，这一点与其他地方不同 用一个例子来说明： S1盒的表如图所示： 设S1 的6位输入b1b2b3b4b5b6 = 101100，则： n = (b1b6)10 = (10)10 = 2 m = (b2b3b4b5)10 = (0110)10 = 6 [ S1 ]2,6可通过上表得知是2 2 = (0010)2即为输出 交换置换W将第十六轮迭代生成的串L16R16交换位置，输出R16L16 逆置换IP-1操作类似于IP置换，只是换了置换表为IP逆置换表 模块分解根据DES算法特点，我将算法分解为以下几个模块： 进制转换convert：用于8位的字符串和64位的二进制01字符串互相转换 DES总体结构des：实现DES算法的总体结构，利用到了辅助模块： 循环左移leftshift 生成子密钥createkey 同时在des中会按需调用其他模块，用以算法实现 全局变量globalVar：存放DES算法中需要用到的各种表(如IP置换表) T迭代iteration：描述16轮迭代过程，其中用到了辅助模块： 轮函数feistel 置换transform：进行各种置换：IP置换、IP逆置换、PC-1置换、PC-2置换、E-扩展置换、P-置换 测试main：进行算法的测试，查看算法是否正确 数据结构C++中有bitset这个类库来管理一系列的bit位，但本实验中为了输入输出转换方便，我使用了char来存放一个bit位，用到的其他数据结构只有string 输入的明文是string，经过convert模块转换后成为了每组64位的二进制字符串，字符串用char数组表示，因此最后得到的密文也是每组64位的二进制字符串 密文经过convert模块转换后成为string 算法中还需要自己定义一些数据结构，即各种表，都是二维/三维的char数组 源代码源代码地址：https://github.com/chenf99/DES/tree/master/C%2B%2B 编译运行结果12345PS C:\Users\11638\Desktop\DES\C++&gt; g++ .\main.cpp -o desPS C:\Users\11638\Desktop\DES\C++&gt; ./desplain:TAKERS Championshipencrypt:▊噴。償挒皷煗硵柊decrypt:TAKERS Championship]]></content>
      <tags>
        <tag>DES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-374]]></title>
    <url>%2F2018%2F10%2F28%2Fleetcode-374%2F</url>
    <content type="text"><![CDATA[题目Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... Example 1: 123&gt; Input: nums = [1, 5, 1, 1, 6, 4]&gt; Output: One possible answer is [1, 4, 1, 5, 1, 6].&gt; Example 2： 123&gt; Input: nums = [1, 3, 2, 2, 3, 1]&gt; Output: One possible answer is [2, 3, 1, 3, 1, 2].&gt; Note:You may assume all input has valid answer. Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space? 分析这道题的意思是把一个无序的数组进行摆动排序，即在奇数下标(1, 3, 5, …)的元素值大于它相邻的偶数下标(0, 2, 4, …)的元素值。如果画出元素值大小随下标变化的图像的话，图像就随着下标的增大在上下不断摆动。 题目保证给出的输入一定有对应有效的输出。 我认为这道题的难点主要在于输入的值中可能有很多相同的值，如果值各异的话，通过简单的遍历来进行值的交换即可，每次遍历到的元素只需要与已确定的部分的最后一个元素比较大小。但由于存在相同的值，这种方法会导致相同的值会聚集在一起，无法得到正确结果。 解法一一种比较容易想到的解法是先找到数组的中位数，然后把所有大于中位数的元素放在奇数位置，所有小于中位数的元素放在偶数位置，等于中位数的元素则需要好好考虑，要尽量把它们分开来存放，如果两个等于中位数的元素相邻也是不满足要求的。 首先把数组排序，就能够找到中位数，然后把大于中位数的元素从左往右开始存放到奇数位置，把小于中位数的元素从右往左存放到偶数位置，等于中位数的元素存放在剩余位置。由于数组已经排好序，所以对于奇数位置，等于中位数的元素是放在右边的，而对于偶数位置，等于中位数的元素是放在左边的，这样就一定能够满足要求。所以寻找中位数不能使用nth_element()函数，因为这个函数并不会把数组排序，之后的操作也就无法保证能把等于中位数的元素分离开。 这种解法时间复杂度为排序的复杂度，O(nlogn)，空间复杂度O(n)。 代码1234567891011121314151617181920class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); //nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); int len = nums.size(); int mid = nums[len / 2]; int odd = 1, even = (len % 2) ? len - 1 : len - 2; vector&lt;int&gt; tmp(len, mid); for(int i = len - 1; i &gt; len / 2; i--) &#123; tmp[odd] = nums[i]; odd += 2; &#125; for(int i = 0; i &lt; len / 2; i++) &#123; tmp[even] = nums[i]; even -= 2; &#125; nums = tmp; &#125;&#125;; 解法二解法一的时间复杂度和空间复杂度都不是最优的，在Discuss中有人给出了时间复杂度O(n)，空间复杂度O(1)的解法，用到了virtual indexing和three-way-partition的技巧。 主要想法跟解法一类似，都是去找中位数，然后把大于中位数的元素放奇数位置，小于中位数的元素放偶数位置，等于中位数的元素放在剩余位置。 要解决时间复杂度的问题，可以用nth_element()函数来寻找中位数；要解决空间复杂度的问题，就不能够构造另外的数组，要进行就地置换(in_place)。 现在总结一下需要解决的问题：大于中位数的放1, 3, 5,…位置，小于中位数的放2, 4, 6,…位置，等于中位数的位置可以不变，同时在交换位置的过程中不能开辟额外的内存空间。 通过结合下标映射和3分法可以解决问题：把下标映射成1，3，5，…，2， 4， 6，…的形式，然后利用3分法，大于中位数的放左边，即映射后的1，3， 5，…下标；小于中位数的放右边，即映射后的2，4，6…下标。 映射是return (1 + 2 * index) % (len | 1);，其中len | 1在len为偶数时取len + 1，在len为奇数时取len。映射把从0～len - 1的index映射到1, 3, 5, …, 2, 4, 6, …。 之后就交给三分法来解决问题，只不过用于三分法的数组下标始终是经过映射后得到的下标。 时间复杂度为O(n)，空间复杂度为O(1)。 代码12345678910111213141516171819202122232425class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); int len = nums.size(); int mid = nums[len / 2]; for (int i = 0, left = 0, right = len - 1; i &lt;= right;) &#123; if (nums[mappedIndex(i, len)] &gt; mid) swap(nums, mappedIndex(left++, len), mappedIndex(i++, len)); else if (nums[mappedIndex(i, len)] &lt; mid) swap(nums, mappedIndex(right--, len), mappedIndex(i, len)); else i++; &#125; &#125;private: void swap(vector&lt;int&gt;&amp; nums, int index1, int index2) &#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp; &#125; //把从0～len - 1的index映射到1, 3, 5, ..., 2, 4, 6, ... int mappedIndex(int index, int len) &#123; return (1 + 2 * index) % (len | 1); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-279]]></title>
    <url>%2F2018%2F10%2F21%2Fleetcode-279%2F</url>
    <content type="text"><![CDATA[题目Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example1 123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example2 123Input: n = 13Output: 2Explanation: 13 = 4 + 9. 分析这道题目的意思是给定一个正整数，要求我们找到最少的平方数，它们的和等于这个正整数。 解法一一开始我尝试从这个正整数减去它最大的平方数入手，判断剩下的数能由多少个平方数组成。但这样做的问题是很可能找不到最少的平方数数目，因为剩下那部分数可能只能由1组成，比如12按这种做法得到的结果就是4。 对于这种问题，最好的方法是分解问题成为一个个易求解的子问题，再分别求解。 我分解问题的方法其实也是在前面的想法上进行改进得到的。 假设问题要求解的是num[n]，n为输入的正整数，我们可以把问题分解成： 1num[n] = min(num[n], num[n - i * i] + 1) 其中i是范围在[1, sqrt(n)]的正整数。通过赋值num[0] = 0，我们可以求出很多num[平方数] = 1，这样一层层求解出来就可以得到num[n]了。 代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; num(n + 1, __INT_MAX__); num[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= sqrt(i); ++j) &#123; num[i] = min(num[i - j * j] + 1, num[i]); &#125; &#125; return num[n]; &#125;&#125;; 解法二解法二是我在Discuss中看到的，是一种数学解法，利用到了四平方和定理，简单来说就是任何一个正整数都可以表示成4个平方数之和，因此答案 &lt;= 4。同时这个定理中还有一个公式：4k(8m + 7)，如果一个正整数不满足这个公式，那么它可以表示成3个平方数之和，此时答案 &lt;= 3；反之，满足这个公式的话答案 == 4。还有个重要的性质：就是如果一个数n是4的倍数，那么num[n] = num[n / 4]。 利用这个数学定理，我们可以更加快速地求出这个问题的答案，利用最后那个性质可以把正整数n缩小，很大地简化了后续求解过程。 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;class Solution &#123;public: int numSquares(int n) &#123; //是4的倍数的话可以除以4，不影响结果 while (n % 4 == 0) n /= 4; //满足8m + 7的数 if (n % 8 == 7) return 4; else &#123; //能否拆成两个平方数之和 for (int i = 0; i * i &lt;= n; ++i) &#123; int tmp = sqrt(n - i * i); if (tmp * tmp == n - i * i) &#123; return !!i + !!tmp; &#125; &#125; //拆不了的话答案就一定是3 return 3; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-135]]></title>
    <url>%2F2018%2F10%2F10%2Fleetcode-135%2F</url>
    <content type="text"><![CDATA[题目Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: 123Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: 1234Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. 分析这道题的意思是给排成一排的孩子发糖果，每个孩子都有级别，发糖果必须满足两个要求： 每个孩子至少一个糖果 级别比相邻孩子高的哪个孩子，得到的糖果也要比相邻孩子的多 解法这道题难度虽然被leetcode标记为Hard，但是并不难解决。第一个要求容易满足，主要是需要满足第二个要求，我们通过简单的遍历就可以得到每个孩子所分得的糖果数了。 输入的数组可以划分为三种子数组：从左至右递增的数组、从右至左递增的数组以及级别数相同的子数组。 对于输入[0, 1, 2, 3, 4]，易知所需的最小糖果数为15，每个孩子得到的糖果数为[1, 2, 3, 4, 5]。输入的孩子级别从左至右递增，因此他们得到的糖果数自然也需要从左至右递增。输入从右至左递增的情况也类似。 如果输入的子数组中级别数相同，如[2, 2, 2]，那中间那个孩子的糖果数为1(给中间孩子发满足条件的最少的糖果数)，另外两个孩子的糖果数取决于他们邻居的级别和糖果数。 以从左至右为例，我们采取的遍历的思想为：当前孩子的级别如果比他左边孩子的级别高，而且他的糖果数不比左边孩子的多的话，就把他的糖果数设置为左边孩子的糖果数 + 1(分配满足条件的最少的糖果数)。 但显然一次遍历是不够的，我们需要分别从左边和右边开始进行两次遍历，同时为了方便，统一把初始的糖果数置为0，这样前面讨论的3种情况都可以解决了。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;numeric&gt;using namespace std;class Solution &#123;public: int candy(const vector&lt;int&gt;&amp; ratings) &#123; vector&lt;int&gt; candy(ratings.size(), 0); //从两边开始分别遍历一次 for (int i = 1; i &lt; ratings.size(); ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candy[i] = candy[i - 1] + 1; &#125; &#125; for (int i = ratings.size() - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1] &amp;&amp; candy[i] &lt;= candy[i + 1]) &#123; candy[i] = candy[i + 1] + 1; &#125; &#125; //该函数的第三个参数指定累加的初值 return accumulate(candy.begin(), candy.end(), candy.size()); &#125;&#125;; 算法时间复杂度为O(n),空间复杂度为O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-025]]></title>
    <url>%2F2018%2F10%2F05%2Fleetcode-025%2F</url>
    <content type="text"><![CDATA[题目Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. 分析这道题目的意思是给出一个链表和一个正整数k，把链表按照每k个的顺序反转，即把链表分解成长度为k的子链表，反转这些子链表，然后再连接起来。需要注意的是如果链表长度不是k的整数，最后的那部分子链表长度不为k，则这一部分不需要反转。 解法对于此题，我的想法是写两个函数来解决问题： 分解链表的函数，把链表分解成长度为k的各个子链表 反转一段链表的函数，用于反转分解后得到的子链表 先实现反转一段链表的函数，这个函数比较容易实现，我们也经常遇到这种问题。实现的思路是用curr指针遍历链表，用pre记录curr的前一项，在遍历的过程中，把curr-&gt;next指向pre，再把pre赋值给curr，一直遍历下去，这样就完成了链表的反转，时间复杂度为O(n)，空间复杂度为O(1)。 稍微难一点的是分解链表的函数，因为链表长度未知，在分解完成、反转完成后还要连接各个子链表，因此不仅需要各个子链表的头，还要各个子链表的尾，而为了满足O(1)的空间复杂度，最好是在遍历的过程中分别用两个变量来记录头和尾，而不能另外开辟空间。 我的思路是：遍历一遍链表，通过count来计数，count ！= k时count++，继续遍历；当count == k时即找到一个子链表，反转这个子链表，并与前面已经完成反转操作的子链表连接，count设为0，再继续遍历。 在这之中需要注意几点： 要记录最终链表的头用以返回，这即是第一个反转后的子链表的头 每次分解需要记录子链表的头和尾，即更新curr_head和curr_tail 要注意处理链表长度不是k的倍数和k大于链表长度的情况 弄明白了这几点之后代码也就不难实现了，但这种解法的效率貌似并不高，应该是由于分解链表的效率低，因此还需要找更好的算法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: //反转一段链表 ListNode* reverse_List(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) return head; ListNode *curr = head, *prev = NULL; while (curr-&gt;next != NULL) &#123; ListNode* tmp = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = tmp; &#125; curr-&gt;next = prev; return curr; &#125; //先把整段链表分解成每k个一段，再对每一段进行反转，最后连接起来 ListNode* reverseKGroup(ListNode* head, int k) &#123; int count = 0;//用于计算一段链表的长度 ListNode* tmp = head; ListNode* curr_head = head;//用作小段链表的头 ListNode* curr_tail = NULL;//当前已完成反转部分链表的尾 ListNode* result_head = NULL; while (tmp != NULL) &#123; count++; if (count == k) &#123; ListNode* remaining = tmp-&gt;next; tmp-&gt;next = NULL; curr_head = reverse_List(curr_head);//反转小段链表 if (result_head == NULL) result_head = curr_head; if (curr_tail != NULL) curr_tail-&gt;next = curr_head; while (curr_head-&gt;next != NULL) &#123; curr_head = curr_head-&gt;next; &#125; curr_tail = curr_head; curr_head = remaining; tmp = remaining; count = 0; &#125; else tmp = tmp-&gt;next; &#125; //输入的链表长度不是k的倍数时会剩下未反转的部分链表 if (count != 0 &amp;&amp; curr_tail != NULL) curr_tail-&gt;next = curr_head; //输入的k大于链表长度的情况 else if (count != 0 &amp;&amp; curr_tail == NULL) return head; return result_head; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-032]]></title>
    <url>%2F2018%2F09%2F30%2Fleetcode-032%2F</url>
    <content type="text"><![CDATA[题目Longest Valid Parentheses Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example1 123Input: "(()"Output: 2Explanation: The longest valid parentheses substring is "()" Example2 123Input: ")()())"Output: 4Explanation: The longest valid parentheses substring is "()()" 分析这道题的意思是给出一个只含有小括号符&quot;(&quot;和&quot;)&quot;的字符串，求出这个字符串中能够成功进行括号匹配的子串的长度，虽然看起来与括号匹配类似，但由于是求能够匹配成功的子串，因此难度加大了不少。 解法一开始我致力于在括号匹配算法的基础进行改进，以求得最长的可以匹配的子串。但这个想法似乎很难实现，因为我不知道在括号能够匹配时它的子串中的具体位置，例如： 对于&quot;((()()))&quot;这个字符串，括号匹配算法遍历到第4个字符&#39;)&#39;才能第一次匹配成功,随后在第6，7，8个字符时可以连续匹配成功3次，但是如何知道后两次成功匹配的字符都分别在子串的首尾部呢？这比较难求，我们也不关心这个，因此不如在匹配成功时计算长度。 但是要求出长度也不是那么容易的，因为括号匹配算法遍历字符串时，我们不能预测接下来的字符能否与之前栈里的字符成功匹配，例如： 对于&quot;((()()(()&quot;这个字符串，最大匹配成功的子串长度为4，但要是它后面还有一个字符&#39;)&#39;，即字符串&quot;((()()(())&quot;，那最大匹配成功的子串长度就是8了；如果接下来的字符是&#39;(&#39;，答案就还是4。其中的区别在于，如果两个能成功匹配的子串相邻，那自然就有了更长的符合条件的子串。 那怎么判断相邻的子串呢？考虑到只有遍历到的字符是&#39;)&#39;时才有可能匹配成功，我们可以通过判断匹配后(会弹出栈顶的&#39;(&#39;元素)栈是否为空来入手： 如果栈为空，就代表在这一对匹配的括号前面没有其他符号来阻隔它与之前的子串，即它与之前匹配的子串相邻，可以加长子串了(当然也不一定是前面，毕竟这一对括号可能分别在之前子串的首尾部) 如果栈不为空，那就说明当前匹配的括号与之前子串不相邻，但由于栈中还有&#39;(&#39;字符，可能与之后的字符匹配，因此不需要变化start 算法思路如下： 用变量result和start来记录当前最大匹配的子串长度和当前匹配的子串首字符位置 利用括号匹配算法，遍历字符串，遇到&#39;(&#39;把它的下标压栈，而&#39;)&#39;则不压栈 若遇到&#39;)&#39;，需谨慎处理： 如果栈为空，则由于&#39;)&#39;一定不会与之后的字符匹配，因此前面的子串一定不会与后面的子串相邻了，start = indexOf(&#39;)&#39;) + 1，即现在要匹配的子串首字符从&#39;)&#39;下一个字符开始 如果栈不为空，那一定会匹配(栈里面只有&#39;(&#39;)，因此弹出栈顶，继续判断 如果弹出栈后栈空，则匹配的子串相邻，需要更新result，方法是判断result和当前匹配子串长度哪个大 否则子串不相邻(这是暂时的，因为start还没有变化)，更新result，不需要与之前的子串比较，因为已经比较过了，比较当前匹配的就好 可以找出一些字符串例子来帮助理解这个思路。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;class Solution &#123;public: int longestValidParentheses(string str) &#123; int result = 0, start = 0; stack&lt;int&gt; s; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] == '(') s.push(i); else &#123; if (s.empty()) start = i + 1; else &#123; s.pop(); if (s.empty()) result = max(result, i - start + 1); else result = max(result, i - s.top()); //已经pop过一次了，所以不需要再加1 &#125; &#125; &#125; return result; &#125;&#125;;int main() &#123; Solution s; cout &lt;&lt; s.longestValidParentheses("()(()");&#125; 算法时间复杂度为O(n)，空间复杂度为O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang入门:环境配置]]></title>
    <url>%2F2018%2F09%2F27%2FGolang%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言在前一篇博客中我们学习了如何配置Centos私有云，下一步我们将要学习Go语言编程。 什么是Go语言？ Go语言由Google于2009年发布，它是一种静态强类型、编译型、并发型、解释型的编程语言，并且具有便利的垃圾回收和强大的运行时反射。 Go语言是简洁的和有效率的，实用性很强。 要学习Go语言编程，第一步就是要学习配置需要的相关环境。 Centos安装Golang有两种方法可以安装Golang: 下载最新版本的go1.11.linux-amd64.tar.gz，然后解压并配置环境变量，这种方法相对复杂些 利用系统包管理工具直接下载Golang，这种方法简单。但Golang不是最新版本的，但也不影响使用 安装最新版Golang下载二进制包可以去官网下载，也可以利用wget工具自动下载： 1wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz 然后解压，可以指定解压到的目录： 1sudo tar -zxvf go1.11.linux-amd64.tar.gz -C /opt/ 记得一定要加上-C(大写)这个参数，创建默认文件夹才能被成功解压，否则报错如下： 设置环境变量，sudo vi /etc/profile，在底部加上 12export GOROOT=/opt/goexport PATH=$PATH:$GOROOT/bin 然后source /etc/profile更新环境变量，再使用go version检查配置是否正常： 我们可以使用go env来查看Go的环境变量，其中比较重要的是GOROOT和GOPATH，GOROOT里面放置系统代码和中间文件，而GOPATH可以作为我们的工作空间。GOROOT和GOPATH中都有三个子目录： src:存放被组织成包的源代码(.go .c .h .s等) pkg:存放编译后生成的文件(.a) bin:存放编译后生成的可执行文件 为了方便，可以把bin加入到 $PATH 变量中，便于直接运行Go程序 创建工作空间： 1mkdir $HOME/gowork 修改配置文件，sudo vi /etc/profile： 12export GOPATH=$HOME/goworkexport PATH=$PATH:$GOPATH/bin 更新配置文件后可以通过go env来查看是否设置成功。 利用包管理工具安装Golang1sudo yum install golang 查看Golang安装的目录： 1rpm -ql golang |more 测试安装： 1go version 然后是创建工作空间和配置GOPATH、PATH这两个环境变量，步骤同上。 安装工具和插件安装VSCode安装过程参考官方给出的教程： 123456sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo'yum check-updatesudo yum install code 然后就可以打开VSCode了。 编写Hello，World首先创建源代码目录： 1mkdir $GOPATH/src/github.com/github-user/hello -p 然后使用VSCode编写一个hello.go文件(VSCode会提示安装Go相关插件)： 1234567package mainimport "fmt"func main() &#123; fmt.Printf("hello, world\n")&#125; 在终端运行： 安装git客户端由于Go语言的插件主要在github上，因此git客户端必不可少 1sudo yum install git 但这样安装的git太老，总觉得用着不舒服，因此我选择更新： 首先移除安装的旧版本 1sudo yum remove git 安装所需的软件包 123sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develsudo yum install gcc perl-ExtUtils-MakeMaker 去官网下载安装包并解压 12wget https://www.kernel.org/pub/software/scm/git/git-2.9.2.tar.gztar -zxvf git-2.9.2.tar.gz 编译安装 123cd git-2.9.2make prefix=/usr/local/git allsudo make prefix=/usr/local/git install 配置环境变量，在/etc/profile中添加 1export PATH=$PATH:/usr/local/git/bin 更新环境变量 1source /etc/profile 如果此时查看git仍是旧版本，执行以下语句： 1234sudo yum remove -y gitsource /etc/bashrccd ~/git --version 安装Go的一些工具当我们进入VSCode打开hello.go时，VSCode会提示我们安装go-outline，点击Install却失败了，需要手动安装： 下载源码到本地 123456# 创建文件夹mkdir -p $GOPATH/src/golang.org/x/# 下载源码go get -d github.com/golang/tools# copy cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf 安装工具包 1go install $GOPATH/src/golang.org/x/tools/go/buildutil 重启VSCode，按照提示安装即可 安装运行 hello world 1go install github.com/github-user/hello 安装go tour1go get -u github.com/Go-zh/tour/gotour 安装好之后会在工作空间的 bin 目录中创建一个 gotour 可执行文件 运行Go语言之旅 1go tool tour 绑定git远程仓库之前我们已经在github.com文件夹下创建了与自己的github账户同名的文件夹，现在需要把这个文件夹绑定git上的远程仓库，用来保存我们以后编写的Go语言代码。 在github上创建一个仓库用于同步之后就可以来绑定远程仓库了，本地执行指令如下： 1234git init git config --global user.name "xxx"git config --global user.email "xxx@xxx"git remote add origin your_repo_url 以上传hello文件夹为例： 123git add hello/git commit -m 'first commit'git push -u origin master git相关指令详见git学习笔记]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>配置环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-042]]></title>
    <url>%2F2018%2F09%2F23%2Fleetcode-042%2F</url>
    <content type="text"><![CDATA[题目Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 分析这道题目的意思是给出一个数组来代表柱子的高度，让我们计算可以有多少水陷在这些柱子围成的空隙中，注意最左边和最右边是没有阻挡作用的。 解法一要让水陷入，就必须有左右各一个柱子比中间的所有柱子都高，因此我的想法是用一个bottom变量来记录矮一点的左边柱子，用一个栈stack来存放两个柱子中的矮柱子高度，当遍历到高度&gt;=bottom的柱子时就形成了一个可以陷入水的空隙，再遍历数组去找到所有可能的这种空隙。算法思路如下： 数组arr长度&lt;=2时无法形成空隙，必为0 bottom = arr[0]，stack&lt;int&gt; s 1234for i : arr if (bottom &lt;= arr[i]) //计算空隙中的水量 else s.push(arr[i]) 而计算空隙中的水量也很简单，其实就是个计算面积的问题：以矮柱子bottom的高度为宽，中间柱子数bar_num为宽计算整个长方形面积，再减去中间柱子的总高度rock即可：water = bottom * bar_num - rock 要得到中间的柱子数bar_num和中间柱子的总高度rock，只需一步步弹出栈即可 循环部分的代码如下： 1234567891011121314151617for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i;&#125; else s.push(height[i]);&#125; 但这个思路还没有完全解决问题，因为我假设的bottom是左边的柱子，然后通过找高度&gt;=bottom的柱子来寻找空隙，但是如果没有高度&gt;=bottom的柱子也是可能存在空隙的，比如例子中最右边的那个空隙。解决办法是记录最高的那个柱子，然后再从右边以同样的方法遍历，直到最高的这个柱子为止，来寻找那些第一次遍历时错过的空隙(十分暴力的解法)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; stack&lt;int&gt; s; int bottom = height[0]; int top = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s.empty()) &#123; int tmp = s.top(); s.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; &#125; else s.push(height[i]); &#125; stack&lt;int&gt; s2; bottom = height[height.size() - 1]; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int rock = 0, bar_num = 0; while (!s2.empty()) &#123; int tmp = s2.top(); s2.pop(); rock += tmp; bar_num++; &#125; int water = bottom * bar_num - rock; result += water; bottom = height[i]; &#125; else s2.push(height[i]); &#125; return result; &#125; &#125;; 这种解法的时间复杂度是O(n2)，而且最坏情况(最高的柱子为最左边的柱子)下需要遍历两次，效率很低了，必须得优化下。 解法二我的优化思路是从堆栈入手，一开始我使用栈是因为想用它来管理那些中间的矮柱子，但其实好像并不需要，因为我只需要得到3条关于它们的信息： 高度&lt;=bottom 矮柱子个数 矮柱子总高度 这3条信息在遍历的过程中都可以得到，而额外弹出栈还需要再套一个循环，完全没必要，因此使用堆栈这一点是显而易见需要优化的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt;= 2) return 0; int result = 0; int bottom = height[0]; int top = 0; int rock = 0, bar_num = 0; for (int i = 1; i &lt; height.size(); ++i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; top = i; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; bottom = height[height.size() - 1]; rock = bar_num = 0; for (int i = height.size() - 2; i &gt;= top; --i) &#123; if (bottom &lt;= height[i]) &#123; //计算水量 int water = bottom * bar_num - rock; result += water; bottom = height[i]; rock = bar_num = 0; &#125; else &#123; rock += height[i]; bar_num++; &#125; &#125; return result; &#125; &#125;;int main() &#123; vector&lt;int&gt; test = &#123;0,1,0,2,1,0,1,3,2,1,2,1&#125;; Solution s; cout &lt;&lt; s.trap(test);&#125; 优化后的代码时间复杂度为O(n)，但是最坏情况下还是可能遍历两次，因此我还需要找出一次遍历就能解决问题的算法，这可能要同时从两边开始遍历。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-023]]></title>
    <url>%2F2018%2F09%2F16%2Fleetcode-023%2F</url>
    <content type="text"><![CDATA[题目Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 分析这道题的描述十分简单，要求也清晰，就是要我们把k个有序的链表合并成一个有序的链表，我们熟悉的应该是合并两个链表，但这里链表数目增加了，算法的设计就自然变难了。 合并两个有序链表我们先回顾经典的合并两个链表的问题，最好的方法如下： 从合并两个链表头节点开始，比较两个链表头节点值的大小，若list的头节点值更小，则把result_list的头指针指向这个节点，并把list的头节点往后移一次 循环判断剩余节点：继续比较两个链表头节点大小，若list的头节点值更小，则把result_list尾节点的next指针指向list的头节点，并把list的头节点往后移一次。推出循环的条件是两个链表中有一个头节点指针为空 使result_list的尾节点的next指针指向不为空的那个链表的头节点 代码如下： 1234567891011121314151617181920212223242526272829//list1和list2分别指向要合并的两个有序链表的头节点 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; 这种方法的时间复杂度最大为O(n)，而空间复杂度为O(1)，效率挺不错了。 合并k个有序链表有了前面的基础后再回到这个题目，很容易会想采用同样的方法：比较这k个链表的头节点的值，然后把最小的那个头节点作为合并后链表的头节点，再不断循环。但这样的话每得到一个正确位置的节点就要循环一次，开销太大了，不适用于此种情况。 鉴于最近课上一直在讲分治算法，很自然地我就想到了用分治法来解决这个问题。既然一次性合并k个链表是困难的，而一次性合并两个链表是容易的，那使用分治法来把这个大问题(合并k个)分成很多个小问题(合并2个)，再一一解决，就很容易了。 解法按照前面的思路，解决方法可以分为以下几个步骤： 使用二分法把这k个链表不断递归分成两个子部分，最终得到的子部分所含有的链表数全为1，这是最底层 最底层不需要合并，因为一个链表的合并自然就是它本身 向上递归，倒数第二层的合并全是两个有序链表的合并，这在之前已经得到解决，合并之后链表数减半，再继续递归合并，一层层合并完就得到了最终的链表 这种方法的时间复杂度是O(Nlogk)，总共分成了logk层，而每一层中合并两个有序链表总共的时间复杂度为O(N)，因此总的就为O(Nlogk) 至于空间复杂度，我们在合并两个链表的过程中并没有额外开辟新的空间，而是仅通过改变指针的指向就实现了合并，因此为O(1) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.Example:Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;private: //合并两个有序链表 ListNode* merge(ListNode* list1, ListNode* list2) &#123; if (list1 == NULL) return list2; else if (list2 == NULL) return list1; ListNode* head = NULL; if (list1-&gt;val &lt; list2-&gt;val) &#123; head = list1; list1 = list1-&gt;next; &#125; else &#123; head = list2; list2 = list2-&gt;next; &#125; ListNode* tmp = head; while (list1 != NULL &amp;&amp; list2 != NULL) &#123; if (list1-&gt;val &lt; list2-&gt;val) &#123; head-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; head-&gt;next = list2; list2 = list2-&gt;next; &#125; head = head-&gt;next; &#125; if (list1 == NULL) head-&gt;next = list2; else head-&gt;next = list1; return tmp; &#125; ListNode* mergelist(vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123; int mid = (left + right) / 2; if (left &lt; right) &#123; ListNode* list1 = mergelist(lists, left, mid); ListNode* list2 = mergelist(lists, mid + 1, right); ListNode* mergedList = merge(list1, list2); return mergedList; &#125; return lists[left]; &#125;public: //思路:先采用分治法把问题分成两个子问题(不断向下递归分解)，到最后一层得到的是单独的一条链表 // 合并两条链表为一条，向上递归继续合并 // 思路很类似于归并排序 ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; return mergelist(lists, 0, lists.size() - 1); &#125;&#125;;int main() &#123; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F09%2F13%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git学习笔记 前言git作为世界上最先进的分布式版本控制系统，为我们管理自己的代码提供了很多便利，它的指令强大且复杂多样，而我一直都只用着git add、git push等最简单的指令，十分惭愧。希望这篇笔记能帮助我之后的git学习，也帮助到有需要的同学。 配置git12345678910111213#查看版本信息git --version#查看配置信息git config --list#查看配置信息，输入后会启动默认的git编辑器，可以编辑用户名和邮箱，#git的配置文件在C:Users\用户名\目录下，是.gitconfig文件git config -e --global#分别为设置用户名和邮箱，如果不加最后面的参数，就是查看用户名和邮箱git config --global user.name "xxx"git config --global user.email "xxx@xxx" 新建仓库12345#在指定目录初始化仓库，会创建一个.git隐藏文件夹，默认在当前目录下初始化仓库git init [dir]#下载一个项目和代码历史，会在本地当前目录自动创建一个项目名的文件夹，用于存放项目git clone [url] 增加和删除文件123456789101112131415161718#添加文件到暂存区，参数是一个.或-A的话为添加所有文件git add [file1] [file2]...#添加指定目录到暂存区，包括该目录的子目录git add [dir]#添加每个变化前，都会要求确认#对于同一个文件的多处变化，可以实现分次提交git add -p#删除工作区文件，并将这次删除放入暂存区git rm [file1] [file2]...#把暂存区的文件删除，但该文件会保留在工作区git rm --cached [file]#重命名文件，并将这次命名放入暂存区git mv [file-original] [file-renamed] 提交修改123456789101112131415161718#提交暂存区到仓库区，message用于描述这次提交git commit -m [message]#提交暂存区的指定文件git commit [file1] [file2]... -m [message]#提交工作区自上次commit之后的变化，直接到仓库区git commit -a#提交时显示所有diff信息git commit -v#使用一次新的commit，替代上一次提交#如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]#重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839#列出所有本地分支git branch#列出所有远程分支git branch -r#列出所有本地分支和远程分支git branch -a#新建一个分支，但依然停留在当前分支git branch [branch-name]#新建一个分支，并切换到该分支git checkout -b [branch]#新建一个分支，指向指定commitgit branch [branch] [commit]#新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]#切换到指定分支，并更新工作区git checkout [branch-name]#建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]#合并指定分支到当前分支git merge [branch]#选择一个commit，合并进当前分支git cherry-pick [commit]#删除分支git branch -d [branch-name]#删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526#列出所有taggit tag#新建一个tag在当前commitgit tag [tag]#新建一个tag在指定commitgit tag [tag] [commit]#删除本地taggit tag -d [tag]#删除远程taggit push origin :refs/tags/[tagName]#查看tag信息git show [tag]#提交指定taggit push [remote] [tag]#提交所有taggit push [remote] --tags#新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#显示有变更的文件git status#显示当前分支的版本历史git log#显示commit历史，以及每次commit发生变更的文件git log --stat#搜索提交历史，根据关键词git log -S [keyword]#显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s#显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature#显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]#显示指定文件相关的每一次diffgit log -p [file]#显示过去5次提交git log -5 --pretty --oneline#显示所有提交过的用户，按提交次数排序git shortlog -sn#显示指定文件是什么人在什么时间修改过git blame [file]#显示暂存区和工作区的差异git diff#显示暂存区和上一个commit的差异git diff --cached [file]#显示工作区与当前分支最新commit之间的差异git diff HEAD#显示两次提交之间的差异git diff [first-branch]...[second-branch]#显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"#显示某次提交的元数据和内容变化git show [commit]#显示某次提交发生变化的文件git show --name-only [commit]#显示某次提交时，某个文件的内容git show [commit]:[filename]#显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223#下载远程仓库的所有变动git fetch [remote]#显示所有远程仓库git remote -v#显示某个远程仓库的信息git remote show [remote]#增加一个新的远程仓库，并命名git remote add [shortname] [url]#取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]#上传本地指定分支到远程仓库git push [remote] [branch]#强行推送当前分支到远程仓库，即使有冲突git push [remote] --force#推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031#恢复暂存区的指定文件到工作区git checkout [file]#恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]#恢复暂存区的所有文件到工作区git checkout .#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]#重置暂存区与工作区，与上一次commit保持一致git reset --hard#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]#重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]#新建一个commit，用来撤销指定commit#后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]#暂时将未提交的变化移除，稍后再移入git stashgit stash pop 理解工作区和暂存区先上图： 工作区就是电脑上的文件夹 在工作区中有一个隐藏的.git文件夹，它不属于工作区，是git的版本库，这里包含所有git操作所需要的东西 版本库中最重要的东西就是暂存区(index/stage)，还有自动创建的第一个分支master和指向master的指针HEAD 下面通过简单的指令来理解暂存区的概念： 首先git init初始化一个空的版本库，git会自动帮我们创建一个分支master，此时的git commit就是往master分支上修改。假设工作区已经有一个readme.txt文件，那此时工作区有一个文件，暂存区和版本库都没有文件： 我们先对readme.txt进行修改，内容随意；再在工作区新增一个文件LICENSE，然后使用git status来查看状态： 可以看到readme.txt被修改了，而LICENSE文件还没有被git add过，因此是Untracked的 使用git add来把这两个文件从工作区复制到暂存区，然后用git status查看状态： 此时暂存区的状态如下图： 然后使用git commit来把暂存区中的文件提交到分支： 此时的版本库如下，暂存区已经没有任何内容了： gitignore有时候我们需要把一些文件放到git的工作区当中，但是又不想提交它们，.gitignore配置文件就是用来忽略文件的。 不用担心不会写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 需要注意的是，.gitignore文件也是需要放入到版本库中的，并且也可以对它进行版本管理。前面我们知道git status会显示一些Untracked的文件，看起来很不舒服，但如果我们利用.gitignore来忽略该文件，git status就会显示working directory clean了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-031]]></title>
    <url>%2F2018%2F09%2F09%2Fleetcode-031%2F</url>
    <content type="text"><![CDATA[题目Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1234&gt; 1,2,3 → 1,3,2&gt; 3,2,1 → 1,2,3&gt; 1,1,5 → 1,5,1&gt; 分析这道题目的意思是给出一个序列，要求给出它的下一个置换，即按照字典序比它大的最小的那个序列。如果找不到这样的置换，那么就输出最小的那个序列(即按升序排序)。in-place的意思是让我们在交换元素时不要花费过多空间，花费的额外空间只能是常量。 解法首先要判断是否有下一个置换，这可能不太直观，但判断没有下一个置换是很容易的：当序列已经是降序时就已经是最大的序列了，当然就不存在下一个置换，此时只要将它反过来就可以得到所求序列。因此，只要序列不是降序的，那么置换就存在。 要判断序列是否是降序，可以采取从后往前遍历的方式，如果相邻的两个元素，后面那个(right)一直比前面那个(left)小，那么就是降序的。当我们找到这样两个元素:right &gt; left时，就找到求下一个置换的突破口了，因为这意味着在left后面的那一段子序列都是降序的，已经不存在下一个置换了，即是时候把left这个位置的元素的值变大了。 找到这样的left之后我的第一个想法是把它与后面那段子序列中比它大的最小的那个元素交换位置，再把子序列排序，这样就得到了比原始序列大的最小的序列，即下一个置换。这样的确是可以得到答案的，但是这样我们就使用了排序了，复杂度就成了O(n2)，算法自然就没那么好了。 实际上，我们知道那段子序列是降序的，那么只要把它反过来就是一个升序的序列了，这样的时间复杂度是O(n)，排好序后再去找比left大的最小的那个元素，交换它们的位置就好了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 1) return; bool flag = false; //是否存在下一个置换 int index; for (index = len - 1; index &gt; 0; --index) &#123;//找left和right if (nums[index] &gt; nums[index - 1]) &#123; flag = true; break; &#125; &#125; if (flag == false) reverse(nums.begin(), nums.end());//没有下一个置换 reverse(nums.begin() + index, nums.end()); int small_index = -1; for (int i = index; i &lt; len; ++i) &#123;//找比left大的最小元素 if (nums[i] &gt; nums[index - 1]) &#123; if (small_index == -1) small_index = i; else if (nums[i] &lt; nums[small_index]) small_index = i; &#125; &#125; int temp = nums[small_index]; nums[small_index] = nums[index - 1]; nums[index - 1] = temp; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox + CentOS让PC提供云服务]]></title>
    <url>%2F2018%2F09%2F09%2Fcentos-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BA%91%2F</url>
    <content type="text"><![CDATA[前期准备安装Git客户端直接百度git for windows即可找到官网的下载链接，安装好对应系统版本后应在任何地方右键鼠标都会出现git bash here： 安装VirtualBox直接到官网下载最新版本的安装包并安装，在Downloads界面选择windows版本的： 配置VirtualBox 点击管理-&gt;全局设定-&gt;常规，设置默认虚拟电脑存储位置，最好把默认的C盘路径改掉，方便自己查找，同时也不消耗系统盘空间。 创建虚拟机内部虚拟网络，使得 Vbox 内部虚拟机可以通过它，实现虚拟机之间、虚拟机与主机的通讯： 管理-&gt;主机网络管理器-&gt;创建，创建一块虚拟网卡，并把IPv4地址设为：192.168.100.1/24，这是虚拟内部网络host的默认地址(这一步好像有同学创建不了，据说回退到4.3版本可以，但他直接换Vmware了…) 用cmd输入ipconfig可以查看到刚创建的网卡VirtualBox Host-Only Network #2: 第一个是本机的网卡，可以通过它看到本机的ip地址，这在之后会有用到。 下载CentOS镜像直接到官网下载Minimal ISO镜像即可，点击Minimal ISO后进入下载界面选第一个就好了 安装虚拟机安装第一个虚拟机进入VirtualBox，点击新建，在名称那里输入centos，就会自动选择类型和版本了： 注意：如果没有64位选择的话，有几种可能： 电脑不是64位的 电脑未开启硬件可虚拟化，具体解决方法是进入BIOS把对应可虚拟化的选项设为enable,一般是Intel Virtual Technology 电脑开启了hyper-v，解决方法是进入控制面板-&gt;卸载程序-&gt;启用或关闭Windows功能，取消选择hyper-v即可，重启就可以了 选好后继续安装，点击下一步，分配内存依据自己电脑配置，2G差不多了，然后创建虚拟硬盘，选择现在创建虚拟硬盘，文件类型选择VDI，动态分配和固定大小按自己个人喜好选就好，文件位置一般会自动选择在之前设置的默认虚拟电脑位置文件夹下，大小选择分配30G，方便以后扩展，然后就创建好了。 接下来选择刚创建的虚拟机点击设置，在系统那里把启动顺序设为硬盘第一(不然装好系统后再次启动可能又会进入安装系统界面)；存储那里点击没有盘片： 然后选择之前下载的Minimal ISO；在网络那里第一块网卡默认NAT，第二块网卡选择Host-Only,接口就是前面创建的虚拟网卡： 设置好之后就可以点击启动来安装系统了，选择Install Centos 7，选择语言后点击继续， 在这个界面要注意两个地方，一个是黄色感叹号那个选项，点击进入后选择安装位置，就选之前分配的虚拟硬盘，然后还要注意点击NETWORK &amp; HOST NAME，进去把网络连接打开， 然后就可以安装了，在这个过程中还可以设置root密码和添加用户。 安装好之后进入系统，首先进行升级OS内核： 获取wget：sudo yum install wget 配置源163源或者阿里云源： 具体操作为(以163源为例): 备份/etc/yum.repos.d/CentOS-Base.repo(即改名): 1sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 进入yum源配置文件：cd /etc/yum.repos.d 下载网易163源： 1sudo wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 下载好后把163源设置为默认源： 1sudo mv CentOS7-Base-163.repo CentOS-Base.repo 然后生成缓存： 12yum clean allyum makecache 升级OS内核：sudo yum update 升级内核之后进行下一步，检查网卡配置： 输入nmtui，配置第二块网卡地址： 选择第一项，然后选择第二个网卡的edit: 在IPv4那里点击Show，在下面的Addresses点击Add，配置第二块网卡地址，格式如192.168.100.50/24, 然后退出nmtui界面。 ping主机，如ping 192.168.100.1 第一个虚拟机的操作完成，关闭虚拟机。 安装第二个虚拟机利用虚拟机复制功能，直接获取新虚拟机：右键之前创建的虚拟机，选择复制，为新虚拟机取名并一定要选择重新初始化所有网卡的 MAC 地址： 然后选链接复制，完成。 启动新的虚拟机，配置主机名和第二块网卡： 配置主机名要使用sudo nmtui，修改网卡地址操作与之前相同，但地址变为了192.168.100.100/24。改好后回退到nmtui的第一个界面，选择第二项来激活第二个网卡，两个网卡名前面都有*号就表示都已激活。 再回到nmtui的第一个界面选第三项，更改主机名，改完后退出，重启。 重启后需重新激活第二个网卡，在windows上进入git bash，ping刚才修改的地址，即ping 192.168.100.100： 通过ssh来访问该虚拟机。到官网下载putty,安装后启动，输入虚拟机第二块网卡的地址，点击open即可连接到虚拟机(windows需启动git bash)：经老师提示发现windows安装了git bash(Unix命令行模拟环境)就有ssh客户端了，可以通过git bash来进行ssh连接，例如我的虚拟机地址是192.168.100.4,则ssh连接的命令为 1ssh [用户名]@[虚拟机地址] 相应操作为： 此时已经差不多完成了，能通过ssh访问到虚拟机就已经搭好私有云环境了，但为了centos更方便使用，继续安装centos桌面： 首先重新配置虚拟机的CPU、内存、显存，因为使用centos桌面对配置要求更高。先关闭虚拟机，选择对应的虚拟机后点击设置来进行配置，CPU 1~2个，内存2G或4G，显存越大越好，同时勾选启动3D加速 启动虚拟机，安装桌面sudo yum groupinstall &quot;GNOME Desktop&quot;,这个很大，耗费时间比较长，需要耐心等待，如果下载不成功，可能需要更换yum源 安装好后设置启动目标为桌面，然后重启: 1ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target 此时我们已经可以通过图形化界面来使用centos，但因为虚拟机对鼠标的捕获很不友好，导致使用很不方便，而且也不能全屏，那么就需要安装VirtualBox的扩展功能了： 先安装kernel-devel和gcc：sudo yum install -y kernel-devel gcc 点击VirtuaBox的设备-&gt;安装增强功能，此时可能会报错： 这个错误挺常见的，也容易解决： 弹出后再选择安装增强功能就好了： 点击Run即可开始安装。 装好之后重启时突然报错：Failed to load selinux policy.然后就一直卡在进度条满的状态，无法进入系统，重启很多次也没用，上网查之后发现是因为/etc/selinux/config配置文件不对，虽然我没有修改这个文件，但还是试了试网上方法： 首先在启动时选择启动项的界面按e进入grub编辑界面： 进入grub编辑界面后找到linux16那一行，在最后面的LANG=zh_CN.UTF-8之后空格，加上selinux=0，如上图所示，然后Ctrl + X启动即可进入系统 进入系统后当然要解决这个问题了，sudo vi /etc/selinux/config,可以看到SELINUX=enforcing,我们要做的是改成disabled,且记SELINUXTYPE=targeted原始配置不用改！ 解决上个那个错误后重启就发现增强功能已经装好了，鼠标可以自由移动，也可以全屏了。 接下来安装Google Chrome(可选)： 直接去官网下载可能会被墙，可以移步国内新浪科技网下载，选择正式版RPM，直接下载 进入下载的安装包所在路径，利用yum来安装sudo yum localinstall google-chrome-stable_current_x86_64.rpm,yum会自动分析依赖，并完成安装 在这里插入一个可能的问题：有了图形化界面后我们就可以很方便地通过设置来把第二块网卡设置自动激活了，避免每次开机都要手动激活的痛苦。在这个过程中我发现了一个问题，貌似系统把我之前设置的第二块网卡的IPv4地址修改了： 现在的地址是192.168.100.4，而之前我是把它设置成了192.168.100.100，而且貌似修改后重启又会变成这个，干脆就使用这个地址吧，在使用ssh访问的时候要注意IP地址的变化。 使用远程桌面访问虚拟机安装扩展包首先关闭所有虚拟机，然后去VirtualBox官网下载扩展包，在下载界面选择VirtualBox 5.2.18 Oracle VM VirtualBox Extension Pack(扩展包版本要与VBox版本相同)： 下载好后点击管理-&gt;全局设定-&gt;扩展，点击添加新包，找到正确的扩展包并添加 装好扩展包后重启Windows(注意不是重启虚拟机) 设置虚拟机端口点击对应的虚拟机，点击设置后选择显示，在远程桌面那里启用服务器，然后设置端口号，这里需要注意每台虚拟机的端口号必须不同，因此最好手动修改端口号而不是使用默认。认证方式选择空，我使用外部的认证方式无法连接： 使用远程桌面直接在win10小娜姐姐那里输入远程，就可以启动windows自带的远程桌面连接，在计算机一栏那里输入的地址为本机IP地址:端口号，注意是本机地址，不是虚拟机的地址！！ 再点击连接，就成功啦： 注： 部分同学发现在不开启第二块网卡时虚拟机可以ping到192.168.100.1,但开启了第二块网卡之后就不行了，经大佬提示后发现是windows防火墙的问题…关闭之后就好了，不过没有必要，因为已经可以实现远程访问了。]]></content>
      <categories>
        <category>服务计算课程</category>
      </categories>
      <tags>
        <tag>配置环境</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-004]]></title>
    <url>%2F2018%2F09%2F07%2Fleetcode-004%2F</url>
    <content type="text"><![CDATA[题目Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析这个题目的意思是给出两个已排好序的数组，要求我们给出包含两个数组中所有数的中位数。我首先想到的方法是利用两个循环变量i， j来同时遍历这两个数组 nums1、nums2 ，当 nums1[i] &lt; nums2[j]时i++ ，否则 j++ ，并且选出小的那个数，直到总共遍历了(m + n) / 2 个元素，有点类似于合并两个有序链表的算法。此时就可以找到中位数了： 如果总数是奇数，那么中位数就是最后一个选出来的数 如果总数是偶数，那么中位数就是最后两个选出来的数的平均数 代码如下： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m == 0) return n % 2 == 0 ? (nums2[n/2 - 1] + nums2[n/2]) / 2.0 : nums2[n/2]; else if (n == 0) return m % 2 == 0 ? (nums1[m/2 - 1] + nums1[m/2]) / 2.0 : nums1[m/2]; int mid = (m + n) / 2; vector&lt;int&gt; sortedArr; for (int i = 0, j = 0; i + j &lt;= mid; ) &#123; if (i == m) sortedArr.push_back(nums2[j++]); else if (j == n) sortedArr.push_back(nums1[i++]); else if (nums1[i] &lt;= nums2[j]) sortedArr.push_back(nums1[i++]); else sortedArr.push_back(nums2[j++]); &#125; return (m + n) % 2 == 0 ? (sortedArr[mid - 1] + sortedArr[mid]) / 2.0 : sortedArr[mid]; &#125;&#125;; 这种方法的时间复杂度是 O((m + n) / 2), 并不满足题目要求的O(log(m + n)) ,因此还是得找效率更高的方法。 解法实际上看到有 log 的复杂度，我们就应该想到要使用分治法，但这题要怎么使用二分法来把两个有序数组合并起来并找到中位数呢？其实，我们并不需要非得这样做，从中位数的定义入手，我们可以知道，如果数组中的一个数在把数组分成长度相等的两部分，且一部分的数值总大于等于另一部分，那这个数就是中位数，即： 把数组nums1 分成两个部分： 1nums1[0],nums1[1]...nums1[i - 1] | nums1[i], nums1[i + 1]...nums[m - 1] 左边部分数目为i，右边部分数目为m - i且 max(left) &lt;= min(right)当i = m - i 时（nums1[i - 1] + nums1[i]) / 2就是中位数 同理，我们无需把两个数组合并起来排序再找中位数，只需要把它们分成两个长度相等的部分，并使max(left) &lt;= min(right)就可以找到中位数了，即： 12nums1[0]...nums1[i - 1] | nums1[i]...nums1[m - 1]nums2[0]...nums2[j - 1] | nums2[j]...nums2[n - 1] 长度相等即: i + j = m - i + n - j ,当总长度为奇数时左边会比右边少一个 max(left) &lt;= min(right) 即: nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]。 那么现在我们的问题就变成了找到这样的 i和j来满足上面两个条件。 i 的范围是 [0, m] ，由第一个条件可以知道 j = (m + n) / 2 - i ,当 m &lt;= n 时 j &gt;= 0 ，否则为负数 现在我们就可以用二分法来解决这个问题了，伪代码如下： 123456781.imin = 0, imax = m2.j = (m + n) / 2 - i3. if nums1[i - 1] &gt; nums2[j] imax = i - 1 //i较大，因此需要减小遍历i的范围 else if nums2[j - 1] &gt; nums1[i] imin = i + 1 //i较小，因此需要增大遍历i的范围 else //找到了合适的i if (m + n) % 2 == 0 return (max(left) + min(right)) / 2.0 else return min(right) 当然我们需要考虑临界问题：i = 0, i = m, j = 0, j = n时怎么办？访问nums1[i - 1],nums2[j],nums2[j - 1],nums1[i]是可能越界的。 实际上，由j = (m + n) / 2 - i ，0 &lt; i &lt; m， n &gt;= m可知0 &lt; j &lt; n，因此我们只需要判断i的临界范围就可以了。 对于nums1[i - 1] &gt; nums2[j],需加上i &gt; imin的判断，防止读取到nums1[-1]和nums2[n] 对于nums2[j - 1] &gt; nums1[i],需加上i &lt; imax的判断，防止读取到nums2[-1]和nums1[m] 最终代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(); int n = nums2.size(); if (m &gt; n) &#123; //确保n&gt;=m nums1.swap(nums2); int temp = m; m = n; n = temp; &#125; int imin = 0, imax = m, mid = (m + n) / 2; while (imin &lt;= imax) &#123; int i = (imin + imax) / 2; int j = mid - i; if (i &gt; imin &amp;&amp; nums1[i - 1] &gt; nums2[j]) imax = i - 1; else if (i &lt; imax &amp;&amp; nums2[j - 1] &gt; nums1[i]) imin = i + 1; else &#123;//找到了使max(left) &lt; min(right)的i int minRight; if (i == m) minRight = nums2[j]; else if (j == n) minRight = nums1[i]; else minRight = min(nums1[i], nums2[j]); if ((m + n) % 2 != 0) return minRight; int maxLeft; if (i == 0) maxLeft = nums2[j - 1]; else if (j == 0) maxLeft = nums1[i - 1]; else maxLeft = max(nums1[i - 1], nums2[j - 1]); return (maxLeft + minRight) / 2.0; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
</search>
